<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="Sunny Cho">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="QuantPsy"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="QuantPsy"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - QuantPsy</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">QuantPsy</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/22/cm-review-1-1/">
                [Computational Modeling] Review (1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-22</span>
            
            
            
                <span class="category">
                    <a href="/categories/computational-modeling/">Computational Modeling</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Computational-Modeling-Review"><a href="#Computational-Modeling-Review" class="headerlink" title="Computational Modeling Review"></a>Computational Modeling Review</h1><h5 id="본-포스팅은-“Computational-Models-of-Cognition-and-Behavior-2018-”와-“Bayesian-Cognitive-Modeling”을-정리한-내용입니다"><a href="#본-포스팅은-“Computational-Models-of-Cognition-and-Behavior-2018-”와-“Bayesian-Cognitive-Modeling”을-정리한-내용입니다" class="headerlink" title="본 포스팅은 “Computational Models of Cognition and Behavior(2018)”와 “Bayesian Cognitive Modeling”을 정리한 내용입니다."></a>본 포스팅은 “Computational Models of Cognition and Behavior(2018)”와 “Bayesian Cognitive Modeling”을 정리한 내용입니다.</h5><p><br></p>
<h4 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h4><h5 id="Models-and-Theories-in-Science"><a href="#Models-and-Theories-in-Science" class="headerlink" title="Models and Theories in Science"></a>Models and Theories in Science</h5><p>Cognitive scientists seek to understand how the mind works. That is, we want to describe and predict people’s behavior, and we ultimately wish to explain it, in the same way that physicists predict the motion of an apple that is dislodged from its tree (and can accuratetly describe its downward path) and explain its trajectory (by applealing to gravity). For example, if you forgot someone’s name when you are distracted seconds after being introduced to her, we would like to know what cognitive process is responsible for this failure. Was it lack of attention? Forgetting over time? Can we know ahead of time whether or not you will remember that person’s name?</p>
<p><br></p>
<p>The central thesis of this book is that to answer questions such as these, cognitive scientists must rely on quantitative mathematical models, just like physicists who research gravity. We suggest that to expand our knowledge of the human mind, consideration of the data and verbal theorizing are insufficient on their own.</p>
<p><br></p>
<p>This thesis is best illustrated by considering something that is simpler and more readily understood that the mind. Have a look at the data which represent the position of planets in the night sky over time. How might one descibe thie peculiar pattern of motion? How would you explain it? The strange loops in the otherwise consistently curvlinear paths describe the famous “retrograde motion” of the planets - that is, their propensity to suddenly reverse direction for sometime before resuming their initial path. What explains retrograde motion? It took more than a thousand years for a satisfactory answer to that question to become available, when Copernicus replaced the goecentric Ptolemaic system with a heliocentric model: Today, we know that retrograde motion arises from the fact that the planets travel at different speeds along their orbits; hence, as Earth “overtakes” Mars, for example, the red planet will appear to reverse direction as it falls behind the speeding Earth.</p>
<p><br></p>
<p>This example permits several conclusions that will be relevant throughout the reminder of this book. First, the pattern of data deifes description and explanation unless one has a model of the underlying process. It is only with the aid of a model that one can describe and explain planetary motion, even at a verbal level. Second, any model that explains the data is itself unobservable. That is, although the Copernican model is readily communicated and represented, it cannot be directly observed. Instead, the model is an abstract explanatory device that “exists” primaily in the minds of the people who use it to describe, predict, and explain the data. Third, there nealy always are several possible models that can explain a given data set. This point is worth exploring in a bit more detail. The answer to this question is quite fascinating and requires that we move toward a quantitative level of modeling.</p>
<p><br><br></p>
<h5 id="Memory-retention"><a href="#Memory-retention" class="headerlink" title="Memory retention"></a>Memory retention</h5><p>Finding a lawful relationship between memory retention and time is one of the oldest cognitive modeling question, going back to Ebbinghaus in the 1880s. The usual experiment involves giving people many items of information on a list, and then testing their ability to remember itmes from the list after different periods of time have elapsed. Various mathematical functions, usually with psychological interpretations, have been proposed as describing the relationship between time and the level of retention. </p>
<p><br></p>
<p>We consider a simplified version of the exponential decay model. The model assumes that the probability that an item will be remembered after a period of time $\mathit{t}$ has elapsed is $\theta_t = exp(-\alpha t) + \beta$, with the restriction $0 &lt; \theta_t &lt; 1$. The $\alpha$ parameter corresponds to the rate of decay of information. The $\beta$ parameter corresponds to a baseline level of remembering that is assumed to remain even after very long time periods. Our analyses using this model are based on fictitious data from a potential memory retention study, to help illustrate key modeling points.</p>
<p><br></p>
<p><img src="/image/cm1.png" alt="cm1"></p>
<p><br></p>
<p>These data are given in Table 10.1, and relate to 4 subjects tested on 18 items at 10 time intervals: 1, 2, 4, 7, 12, 21, 35, 59, 99, and 200. The number of items tested and the first 9 time intervals are those used by Rubin et al. (1999). Each datum in Table 10.1 counts the number of correct memory recalls for each subject at each time interval. Included in Table 10.1 are missing data, shown by “?” symbols, so subjects have missing data for the final time period of 200, which tests the ability of models to generalize to new measurements. For Subject 4, these are no data at all, which tests the ability of models to generalize to new subjects. </p>
<p><br></p>
<p><img src="/image/cm2.png" alt="cm2"></p>
<p><br></p>
<h5 id="No-individual-differences"><a href="#No-individual-differences" class="headerlink" title="No individual differences"></a>No individual differences</h5><p>The graphical model for our first attempt to account for the data is shown in Figure 10.1. The model assumes that every subject has the same retention curve, and so there is one true value for the $\alpha$ and $\beta$ parameters. The outer plate corresponds to the different time periods with values given by the observed $t_j$ variable. Together with the $\alpha$ and $\beta$ parameters, the time period defines the probability $\theta_j$ that the jth item will be remembered. The inner plate corresponds to the subjects. Each has the same probability of recall at any given time period, but their experimental data, given by the success counts $k_{ij}$, vary, and are bionomially distributed according to the success rate and number of trials.</p>
<p><br></p>
<p>The script Retention_1.txt implements the graphical model in WinBUGS. Note that the code calculates the success rate for each subject at each interval separately, and so in more elaborate than it needs to be:</p>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Retention With No Individual Differences</span></span><br><span class="line">model&#123;</span><br><span class="line">  <span class="comment"># Observed and Predicted Data</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:ns)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>:nt)&#123;</span><br><span class="line">      k[i, j] ~ dbin(theta[i, j], n)</span><br><span class="line">      predk[i, j] ~ dbin(theta[i, j], n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># Retention Rate At Each Lag For Each Subject Decays Exponentially</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:ns)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>:nt)&#123;</span><br><span class="line">      theta[i, j] &lt;- min(<span class="number">1</span>, exp(-alpha*t[j]+beta)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># Priors</span></span><br><span class="line">  alpha ~ dbeta(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">  beta ~ dbeta(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>The code applies the model to the data, and produces analysis of the posterior and posterior predictive distributions. The joint posterior distribution of $\alpha$ and $\beta$ is shown in the main panel of Figure 10.2, as a two-dimensional scatter plot.</p>
<p><br></p>
<p><img src="/image/cm3.png" alt="cm3"></p>
<p><br></p>
<p>Each of the points in the scatter-plot corresponds to a posterior sample selected at random from those available. The marginal distributions of both $\alpha$ and $\beta$ are shown below and to the right, and are based on all samples. The marginals show the distribution of each parameter, conditioned on the data, considered independently of the other parameter (i.e., averaged across the other parameter). It is clear from Figure 10.2 that the joint posterior carries more information than the two marginal distributions. If the joint posterior were independent, it would be just the product of the two marginal. But the joint posterior shows a mild relationship, with larger values of $\alpha$ generally corresponding to larger values of $\beta$.</p>
<p><br></p>
<p><img src="/image/cm4.png" alt="cm4"></p>
<p><br></p>
<p>This can be interpreted psychologically as meaning that it is uncertain whether the parameters are a relatively higher baseline coupled with a relatively higher decay rate, or a relatively lower baseline coupled with a relatively lower decay rate. Figure 10.3 shows the posterior predictive distribution over the number of successful retentions at each time interval. For each subject, at each interval, the squares show the posterior mass given to each possible number of items recalled. These correspond to the model’s predictions about observed behavior in the retention experiment, based on what the model has learned from the data. Also shown, by the black squres and connecting lines, are the actual observed data for each subject, where available. </p>
<p><br></p>
<p>The obvious feature of Figure 10.3 is that the current model does not meet a basic requirement of descriptive adequacy. For both Subjects 1 and 3 the model gives little posterior mass to the observed data at many time periods. It describes a steeper rate of decay than shown by the data of Subject 1, and a shallower rate of decay than shown by the data of Subject 3. After evaluating the model using the posterior predictive analysis, we can conclude that the modeling assumption of no individual differences is inappropriate. It is important to understand that this conclusion neuters the usefulness of the posterior distribution over parameters shown in Figure 10.2. The posterior distribution is conditioned on the assumption that the model is appropriate, and is not relevant when the model is fundamentally deficient.</p>
<p><br><br></p>
<h5 id="Full-individual-differences"><a href="#Full-individual-differences" class="headerlink" title="Full individual differences"></a>Full individual differences</h5><p>A revised graphical model that does accommodate individual differences is shown in Figure 10.4. The change from the previous model is that the ith subject now has their own $\alpha_i$ and $\beta_i$ parameters, and that the probability of retention for an item $\theta_{ij}$ now changes for both subjects and retention intervals.</p>
<p><br></p>
<p><img src="/image/cm5.png" alt="cm5"></p>
<p><br></p>
<p>The script Retention_2.txt implements the graphical model in WinBUGS:</p>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Retention With Full Individual Differences</span></span><br><span class="line">model&#123;</span><br><span class="line">  <span class="comment"># Observed and Predicted Data</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:ns)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>:nt)&#123;</span><br><span class="line">      k[i, j] ~ dbin(theta[i,j], n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># Retention Rate At Each Lag For Each Subject Decays Exponentially</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:ns)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>:nt)&#123;</span><br><span class="line">      theta[i, j] &lt;- min(<span class="number">1</span>, exp(-alpha[i]*t[j]) + beta[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># Priors For Each Subject</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:ns)&#123;</span><br><span class="line">    alpha[i] ~ dbeta(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    beta[i] ~ dbeta(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>The code applies the model to the same data and again produces analysis of the posterior and posterior predictive distributions. </p>
<p><br></p>
<p><img src="/image/cm6.png" alt="cm6"></p>
<p><br></p>
<p>The joint posterior distributions for each subject are shown in the main panel of Figure 10.5. Each point in the scatter-plot corresponds to a posterior sample, with different markers representing different subjects. The first, second, third, and fourth subjects use squre, circular, triangular, and cross markers, respectively. The marginal distributions are shown below and to the right, and use different line styles to represent the subjects.</p>
<p><br></p>
<p><img src="/image/cm7.png" alt="cm7"></p>
<p><br></p>
<p>Figure 10.6 shows the same analysis of the posterior predictive distributions over the number of successful retentions at each time interval, for each subject. It is clear that allowing for individual differences lets the model achieve a basic level of descriptive adequacy for Subjects 1, 2, and 3. The posteriors in Figure 10.5 show that different values for the $\alpha$ decay parameter are used for each of these subjects, corresponding to our intuitions from the earlier analysis.</p>
<p><br></p>
<p>The weakness in the current model is evident in its predictions for Subject 4. Because each subject is assumed to have decay and baseline parameters that are different, the only information the model has about the new subject is the priors for the $\alpha$ and $\beta$ parameters. The relationships between parameters for subjects that are visually evident in Figure 10.5 are not formally captured by the model. This means, as shown in Figure 10.5, the posterior for Subject 4 are just the priors, and so the posterior predictive distribution for Subject 4, as shown in Figure 10.6, does not have any useful structure. In this way, the model fails a basic test of generalizability, since it does not make sensible predictions for the behavior of subjects other than those for whom data are available. Intuitively, one might want to predict that Subject 4 will be likely to have model parameters consistent with regularties in the inferred parameters for Subjects 1, 2, and 3.</p>
<p><br><br></p>
<h5 id="Structured-individual-differences"><a href="#Structured-individual-differences" class="headerlink" title="Structured individual differences"></a>Structured individual differences</h5><p>The relationship between the parameters of different subjects, visually evident in Figure 10.5, can be captured using a hierarchical model. A graphical model implementing this approach is shown in Figure 10.7. The key cahnge is that now the $\alpha_i$ and $\beta_i$ parameters for each subject are modeled as coming from Gaussian distributions. The over-arching Gaussian distribution models this group-level structure for each parameter. This group structure itself has parameters, in the form of means $\mu_{\alpha}$ for the decay and $\mu_{\beta}$ for the baseline, and precisions $\lambda_{\alpha}$ for the decay and $\lambda_{\beta}$ for the baseline. In this way, the individual differences between subjects are given structure.</p>
<p><br></p>
<p>Each $\alpha_i$ and $\beta_i$ parameter is independently sampled, so they can be different, but they are sampled from the same distribution, so they have a relationship to one another. This means that inferences made for one subject influence predictions made for another. This means that inferences made for one subject influence predictions made for another. Since the means and precisions of the gorup-level distributions are common to all subjects, what is learned about them from one subject affects what is known about another. In addition, because they are sampled from over-arching distributions, the $\alpha_i$, and $\beta_i$ parameters at the individual subject level no longer have priors explicitly specified, but inherit them from the priors on the means and precisions of the group-level Gaussian distributions. The script Retention_3.txt implements the graphical model in WinBUGS:</p>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Retention With Structured Individual Differences</span></span><br><span class="line">model&#123;</span><br><span class="line">  <span class="comment"># Observed and Predicted Data</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:ns)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>:nt)&#123;</span><br><span class="line">      k[i, j] ~ dbin(theta[i, j], n)</span><br><span class="line">      predk[i, j] ~ dbin(theta[i, j], n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># Retention Rate At Each Lag For Each Subject Decays Exponentially</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:ns)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>:nt)&#123;</span><br><span class="line">      theta[i, j] &lt;- min(<span class="number">1</span>, exp(-alpha[i]*t[j]+beta[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># Parameters For Each Subject Drawn From Gaussian Group Distributions</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:ns)&#123;</span><br><span class="line">    alpha[i] ~ dnorm(alphamu, alphalambda)I(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    beta[i] ~ dnorm(betamu, betalambda)I(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># Priors For Group Distributions</span></span><br><span class="line">  alphamu ~ dbeta(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">  alphalambda ~ dgamma(<span class="number">.001</span>,<span class="number">.001</span>)I(<span class="number">.001</span>,)</span><br><span class="line">  alphasigma &lt;- <span class="number">1</span>/sqrt(alphalambda)</span><br><span class="line">  betalambda ~ dgamma(<span class="number">.001</span>,<span class="number">.001</span>)I(<span class="number">.001</span>,)</span><br><span class="line">  betasigma &lt;- <span class="number">1</span>/sqrt(betalambda)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>The code applies the model to the data, and again produces an analysis of the posterior and posterior predictive distributions. The joint amd marginal posterior distributions for this model are shown in Figure 10.8 using the same markers and lines as before. For Subjects 1, 2, and 3, these distributions are extremely similar to those found using the full individual differences model. The important difference is for Subject 4, who now sensible posterior distributions for both parameters. For the decay parameter $\alpha$ there is still considerable uncertainty, consistent with the range of values seen for the first three subjects, but for the baseline parameter $\beta$, Subject 4 now has a much more constrained posterior distribution.</p>
<p><br></p>
<p><img src="/image/cm8.png" alt="cm8"></p>
<p><br></p>
<p>The posterior predictive distributions for each subject under the hierarchical model are shown in Figure 10.9. The preditions remain useful for the first three subjects, and are now also appropriate for Subject 4. The structured prediction for Subject 4, from whom no data have yet been collected, comes directly from the nature of the hierarchical model. Based on the data from Subjects 1, 2, and 3, inferences are made about the means and precisions of the group distributions for the two parameters of the retention model. The new Subject 4 has values sampled from the Gaussians with these parameters, producing the sensible parameter distributions in Figure 10.8 that lead to the sensible predictive distributions in Figure 10.9.</p>
<p><br></p>
<p><img src="/image/cm9.png" alt="cm9"></p>
<p><br></p>
<p>Psychologically, hierarchical models are powerful because they are able to represent knowledge at different levels of abstraction in a cognitive process(Lee, 2011a). Just as the data have been assumed to be generated by the decay and baseline parameters combining in a memory process for individual subjects, the hierarchical model assumes that those parameters themselves are generated by more abstract latent parameters that describe group distributions across subjects. In other words, a hierarchical model lets a theory of memory retention be combined with a theory of individual differences, to provide a more complete account of behavioral data from multiple subjects.</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/21/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EC%8B%A4%EC%8A%B5%ED%8E%B8-1/">
                [iOS] 앱 개발 실습편 (1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="내-소개-애플리케이션"><a href="#내-소개-애플리케이션" class="headerlink" title="내 소개 애플리케이션"></a>내 소개 애플리케이션</h1><h5 id="본-포스팅은-“야곰의-iOS-프로그래밍”을-정리한-내용입니다"><a href="#본-포스팅은-“야곰의-iOS-프로그래밍”을-정리한-내용입니다" class="headerlink" title="본 포스팅은 “야곰의 iOS 프로그래밍”을 정리한 내용입니다."></a>본 포스팅은 “야곰의 iOS 프로그래밍”을 정리한 내용입니다.</h5><p><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/19/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%8F%84%EC%A0%84%EA%B8%B0-6/">
                [iOS] 앱 개발 도전기 (6)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-19</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="델리게이트-패턴"><a href="#델리게이트-패턴" class="headerlink" title="델리게이트 패턴"></a>델리게이트 패턴</h1><p>iOS 앱의 객체는 델리게이트 패턴(Delegate Pattern)이라고 불리는 일종의 위임 패턴을 많이 사용합니다. 이 패턴은 iOS 앱 코드의 전반적 구조를 이루는 아주 중요한 부분이므로, 이것을 충분히 이해해야만 iOS 기반의 앱을 원활하게 작성할 수 있습니다. 일반적인 단어로 널리 사용되는 패턴(Pattern)이란 반복해서 나타나는 사건이나 형태를 의미합니다. 보통 예측 가능한 방식으로 되풀이된다는 점에서 그 의미가 있죠. 객체지향 프로그래밍에서는 디자인 패턴(Design Pattern)이라는 합성 용어로 사용되는 경우가 대부분입니다. 여기서 디자인이란 프로그램 구성에 대한 디자인 즉, 구조적 설계를 의미합니다. 객체지향 프로그래밍에서는 객체 간의 관계가 중요한데, 설계에 관한 문제를 해결하기 위한 해법으로 객체들의 관계를 구조화한 사례가 일반화된 것이 디자인 패턴입니다.</p>
<p><br></p>
<p>델리게이트 패턴은 쉽게 말해 객체지향 프로그래밍에서 하나의 객체가 모든 일을 처리하는 것이 아니라 처리해야 할 일 중 일부를 다른 객체에 넘기는 것을 말합니다. 이는 효율성 관점에서 아주 중요한 역할을 합니다. 기능을 위임할 수 있는 객체가 있다는 것은 그만큼 직접 구현해야 하는 부분이 적다는 뜻이기 때문에 큰 규모의 프로그램을 빠르게 작성할 수 있습니다. 모든 기능을 직접 처리해주려면 코딩양이 매우 늘어날 뿐더러 집중해야 할 부분에 집중하지 못하게 됩니다. 이 때문에 기능을 분담하여 나누는 델리게이트 패턴이 필요합니다.</p>
<p><br></p>
<p>사실 델리게이트 패턴은 iOS에서 가장 활발히 사용하고 있지만, 꼭 iOS 개발에 국한된 패턴은 아닙니다. 대부분 GUI 기반 프로그래밍에서 일반적으로 널리 사용되는 패턴이죠. GUI 기반 프로그래밍에서 델리게이트 패턴이 사용되는 가장 대표적인 예는 이벤트 리스너(Event Listener)입니다. 앞에서 아마도 버튼을 @IBAction 메소드로 연결하여 버튼 클릭 시 해당 메소드가 실행되도록 구성해보았을 겁니다.</p>
<p><br></p>
<p>그런데 구체적으로 어떤 과정을 거쳐 사용자가 아이폰 기기에서, 혹은 컴퓨터에서 마우스 클릭하는 동작이 이 애플리케이션에 전달되는지 생각해 본 적 있나요? 일반적인 데스크톱 프로그램에서 마우스 클릭이 특정 프로그램의 이벤트 처리 함수 onClick()으로 연결되어 원하는 내용이 실행되는 과정을 정리해보면 다음과 같습니다.</p>
<p><br></p>
<ol>
<li>마우스 버튼을 클릭합니다.</li>
<li>마우스에서는 연결된 시리얼 케이블이나 블루투스 통신을 통해 0x000867(단순히 예시입니다. 실제로 이 값을 전송하지는 않습니다) 신호를 전송합니다.</li>
<li>마우스로부터 전송된 신호는 RS232 통신 프로토콜을 이용하여 메인보드를 거쳐 운영체제의 메시지 센터로 전달됩니다.</li>
<li>신호를 수신한 운영체제에서는 마우스 포인터의 화면상 좌표를 확인합니다.</li>
<li>운영체제에서는 해당 좌표에서 활성화된 애플리케이션을 확인합니다.</li>
<li>델리게이트를 이용하여 클릭 신호가 애플리케이션의 이벤트 처리 함수 onClick()에 대응하였음을 애플리케이션에 알립니다.</li>
<li>애플리케이션이 onClick() 함수를 실행합니다.</li>
</ol>
<p><br></p>
<p>우리는 1~7 까지를 직접 처리하지 않습니다. 그럼에도 사용자의 클릭 이벤트가 우리가 만든 앱에서 정상으로 전달되어 우리가 의도하는 메소드를 실행할 수 있는 것은, 클릭 이벤트를 인식하고 프로그램에 전달해주는 위임 객체가 있기 때문입니다. 이런 과정을 실제로 우리가 구현하고자 한다면 필요한 코딩양은 어마어마합니다. 하지만 실제로 많은 프로그래밍 과정에서 모든 이벤트에 대한 처리는 델리게이트 패턴에 의해 운영체제의 메시지 처리 객체로 위임되고, 운영체제가 관리하는 이 메시지 처리 객체가 이벤트를 감지하게 되면 델리게이트를 이용하여 애플리케이션에 해당 메소드를 알려줌으로써 우리가 원하는 코드가 실행됩니다. 그 중간 과정은 델리게이트 패턴 덕분에 우리가 직접 구현할 필요가 없는 것이죠.</p>
<p><br></p>
<p>iOS에서 사용되는 델리게이트 패턴도 이와 같은 개념입니다. 기능을 처리할 객체를 델리게이트로 설정하고, 특정 이벤트가 발생할 때 이를 델리게이트에 의해 위임된 본래의 객체로 전달해주는 역할을 합니다. 가령 웹 뷰(Web View)는 외부 브라우저 없이 웹 페이지를 앱 내에서 표시해주는 역할을 하는데, 이 과정에서 잡아내야 할 몇 가지 중요한 시점이 있습니다. 웹 페이지가 로딩되기 시작할 때라든가, 로딩이 완료되었을 때 또는 로딩이 실패하였을 때, 혹은 사용자가 다른 페이지로 이동하고자 할 때 등이 그에 해당하죠.</p>
<p><br></p>
<p>이러한 이벤트를 캐치할 수 있도록 직접 구현하려면, 상당히 복잡한 과정을 거쳐야 합니다. 여러 줄에 걸친 복잡한 과정을 통해 구현한 다음에도 심지어는 이벤트를 정확히 캐치하지 못할 수도 있죠. 하지만 웹 뷰 자체에서 이러한 시점을 잡아낼 수 있는 기능이 이미 구현되어 있으므로 우리는 웹 뷰가 특정 시점을 알려줄 뷰 컨트롤러를 델리게이트로 위임하고 웹 뷰가 이벤트 발생 시 호출해주는 함수를 구현해주기만 하면 됩니다. </p>
<p><br></p>
<p>다만 iOS에서의 델리게이트 패턴은 위임 객체가 호출할 메소드를 우리가 직접 정의하는 방식은 아닙니다. 웹 뷰의 경우 웹 페이지를 처음 읽어 들이기 시작할 때 webViewDidStartLoad(_:) 메소드를 호출하고, 웹 페이지를 모두 읽어 들였을 때 webViewDidFinishLoad(_:) 메소드를 호출하도록 프로토콜을 통해 이미 약속되어 있죠. 따라서 우리는 웹 뷰와 관련된 프로토콜에 정의된 형식을 따라 이 메소드를 구현하면 됩니다. 위 내용을 한 마디로 정리하면 다음과 같습니다.</p>
<p><br></p>
<h5 id="“웹-뷰-너에게-모든-것을-일임할게-뷰-컨트롤러인-나에게는-특정-이벤트가-발생했을-때-알려주기만-하면-돼-”"><a href="#“웹-뷰-너에게-모든-것을-일임할게-뷰-컨트롤러인-나에게는-특정-이벤트가-발생했을-때-알려주기만-하면-돼-”" class="headerlink" title="“웹 뷰 너에게 모든 것을 일임할게. 뷰 컨트롤러인 나에게는 특정 이벤트가 발생했을 때 알려주기만 하면 돼!”"></a>“웹 뷰 너에게 모든 것을 일임할게. 뷰 컨트롤러인 나에게는 특정 이벤트가 발생했을 때 알려주기만 하면 돼!”</h5><p><br></p>
<p>특정 이벤트가 발생했을 때 알려주는 방법이 바로 미리 정의된 델리게이트 메소드를 사용하는 것입니다. 이를 위해 iOS에서 델리게이트 패턴을 사용하는 모든 객체는 델리게이트 메소드를 정의한 프로토콜을 가집니다. 이를 델리게이트 프로토콜이라고 하는데, 보통 객체의 이름 되에 Delegate를 붙여서 정의합니다. 우리가 델리게이트 메소드를 이용하려면 델리게이트 프로토콜을 구현하는 과정이 반드시 필요합니다. 더 자세하게 이해하고 익숙하게 사용할 수 있도록 구체적인 예를 통해 델리게이트 패턴을 익혀보겠습니다.</p>
<p><br></p>
<h4 id="텍스트-필드"><a href="#텍스트-필드" class="headerlink" title="텍스트 필드"></a>텍스트 필드</h4><p>텍스트 필드는 델리게이트 패턴을 사용하는 대표적인 객체 중의 하나입니다. 기본적인 기능은 델리게이트 패턴 없이도 사용할 수 있지만, 입력값을 제어하는 등의 고급 기능을 구현하고 싶을 때는 델리게이트 패턴을 적용해야 합니다. 트정 문자열의 입력 배제, 입력 가능한 문자열 길이 제한 등이 델리게이트 패턴을 통해 처리할 수 있는 대표적인 사례죠. 텍스트 필드에 델리게이트 패턴을 적용하려면 다음과 같은 두 가지 작업이 필요합니다.</p>
<p><br></p>
<ol>
<li>텍스트 필드에 대한 델리게이트 프로토콜을 구현한다.</li>
<li>텍스트 필드의 델리게이트 속성을 뷰 컨트롤러에 연결한다.</li>
</ol>
<p><br></p>
<p>첫 번째 작업은 프로토콜 구현에 관련된 것입니다. 델리게이트 패턴을 구현하려면 모든 객체는 그에 맞는 델리게이트 프로토콜을 구현해야 하는데, 이때 프로토콜의 이름은 항상 해당 객체의 클래스명 + Delegate로 이루어집니다. 텍스트 필드의 클래스명이 UITextField이므로 델리게이트 프로토콜은은 UITextFieldDelegate가 되는 식이죠.</p>
<p><br></p>
<p>델리게이트 프로토콜을 구현한다는 것은 클래스 이름 정의 뒤에 프로토콜 명을 덧붙이는 것만을 의미하지는 않습니다. 프로토콜에 정의된 메소드를 실질적으로 작성하는 것까지를 포함합니다. @optional 키워드가 붙은 메소드는 필요한 것만 선택적으로 구현해도 되지만, 이외의 메소드는 반드시 구현해 주어야 합니다.</p>
<p><br></p>
<p>델리게이트 프로토콜을 구현하고 나면 이어지는 작업은 해당 객체의 델리게이트 속성을 뷰 컨트롤러와 연결하는 것입니다. 이때 델리게이트 속성이란, 델리게이트 메소드가 구현되어 있는 객체를 의미합니다. 특정 이벤트가 발생했을 경우 텍스트 필드는 이를 알려주기 위해 델리게이트 메소드가 구현되어 있는 객체를 찾는데, 이를 위한 참조 포인터가 저장되는 곳이 delegate 속성입니다. 텍스트 필드의 delegate 속성에 저장된 인스턴스가 델리게이트 메소드를 구현한 것으로 인식하고, 필요한 메소드를 호출하는 거죠.</p>
<p><br></p>
<p>이후로는 텍스트 필드를 원래대로 사용하기만 하면 됩니다. 텍스트 필드에서 미리 지정된 시점이 되면 delegate 속성에 정의된 인스턴스를 찾아 델리게이트 메소드를 호출할 것이고, 델리게이트 메소드에 미리 정의해 둔 내용이 알아서 실행될 테니까요. 앞에서도 텍스트 필드에 대해 다루어 본 적이 있지만, 기왕 이야기가 나왔으니 이 컨트롤에 대해 조금 더 자세히 알아봅시다.</p>
<p><br><hr><br></p>
<h1 id="프로젝트-생성-및-실습"><a href="#프로젝트-생성-및-실습" class="headerlink" title="프로젝트 생성 및 실습"></a>프로젝트 생성 및 실습</h1><p>먼저 텍스트 필드의 속성을 설정해보겠습니다. 스위프트 코드로 제어해 봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> tf: <span class="type">UITextField!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// 텍스트 필드 속성 설정</span></span><br><span class="line">        <span class="keyword">self</span>.tf.placeholder = <span class="string">"값을 입력하세요"</span> <span class="comment">// 안내 메시지</span></span><br><span class="line">        <span class="keyword">self</span>.tf.keyboardType = <span class="type">UIKeyboardType</span>.alphabet <span class="comment">// 키보드 타입 영문자 패드로</span></span><br><span class="line">        <span class="keyword">self</span>.tf.keyboardAppearance = <span class="type">UIKeyboardAppearance</span>.dark <span class="comment">// 키보드 스타일 어둡게</span></span><br><span class="line">        <span class="keyword">self</span>.tf.returnKeyType = <span class="type">UIReturnKeyType</span>.<span class="built_in">join</span> <span class="comment">// 리턴키 타입은 "Join"</span></span><br><span class="line">        <span class="keyword">self</span>.tf.enablesReturnKeyAutomatically = <span class="literal">true</span> <span class="comment">// 리턴키 자동 활성화 "On"</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         스타일 설정</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 테두리 스타일 - 직선</span></span><br><span class="line">        <span class="keyword">self</span>.tf.borderStyle = <span class="type">UITextField</span>.<span class="type">BorderStyle</span>.line</span><br><span class="line">        <span class="comment">// 배경 색상</span></span><br><span class="line">        <span class="keyword">self</span>.tf.backgroundColor = <span class="type">UIColor</span>(white: <span class="number">0.87</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">        <span class="comment">// 수직 방향으로 텍스트가 가운데 정렬되도록</span></span><br><span class="line">        <span class="keyword">self</span>.tf.contentVerticalAlignment = .center</span><br><span class="line">        <span class="comment">// 수평 방향으로 텍스트가 가운데 정렬되도록</span></span><br><span class="line">        <span class="keyword">self</span>.tf.contentHorizontalAlignment = .center</span><br><span class="line">        <span class="comment">// 테두리 색상을 회색으로</span></span><br><span class="line">        <span class="keyword">self</span>.tf.layer.borderColor = <span class="type">UIColor</span>.darkGray.cgColor</span><br><span class="line">        <span class="comment">// 테두리 두께 설정 (단위: pt)</span></span><br><span class="line">        <span class="keyword">self</span>.tf.layer.borderWidth = <span class="number">2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><img src="/image/ios14.png" alt="ios14"></p>
<p><br></p>
<p>텍스트 필드에 대해 학습한 내용을 바탕으로 드디어 델리게이트 패턴을 적용해 보겠습니다. 델리게이트 패턴을 적용할 때 갖장 먼저 할 일은 델리게이트 프로토콜에 대한 구현을 선언하는 것입니다. ViewController 클래스에 UITextFieldDelegate 프로토콜 구현을 선언합 후, viewDidLoad() 메소드 맨 아래에 텍스트 필드의 delegate 속성에 self를 대입하는 구문을 추가합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITextFieldDelegate</span></span>&#123;</span><br><span class="line">    ...(중략)...</span><br><span class="line">    <span class="comment">// 델리게이트 지정</span></span><br><span class="line">    <span class="keyword">self</span>.tf.delegate = <span class="keyword">self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>텍스트 필드의 delegate는 텍스트 필드에 특정 이벤트가 발생했을 때 알려줄 대상 객체를 가리키는 속성입니다. 이 속성에 대입된 self는 현재의 뷰 컨트롤러 인스턴스를 의미하죠. 다시 말해, 텍스트 필드에서 미리 정해진 특정 이벤트가 발생하면 현재의 뷰 컨트롤러에게 알려달라는 요청입니다. 이를 가리켜 “뷰 컨트롤러가 텍스트 필드의 델리게이트 객체로 지정되었다”라고 표현합니다. 텍스트 필드가 자신의 델리게이트 객체에게 특정 이벤트가 발생했음을 알려줄 때에는 델리게이트 메소드를 이용합니다. 이벤트마다 호출하기로 약속된 메소드가 정해져 있는데, 이를 현재 지정된 델리게이트 객체에서 찾아 호출하는 겁니다. 이를 위해서는 먼저 델리게이트 객체에 지정된 메소드가 구현되어 있는지 확인합니다. 만약 구현되어 있다면 필요한 인자값을 담아 메소드를 호출해 주고, 구현되어 있지 않다면 ‘안 알려줘도 되나보다’라고 판단하고 그대로 종료하는 방식으로 이루어지는 것이 델리게이트 패턴입니다.</p>
<p><br></p>
<p>ViewController 클래스에 다음과 같이 textFieldShouldBeginEditing(_:) 메소드를 추가합니다. 자동 완성 지원이 되므로, 이를 이용하면 편리합니다. 이후에도 계속해서 델리게이트 메소드를 차례로 추가합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 텍스트 필드의 편집이 시작된 후 호출</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">textFieldDidBeginEditing</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"텍스트 필드의 편집이 시작되었습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 텍스트 필드의 내용이 삭제될 때 호출</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">textFieldShouldClear</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"텍스트 필드의 내용이 삭제됩니다."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// false를 리턴하면 삭제되지 않는다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 텍스트 필드의 내용이 변경될 때 호출</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">textField</span><span class="params">(<span class="number">_</span> textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"텍스트 필드의 내용이 \(string)으로 변경됩니다."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// false를 리턴하면 내용이 변경되지 않는다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 텍스트 필드의 리턴키가 눌러졌을 때 호출</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    textField.resignFirstResponder()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"텍스트 필드의 리턴키가 눌러졌습니다."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 텍스트 필드 편집이 종료될 때 호출</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">textFieldShouldEndEditing</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"텍스트 필드의 편집이 종료됩니다."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  <span class="comment">// false를 리턴하면 편집이 종료되지 않는다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 텍스트 필드의 편집이 종료되었을 때 호출</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">textFieldDidEndEditing</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"텍스트 필드의 편집이 종료되었습니다."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>각각의 델리게이트 메소드는 실행 시점에 맞추어 호출됩니다. 앱을 실행한 다음, 텍스트 필드에 값을 입력해보면 어떤 메소드가 어떻게 호출되는지 알 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">텍스트 필드의 편집이 시작되었습니다.</span><br><span class="line">텍스트 필드의 내용이 e으로 변경됩니다.</span><br><span class="line">텍스트 필드의 내용이 으로 변경됩니다.</span><br><span class="line">텍스트 필드의 내용이 e으로 변경됩니다.</span><br><span class="line">텍스트 필드의 내용이 d으로 변경됩니다.</span><br><span class="line">텍스트 필드의 내용이 i으로 변경됩니다.</span><br><span class="line">텍스트 필드의 내용이 t으로 변경됩니다.</span><br><span class="line">텍스트 필드의 편집이 종료됩니다.</span><br><span class="line">텍스트 필드의 편집이 종료되었습니다.</span><br><span class="line">텍스트 필드의 리턴키가 눌러졌습니다.</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>한 가지 기능을 덧붙여 봅시다. 텍스트 필드에 숫자를 입력할 수 있도록 차단하는 코드를 추가해 봅시다. 그리고 텍스트 필드에는 최대로 입력 가능한 문자열 길이가 있는 경우가 많습니다. 이것 역시 이 메소드를 이용하면 쉽게 구현할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 텍스트 필드의 내용이 변경될 때 호출</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">textField</span><span class="params">(<span class="number">_</span> textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"텍스트 필드의 내용이 \(string)으로 변경됩니다."</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="type">Int</span>(string) == <span class="literal">nil</span>&#123;  <span class="comment">// 입력된 값이 숫자가 아니라면 true를 리턴</span></span><br><span class="line">        <span class="comment">// 현재 텍스트 필드에 입력된 길이와 더해질 문자열 길이의 합이 10을 넘는다면 반영하지 않음</span></span><br><span class="line">        <span class="keyword">if</span> (textField.text?.<span class="built_in">count</span>)! + string.<span class="built_in">count</span> &gt; <span class="number">10</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 입력된 값이 숫자라면 false를 리턴</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<p>다음은 이미지 피커 컨트롤러(Image Picker Controller)를 통해 델리게이트 패턴을 활용해보도록 하겠습니다. 이미지 피커 컨트롤러 자체는 단순히 이미지를 선택해서 가져오는 기능입니다. 하지만 이미지를 불러올 소스를 어떤 것으로 설정하느냐에 따라 앨범이나 카메라 기능을 사용할 수 있으므로, 카메라를 이용하여 즉석에서 촬영한 사진을 사용하거나 앨범에 저장된 이미지를 불러올 때 대부분 이 컨트롤러를 사용하여 기능을 구현합니다.</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/19/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%8F%84%EC%A0%84%EA%B8%B0-7/">
                [iOS] 앱 개발 도전기 (7)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-19</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="테이블-뷰를-이용한-데이터-목록-구현"><a href="#테이블-뷰를-이용한-데이터-목록-구현" class="headerlink" title="테이블 뷰를 이용한 데이터 목록 구현"></a>테이블 뷰를 이용한 데이터 목록 구현</h1><p>앱에서 제공하는 콘텐츠는 생각보다 방대한 경우가 많습니다. 그렇다고 매번 검색을 통해서 데이터를 찾도록 하는 것은 터치 이벤트에 의존하는 사용자에게 무척 불편한 일입니다. 방대한 콘텐츠를 앱을 통해 제공하고, 사용자가 효율적으로 콘텐츠에 접근할 수 있도록 하려면 콘텐츠의 성격에 따라 앱의 구조와 UI를 고려해야 합니다.</p>
<p><br></p>
<p>이때 사용되는 것이 테이블 뷰 컨트롤러입니다. 테이블 뷰 컨트롤러의 표면적 역할은 목록 형태의 콘텐츠를 화면에 표현해주는 것입니다. 하지만 그 역할을 자세히 들여다보면 계층 구조를 이루는 콘텐츠의 상위 카테고리를 정렬하여 표현함으로써 방대한 콘텐츠 속에서도 사용자가 원하는 항목에 쉽게 접근할 수 있게 해 주는 특성을 지니고 있습니다.</p>
<p><br></p>
<p>테이블 뷰 컨트롤러와 내비게이션 컨트롤러는 계층적 성격의 콘텐츠를 표현해주기 위해 상호 보완적인 역할을 합니다. 테이블 뷰 컨트롤러를 이용하여 수평적 관계의 카테고리나 콘텐츠를 병렬로 배열하고, 수직적 관계로 세분한 정보들을 내비게이션 컨트롤러를 통하여 직렬로 표현하여 전체적인 앱의 콘텐츠 표현 구조를 구성하죠. </p>
<p><br></p>
<p>일반적으로 알려진 정보 검색 알고리즘에 따르면, 가장 효율적인 정보 접근 방법은 콘텐츠를 성격에 따라 계층으로 구조화하는 것입니다. 계층으로 콘텐츠를 구조화하면 상위 카테고리 하나를 선택하는 과정만으로도 원하는 정보에 접근하는 것이 훨씬 단순해지기 때문입니다. 이때 가장 고려해야 할 부분은 더 적은 횟수의 선택 과정으로 원하는 정보를 찾을 수 있게 하는 것입니다. 이것이 바로 정보 검색 알고리즘의 핵심이자 앱을 만들 때 콘텐츠 구조를 설계하는 원칙입니다. 데이터베이스의 설계 원리에 선택도(Cardinality)라는 것이 있는데, 특정 카테고리를 선택하여 나온 결과값의 개수가 적을수록 ‘선택도가 높다’고 표현하며 콘텐츠 분류가 잘되었다고 할 수 있습니다.</p>
<p><br></p>
<p>테이블 뷰를 이용하여 화면을 구성할 때는 단순히 목록을 구성하는 데에 주력하는 것이 아니라, 이러한 데이터 접근 구조에 대해서도 고려해야 합니다. 그러면서 사용자가 어떻게 하면 보다 손쉽게 원하는 콘텐츠에 접근할 수 있을 것인가를 반영하여 화면 구조를 설계해야 합니다. </p>
<p><br></p>
<p>하나의 테이블 뷰 컨트롤러 화면을 구성하는 단위는 다음과 같습니다.</p>
<p><br></p>
<h5 id="테이블-뷰-컨트롤러-gt-하나의-테이블-뷰-gt-여러-개의-테이블-뷰-섹션-gt-여러-개의-테이블-뷰-셀-gt-테이블-뷰-셀마다-하나씩-콘텐츠-뷰"><a href="#테이블-뷰-컨트롤러-gt-하나의-테이블-뷰-gt-여러-개의-테이블-뷰-섹션-gt-여러-개의-테이블-뷰-셀-gt-테이블-뷰-셀마다-하나씩-콘텐츠-뷰" class="headerlink" title="테이블 뷰 컨트롤러 &gt; 하나의 테이블 뷰 &gt; 여러 개의 테이블 뷰 섹션 &gt; 여러 개의 테이블 뷰 셀 &gt; 테이블 뷰 셀마다 하나씩 콘텐츠 뷰"></a>테이블 뷰 컨트롤러 &gt; 하나의 테이블 뷰 &gt; 여러 개의 테이블 뷰 섹션 &gt; 여러 개의 테이블 뷰 셀 &gt; 테이블 뷰 셀마다 하나씩 콘텐츠 뷰</h5><p><br><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/15/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%B2%88%EC%99%B8%ED%8E%B8-3/">
                [iOS] 앱 개발 번외편 (3)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-15</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Xib와-테이블뷰-셀-커스터마이즈"><a href="#Xib와-테이블뷰-셀-커스터마이즈" class="headerlink" title="Xib와 테이블뷰 셀 커스터마이즈"></a>Xib와 테이블뷰 셀 커스터마이즈</h1><p><br></p>
<h3 id="1-인터페이스-구성하기"><a href="#1-인터페이스-구성하기" class="headerlink" title="1. 인터페이스 구성하기"></a>1. 인터페이스 구성하기</h3><p>자, 먼저 아래와 같이 전체적인 앱 플로우를 구성하기 위하여 본 포스팅에서 사용될 테이블뷰와 탭바 컨트롤러를 공식문서에서 어떻게 설명하였는지 먼저 살펴보도록 하자. 아래는 직관적으로 이해가 잘 되는 개요 부분을 발췌하였다.</p>
<p><br></p>
<p><br></p>
<h4 id="Class-UITableView"><a href="#Class-UITableView" class="headerlink" title="Class UITableView"></a>Class UITableView</h4><p>A view that presents data using rows arranged in a single column</p>
<p><br></p>
<p>Table views on iOS display a single column of vertically scrolling content, divided into rows. Each row in the table contains one piece of your app’s content. For example, the Contacts app displays the name of each contact in a separate row, and the main page of the Settings app displays the available groups of settings. You can configure a table to display a single long list of rows, or you can group related rows into sections to make navigating the content easier.</p>
<p><br></p>
<p>Tables are commonly used by apps whose data is highly structured or organized hierarchically. Apps that contain hierarchical data often use tables in conjunction with a navigation view controller, which facilitates navigation between different levels of the hierarchy. For example, the Settings app uses tables and a navigation controller to organize the system settings.</p>
<p><br></p>
<p>UITableView manages the basic apperance of the table, but your app provides the cells(UITableViewCell objects) that display the actual content. The standard cell configurations display a simple combination of text and images, but you can define custom cells that display any content you want. You can also supply header and footer views to provide additional information for groups of cells.</p>
<p><br><br></p>
<h4 id="UITabBarController"><a href="#UITabBarController" class="headerlink" title="UITabBarController"></a>UITabBarController</h4><p>A container view controller that manages a radio-style selection interface, where the selection determines which child view controller to display.</p>
<p><br></p>
<p>The tab bar interface displays tabs at the bottom of the window for selecting between the different modes and for displaying the views for that mode. This class is generally used as-is, but may also be subclassed.</p>
<p><br></p>
<p>Each tab of a tab bar controller interface is associated with a custom view controller. When the user selects a specfic tab, the tab bar controller displays the root view of the corresponding view controller, replacing any previous views. (User taps always display the root view of the tab, regardless of which tab was previously selected. This is true even if the tab was already selected.) Because selecting a tab replace the contents of the interface, the type of interface managed in each tab need not be similar in any way. In fact, tab bar interfaces are commonly used either to present different types of information or to present the same information using a completely different style of interface.</p>
<p><br></p>
<p>You should never access the tab bar view of a tab bar controller directly. To configure the tabs of a tab bar controller, you assign the view controllers that provide the root view for each tab to the viewControllers property. The order in which you specify the view controllers determines the oreder in which they appear in the tab bar. When setting this property, you should assign a value to the selectedViewController property to indicate which view controller is selected initially. (You can also select view controllers by array index using the selectedIndex property.) When you embed the tab bar controller’s view (obtained using the inherited vieww property) in your app window, the tab bar controller automatically selects that view controller and displays its contents, resizing them as needed to fit the tab bar interface.</p>
<p><br></p>
<p>Tab bar items are configured through their corresponding view controller. To associate a tab bar item with a view controller, create a new instance of the UITabBarItem class, configure it appropriately for the view controller, and assign it to the view controller’s tabBarItem property. If you don’t provide a custom tab bar item for your view controller, the view controller creates a default item containing no image and the text from the view controller’s title property.</p>
<p><br></p>
<p>As the user interacts with a tab bar interface, the tab bar controller objects sends notifications about the interactions to its delegate. The delegate can be any object you specify but must conform to the UITabBarControllerDelegate protocol. You can use the delegate to prevent specific tab bar items from being selected and to perform additional tasks when tabs are selected. You can also use the delegate to monitor changes to the tab bar that are made by the More navigation controller.</p>
<p><br><hr><br></p>
<h3 id="2-모델-코드작성"><a href="#2-모델-코드작성" class="headerlink" title="2. 모델 코드작성"></a>2. 모델 코드작성</h3><p>우선 도서 정보를 담을 틀인 BookVO 클래스를 작성해보자.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookVO</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bookImage: <span class="type">String?</span>  <span class="comment">// 도서 커버 이미지 주소</span></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String?</span>  <span class="comment">// 도서 이름</span></span><br><span class="line">    <span class="keyword">var</span> price: <span class="type">String?</span>  <span class="comment">// 도서 가격</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 클래스는 도서 정보를 담기 위한 객체이다. BookVO 클래스에는 몇 개의 프로퍼티가 정의되어 있는데, 도서의 커서 이미지 주소를 저장하기 위한 bookImage, 도서 이름을 저장하기 위한 title, 도서 가격을 위한 price가 있다. 우리는 이들 변수 각각에 값을 저장하지만, 전달할 때는 BookVO 클래스의 인스턴스 자체를 전달하게 된다. 값을 주고 받을 때 개별 변수가 아니라 클래스 인스턴스 자체가 전달되므로 각 변수에 저장된 값들의 관련성이 유지될 수 있음은 물론, 여러 개의 변수가 필요하지도 않다. 이렇게 만들어진 클래스 인스턴스는 테이블 뷰의 셀 하나하나를 구성하는 데이터 소스로 사용된다. 각각의 프로퍼티는 비어있을 수도 있으므로 옵셔널 타입으로 선언한다.</p>
<p><br></p>
<p>참고로 VO의 의미인 Value Object 패턴을 함께 알아보자. 이는 데이터 저장을 전달하는 클래스를 별도로 분리하는 설계 방식을 말하는데, 줄여서 VO라고 한 것이다. 객체 지향 설계에서는 매우 자주 활용되는 방식이다. VO 패턴을 쉽게 생각하자면 일종의 식판이라고 할 수 있다. 밥그릇, 국그릇 등을 올려놓는 식판 말이다. 식판 위에 올라가는 밥그릇, 국그릇, 반찬 그릇 등에는 밥이나 국, 그리고 반찬이 담기듯이 VO 패턴의 클래스에 올려지는 각종 변수들은 해당하는 데이터를 담는 역할을 한다. 밥그릇에 밥을 담고 국그릇에 국을 담고 반찬 그릇에 반찬을 담아 식판 위에 올려놓은 다음에 식탁으로 갈 때에는 각각의 그릇들을 들고 가는 것이 아니라 식판 하나만 들고 가면 된다. 식판을 들고 가면 자연스레 밥과 국, 반찬은 함께 이동하게 된다. VO 패턴도 마찬가지이다. 클래스 인스턴스 내부의 속성에 각각의 데이터들을 담은 다음, 전달할 때에는 클래스 인스턴스 전체를 전달하기 때문에 자연스레 클래스 내부의 변수에 저장된 값도 함께 전달된다.</p>
<p><br><hr><br></p>
<h3 id="3-웹-데이터-요청-코드-작성"><a href="#3-웹-데이터-요청-코드-작성" class="headerlink" title="3. 웹 데이터 요청 코드 작성"></a>3. 웹 데이터 요청 코드 작성</h3><p>본 포스팅에서는 오픈 API 중 하나인 api.itbook.store를 사용하여 API를 호출하고 응답 데이터를 받아 화면에 표시하도록 하겠다.  </p>
<p>그러면 본격적으로 테이블뷰의 셀은 어떻게 커스터마이즈 할 수 있을까? 쉽게 말해 기본적으로 제공되는 테이블뷰의 셀 스타일에서 벗어나 원하는 모양의 커스텀 셀을 직접 만들 수 없을까? 이제까지는 스토리보드에 셀 프로토타입이 만들어져 있었고, 그 프로토타입을 원하는 모양으로 만든 다음에 Identifier를 부여해서 코드에서 불러와 사용을 했었다. 그러나 이처럼 하나의 테이블뷰에서 프로토타입을 구현해 두면 다른 테이블뷰에서 사용하기 불편하다. 그래서 두 테이블 뷰에서 동시에 동일한 테이블 뷰의 셀을 사용하기 위해 셀 클래스를 따로 만들고, 인터페이스 파일을 따로 구현해 볼 것이다. 여기서는 Xib를 사용해 볼 것이다. Xib는Xml Interface Builder의 약자로 스토리보드가 생기기 전에 많이 사용하였으며, Xib 이전에는 Nib(NeXT Interface Builder)가 사용되었다. Nib에서 Xib로 변경된 이유에는 소스코드 매니지먼트가 있다. Nib은 바이너리 아카이브 파일로 이루어진 통짜 파일이라 코드의 변경 및 추적이 어렵다. 이를 Xml 기반인 Xib를 사용해서 코드의 변경 이력을 확인하기 수월하도록 개선하였다. 그러나 Xib는 각각의 뷰마다 인터페이스 파일을 생성해주어야 했기 때문에 스토리보드처럼 뷰 사이의 흐름을 파악하기는 어렵고 인터페이스 파일이 많아지는 단점이 있었다. 그래서 스토리보드가 등장했으나 지금도 인터페이스 빌더에서 Xib를 사용할 수 있다는 점이 중요하다. 이를 활용하여 자주 사용할 뷰를 만들어두고 계속해서 재사용한다거나 단독으로 뷰 컨트롤러 인터페이스를 구현할 수 있다. Xib 파일을 빌드하면 Nib 파일로 변환된다.     </p>
<p><br></p>
<p>먼저 UITableView 클래스를 상속받는 BookTableViewCell 클래스를 만들어보자. 이후 커스텀 셀을 위한 델리게이트 프로토콜을 만들어볼 것이다. 즉, 셀이 스스로 처리하지 못하는 일을 누군가에게 맡길 것이다.  </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/14/sem-%EB%B2%A0%EC%9D%B4%EC%A7%80%EC%95%88-%EA%B5%AC%EC%A1%B0%EB%B0%A9%EC%A0%95%EC%8B%9D/">
                [SEM] 베이지안 구조방정식
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-14</span>
            
            
            
                <span class="category">
                    <a href="/categories/bayesian-structural-equation-model/">Bayesian Structural Equation Model</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="베이지안-구조방정식"><a href="#베이지안-구조방정식" class="headerlink" title="베이지안 구조방정식"></a>베이지안 구조방정식</h1><p><br></p>
<h5 id="본-포스팅은-“Structural-Equation-Modeling-A-Bayesian-Apporach-Sik-Yum-Lee”-책과-“blavaan-Bayesian-Structural-Equation-Models-via-Parameter-Expansion”-내용을-바탕으로-합니다"><a href="#본-포스팅은-“Structural-Equation-Modeling-A-Bayesian-Apporach-Sik-Yum-Lee”-책과-“blavaan-Bayesian-Structural-Equation-Models-via-Parameter-Expansion”-내용을-바탕으로-합니다" class="headerlink" title="본 포스팅은 “Structural Equation Modeling: A Bayesian Apporach, Sik Yum Lee” 책과 “blavaan: Bayesian Structural Equation Models via Parameter Expansion” 내용을 바탕으로 합니다."></a>본 포스팅은 “Structural Equation Modeling: A Bayesian Apporach, Sik Yum Lee” 책과 “blavaan: Bayesian Structural Equation Models via Parameter Expansion” 내용을 바탕으로 합니다.</h5><p><br><br></p>
<h4 id="blavaan"><a href="#blavaan" class="headerlink" title="blavaan"></a>blavaan</h4><p>The intent of blavaan is to implement Bayesian structural equation models (SEMs) that harness open source MCMC samplers while simplifying model specification, summary, and extension. Bayesian SEM has received increasing attention in recent years, with MCMC samplers being developed for specific priors, specific models being estimated in JAGS and BUGS, factor analysis samplers being included in R packages bfa and MCMCpack, and multiple samplers being implemented in Mplus. These methods have notable advantages over analogous frequentist methods, including the facts that estimation of complex models is typically easier and that estimates of parameter uncertainty do not rely on asymptotic arguments. Further, in addition to allowing for the inclusion of existing knowledge into model estimates, prior distributions can be used to inform underidentified models, to average across multiple models in a single run, and to avoid Heywood cases.</p>
<p><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/11/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%B2%88%EC%99%B8%ED%8E%B8-2/">
                [iOS] 앱 개발 번외편 (2)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-11</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="로그인-회원가입-구현하기"><a href="#로그인-회원가입-구현하기" class="headerlink" title="로그인 - 회원가입 구현하기"></a>로그인 - 회원가입 구현하기</h1><p><br></p>
<p>앱 사용자에게 어떤 식으로든 메시지를 전달하고 싶을 때가 있습니다. 그것이 오류에 대한 안내 메시지이거나 혹은 오랫동안 접속하지 않은 사용자에 대한 초대 메시지이거나 간에 메시지를 보내야할 필요가 있죠. 모바일 서비스는 기본적으로 제작자와 사용자 간의 대화입니다. 제공자가 제공하는 기능과 콘텐츠, 그리고 서비스를 사용자가 이용하는 과정에서 발생하는 액션과 피드백 작용이 이들 대화의 거의 대부분을 차지하죠. 그래서 모바일 서비스에서 이루어지는 대화는 함축적인 기호나 화면 구성, 콘텐츠를 통해 간접적으로 이루어지는 경우가 많습니다.</p>
<p><br></p>
<p>하지만 때로는 보다 직접 명시적인 메시지를 전달해야 할 때가 있습니다. 서버 점검 때문에 일정 시간 동안 서비스 사용이 제한될 때 이를 안내하거나, 네트워크가 연결됮지 않은 상태를 사용자에게 인지시키고, 한동안 접속하지 않은 사용자에게 초대 메시지를 보내는 등의 경우가 이에 해당합니다. 이럴 때를 위해 코코아 터치 프레임워크에서는 사용자에게 미시지를 보낼 수 있는 다양한 방법을 지원합니다. 앱 내에서 사용자에게 메시지를 전달하는 대표적인 방법으로는 다음과 같은 것들을 꼽을 수 있습니다.</p>
<p><br></p>
<ul>
<li>메시지창(알림창)</li>
<li>로컬 알림</li>
<li>서버 알림(푸시 알림)</li>
</ul>
<p><br></p>
<p>인터넷을 사용해 본 분이라면 거의 대부분은 메시지 창, 혹은 알림창을 경험해 봤을 겁니다. 사각형의 박스 안에서 메시지를 출력하고, 버튼을 눌러 의사를 표현하도록 하는 것이 바로 알림창이죠. 사용자에게 즉각적으로 메시지를 전달할 수 있으면서 주의를 환기할 수도 있고, 다른 화면 요소에 묻혀 인식되지 않을 위험성도 낮아져 주로 경고나 알림 메시지 등에서 널리 사용되는 창입니다.</p>
<p><br></p>
<p>하지만 한 가지 단점이 있다면 이 알림창은 앱이 실행 중일 때만 동작한다는 것입니다. 사용자에게 즉각적으로 메시지를 전달해야 할 필요가 있을 경우에도 사용자가 앱을 실행하지 않으면 알림창을 노출할 수 없는 한계가 있죠. 이를 보완하기 위해 고안된 것이 로컬 알림과 서버 알림 기능입니다.</p>
<p><br></p>
<p>로컬 알림과 서버 알림은 소위 우리가 말하는 푸시 메시지 기능입니다. 아이폰을 사용해 본 적이 있는 분이라면 앱을 켜 놓지 않아도 아이폰 화면에 전달되는 메시지들을 본 적이 있을 겁니다. 이들 알림은 바로 이 기능을 가리킵니다. 공식 용어로 이들을 로컬 노티피케이션, 포시 노티피케이션이라고 부르지만 실무 현장에서는 그냥 로컬 푸시, 서버 푸시라고 부르는 경우가 더 많습니다.</p>
<p><br></p>
<p>기본적으로 모바일 디바이스 내에서 로컬 푸시와 서버 푸시를 구현하는 메커니즘은 거의 동일합니다. 하지만 메시지의 출처는 전혀 다릅니다. 로컬 푸시가 앱 내부에서 특쩡 프로세스에 의해 등록된 메시지를 iOS가 전달하는 방식이라면 서버 푸시는 별도의 서버를 통해 APNs(Apple Push Notification Service)라는 애플 고유의 메시징 시스템에게 보낸 메시지가 네트워크를 통해 전달되는 방식입니다. </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/09/fnlp-%EC%B2%9C%EC%9E%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC-1/">
                [nlp] 천장부터 시작하는 자연어처리 (1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-09</span>
            
            
            
                <span class="category">
                    <a href="/categories/natural-language-processing/">Natural Language Processing</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="트랜스포머-네트워크"><a href="#트랜스포머-네트워크" class="headerlink" title="트랜스포머 네트워크"></a>트랜스포머 네트워크</h1><p><br></p>
<h5 id="본-포스팅은-“한국어-임베딩”-책을-바탕으로-합니다"><a href="#본-포스팅은-“한국어-임베딩”-책을-바탕으로-합니다" class="headerlink" title="본 포스팅은 “한국어 임베딩” 책을 바탕으로 합니다."></a>본 포스팅은 “한국어 임베딩” 책을 바탕으로 합니다.</h5><p><br><hr><br></p>
<p>트랜스포머(Vaswani et al., 2017) 네트워크는 구글 연구 팀이 NIPS에 공개한 딥러닝 아키텍처이다. 뛰어난 성능으로 주목받았다. 이후 발표된 GPT, BERT 등 기법은 트랜스포머 블록을 기본 모델로 쓰고 있다. 이제부터 트랜스포머 모델 가운데 기본 블록의 산 과정과 그 작동 원리를 살펴보도록 한다. 하단 멀티헤드 어텐션과 상단 피드포워 네트워크를 설명한다.</p>
<p><br></p>
<h4 id="Scaled-Dot-Product-Attention"><a href="#Scaled-Dot-Product-Attention" class="headerlink" title="Scaled Dot-Product Attention"></a>Scaled Dot-Product Attention</h4><p>트랜스포머 블록의 주요 구성 요소 가운데 하나가 바로 Scaled Dot-Product Attention이다. 여기서 입력은 기본적으로 행렬 형태를 가지며 그 크기는 입력 문장의 단어 수 <em> 입력 임베딩의 차원 수다. 예컨대 “드디어, 금요일, 이다”라는 문장이 Scaled Dot-Product Attention 입력으로 들어가고 그 히든 차원 수가 768차원이라면 이 레이어의 력 행렬의 크기는 3 </em> 768이 된다.</p>
<p><br></p>
<p>트랜스포머의 Scaled Dot-Product Attention 메터니즘은 쿼리, 키, 값 세 가지 사이의 다이나믹스가 핵심이다. 입력 행렬과 쿼리, 키, 값에 해당하는 행렬을 각각 곱해 계한다. 이후 쿼리와 키가 얼마나 관련을 맺고 있는지를 나타내기 위해 입력 행렬과 쿼리 행렬을 곱한 결과와 입력 행렬과 키 행렬을 곱한 결과를 내적하여 키 벡터의 차원 수의 제곱근을 나누어준 뒤 소프트맥스를 취한다. 마지막으로 이 확률 값을 가중치 삼아 값에 해당하는 벡터들을 가중합한다.</p>
<p><br></p>
<p>Scaled Dot-Product Attention은 어떻게 단어들 사이의 의미적, 문법적 관계를 포착해낼 수 있는 걸까. 그 비결 중 일부는 기법 이름 속에 숨어 있다. 첫째는 dot-product, 둘째는 attention, 셋째는 scale이다. 선형대수학에서 dot-product는 내적을 달리 이르는 말이다. 내적은 벡터 간 유사도 측정 기법의 일종인 코사인 유사도와 깊은 관련 가진다. 두 벡터를 내적하고 이들 길이의 곱으로 나눠준 값이 바로 코사인 유사도다. 두 벡터가 모두 길이 1인 단위 벡터라면 두 벡터의 내적 자체가 코사인 유사도이며 그 값이 크면 클수록 코사인 유사도는 높아진다. 코사인 유사도는 두 벡터 사이의 각가 0도로 완전히 같을 경우 최대값 1, 180도로 완전히 반대인 경우 최소값 -1이 된다.</p>
<p><br></p>
<p>어떤 쿼리와 키가 특정 태스크 수행에 중요한 역할을 하고 있다면 트랜스포머 블록은 이들 사이의 내적 값을 키우는 방식으로 학습한다. 내적 값이 커지면 해당 쿼리와 키 벡터 공간상 가까이에 있을 가능성이 높아진다. 셀프 어텐션은 같은 문장 내 모든 어 쌍 사이의 의미적, 문법적 관계를 포착해낸다는 뜻이다. Scaled Dot-Production Attention은 소프트맥스 행렬과 값 행렬을 내적하는 것으로 마무리된다. 이는 소프트맥스 확률을 가중치 삼아 각 값 벡터들을 가중합하는 것과 같다. 따라서 Scaled Dot-Production Attention 결과 새롭게 만드어진 벡터는 해당 문장 내 단어 쌍 관계가 모두 축된 결과다.</p>
<p><br></p>
<p>셀프 어텐션은 기존 RNN, CNN 보다 장점이 많다. CNN의 경우 사용자가 정한 특정 윈도우 내의 로컬 문맥만 살핀다. 예컨대 문장 길이가 꽤 길고 맨 처음 단어와 마지막 단 사이의 연관성 파악이 태스크 수행에 중요한 데이터라면 CNN으로 이를 해결하기는 지 않다. 한편 RNN은 시퀀스 길이가 길어질수록 그래디언트 문제가 발생할 염려가 있다. 다시 말해 시퀀스가 길면 처음 입력받았던 단어는 RNN 모델이 잊어버릴 가능성이 높다는 이야기다. 하지만 트랜스포머와 같은 셀프 어텐션 기법은 문장 내 모든 단어쌍 사이의 관계를 늘 전체적으로 파악할 수 있다. 이 덕분에 트랜스포머는 컨볼루션 필나 RNN 셀 없이도 자연어 처리 태스크를 성공적으로 수행할 수 있었다.</p>
<p><br></p>
<p>또 다른 중요 요소는 scale이다. Scaled Dot-Product Attention에서는 쿼리와 키 행렬을 내적한 뒤 키 행렬 차원 수의 제곱근을 나눠줘 스케일을 하고 있다. Vaswani et al. (2017)에 따르면 이 경우에 쿼리-키 내적 행렬의 분산을 줄이게 돼 소프트맥스의 그래디언트가 지나치게 작아지는 것을 방지할 수 있다.</p>
<p><br><br></p>
<h4 id="멀티헤드-어텐션"><a href="#멀티헤드-어텐션" class="headerlink" title="멀티헤드 어텐션"></a>멀티헤드 어텐션</h4><p>트랜스포머 블록에서 멀티헤드 어텐션은 Scaled Dot-Product Attention을 여러 번 시하는 것을 가리킨다. 동일한 문장을 여러 명의 독자가 동시에 분석해 최선의 결과를 내려고 하는 것에 비유할 수 있겠다. 멀티헤드 어텐션의 계산 과정은 미리 만들어놓은 쿼리, 키, 값에 Scaled Dot-Production을 h번 수행한다. 이후 각 헤드의 결과 행렬을 이어 붙여 긴 행렬을 만들어 사용한다.</p>
<p><br><br></p>
<h4 id="Position-wise-Feedforward-Networks"><a href="#Position-wise-Feedforward-Networks" class="headerlink" title="Position-wise Feedforward Networks"></a>Position-wise Feedforward Networks</h4><p>멀티헤드 어텐션 레이어의 입력 행렬과 출력 행렬의 크기는 입력 단어 수 * 히든 벡터 차원 수로 동일하다. Position-wise Feedforward Networks 레이어에서는 멀티헤드 어텐션 레이어의 출력 행렬을 행 벡터 단위로, 다시 말해 단어 벡터 각각에 관해 수식을 적용한다. 멀티헤드 어텐션 레이어의 출력 행렬 가운데 하나의 단어 벡터에 관해 두 번의 선형변환을 수행하며 그 사이에 ReLU를 적용한다.</p>
<p><br><br></p>
<h4 id="트랜스포머의-학습-전략"><a href="#트랜스포머의-학습-전략" class="headerlink" title="트랜스포머의 학습 전략"></a>트랜스포머의 학습 전략</h4><p>트랜스포머의 학습 전략은 웜업(warm up)이다. 사용자가 정한 스텝 수에 이르기까지 습률을 올렸다가 스텝 수를 만족하면 조금씩 떨어뜨리는 방식이다. 대규모 데이터,  모델 학습에 적합하다. 이 전략은 BERT 등 이후 제안된 모델에도 널리 쓰이고 있다. 이밖에 레이어 정규화 등도 트랜스포머의 안정적인 학습에 기여하고 있는 것으로 보다.</p>
<p><br><br></p>
<h4 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h4><p>BERT(Bidirectional Encoder Representations from Transformer)는 구글에서 공개한 모델이다. 성능이 뛰어나 널리 쓰이고 있다. BERT의 성공 비결은 그 퍼포먼스가 검증된 트랜스포머 블록을 썼을뿐더러 모델의 속성이 양방향을 지향한다는 점에 있다. GPT는 단어 시퀀스를 왼쪽에서 오른쪽으로 한 방향으로만 모든 아키텍처이다. ELMo는 Bi-LSTM 레이어의 상단은 양방향이지만 중간 레이어 역시 한 방향인 모델이다. 반면 BERT의 경우 모든 레이어에서 양방향 성질을 잃지 않고 있다.</p>
<p><br></p>
<p>BERT와 GPT 모델은 모두 트랜스포머 블록을 사용하고 있다. 그렇다면 GPT는 왜 단어들을 양방향으로 보지 못하는 것일까? 그 이유는 GPT가 언어 모델이기 때문이다. GPT는 주어진 단어 시퀀스를 가지고 그다음 단어를 예측하는 과정에서 학습한다. 이 경우 현재 입력 단어 이후의 단어를 모델에게 알려주는 것은 반칙이다. 언어 모델은 주어진 시퀀스를 가지고 다음 단어를 맞춰야 하는데, 맞춰야할 정답을 미리 알려줄 수는 없기 때문이다. Devline et al. (2018)은 이 문제를 극복하기 위해 마스크 언어 모델(masked language model)을 제안했다. 주어진 시퀀스 다음 단어를 맞추는 것에서 벗어나, 일단 문장 전체를 모델에게 알려주고, 빈칸(MASK)에 해당하는 단어가 어떤 단어일지 예측하는 과정에서 학습을 해보자는 아이디어다. 마스크 언어 모델 태스크에서는 모델에 문장 전체를 다 주어도 반칙이 될 수 없다. BERT 모델은 빈칸을 채워야 하기 때문이다.</p>
<p><br></p>
<p>GPT는 Scaled Dot-Product Attention을 하는 과정에서 예측해야 할 단어를 보지 않기 위해 소프트맥스 스코어 행렬의 일부 값을 0으로 만든다. 예컨대 입력 문장이 꿈, 보다, 해몽이고 이번에 예측해야 할 단어가 보다라면 GPT는 이전 단어인 꿈만 참고할 수 있다. 해몽이라는 단어를 맞춰야 할 순서라면 GPT는 꿈, 보다만을 참고해야 한다. 반면 BERT는 빈칸만 맞추면 되기 때문에 그림처럼 문장 내 단어 쌍 사이의 관계를 모두 볼 수 있다.</p>
<p><br></p>
<p>Devlin et al. (2018)은 BERT 임베딩을 각종 다운스트림 태스크에 적용해 실험한 결과 BERT의 임베딩 품질이 GPT보다 좋음을 입증했다. 그만큼 모델이 양방향 전후 문맥을 모두 보게 하는 것이 중요하다는 이야기다. BERT가 양방향 모델이 될 수 있었던 배경은 모델이 순방향, 역방향 문맥을 모두 볼 수 있도록 하는 학습 태스크 덕분이다. BERT의 프리트레인 태스크에는 크게 마스크 언어 모델, 다음 문장인지 여부 맞추기 두 가지가 있다. 먼저 마스크 언어 모델 태스크 수행을 위한 학습 데이터는 다음과 같이 만든다.</p>
<p><br></p>
<ul>
<li>학습 데이터 한 문장 토큰의 15%를 마스킹한다.</li>
<li>마스킹 대상 토큰 가운데 80%는 실제 빈칸으로 만들고, 모델은 그 빈칸을 채운다.</li>
<li>마스킹 대상 토큰 가운데 10%는 랜덤으로 다른 토큰으로 대체하고, 모델은 해당 위치의 정답 언어가 무엇일지 맞추도록 한다.</li>
<li>마스킹 대상 토큰 가운데 10%는 토큰 그대로 두고, 모델은 해당 위치의 정답 단어가 무엇일지 맞추도록 한다.</li>
</ul>
<p><br></p>
<p>이같이 학습 데이터를 만들게 되면 우리는 다음을 기대할 수 있다.</p>
<ul>
<li>빈칸을 채워야 하기 때문에 문장 내 어느 자리에 어떤 단어를 쓰는 게 자연스러운지 앞뒤 문맥을 읽어낼 수 있게 된다.</li>
<li>주어진 문장을 비교해 보면서 문장이 의미/문법상 비문인지 아닌지 가려낼 수 있다.</li>
<li>모델은 어떤 단어가 마스킹될지 전혀 모르기 때문에 문장 내 모든 단어 사이의 의미적, 문법적 관계를 세밀히 살피게 된다.</li>
</ul>
<p><br></p>
<p>다음 문장인지 여부를 맞추기 위한 학습 데이터는 다음과 같이 만든다.</p>
<ul>
<li>모든 학습 데이터는 1건당 문장 두 개로 구성된다.</li>
<li>이 가운데 절반은 동일한 문서에서 실제 이어지는 문장을 두 개 뽑고, 그 정답으로 참을 부여한다.</li>
<li>나머지 절반은 서로 다른 문서에서 문장 하나씩 뽑고, 그 정답으로 거짓을 부여한다.</li>
<li>max_num_tokens를 정의한다.</li>
<li>이전에 뽑은 문장 두 개의 단어 총 수가 max_num_token을 넘지 못할 때까지 두 문장 중 단어 수가 많은 쪽을 50%의 확률로 무장 맨 앞 또는 맨 뒤 단어 하나씩 제거한다.</li>
</ul>
<p><br></p>
<p>이같이 학습 데이터를 만들게 되면 우리는 다음을 기대할 수 있다.</p>
<ul>
<li>모델은 주어진 문장이 이어진 문장인지 아닌지 반복 학습한다. 따라서 문장 간 의미 관계를 이해할 수 있다.</li>
<li>일부 문장 성분이 없어도 전체 의미를 이해하는 데 큰 무리가 없다. NSP 태스크가 너무 쉬워지는 것을 방지하기 위해 문장 맨 앞 또는 맨 뒤쪽 단어 일부를 삭제했기 때문이다.</li>
<li>학습 데이터에 짧은 문장이 포함돼 있어도 성능이 크게 떨어지지 않는다.</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/09/nlp-%EC%B2%9C%EC%9E%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC-1/">
                [nlp] 천장부터 시작하는 자연어처리 (1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-09</span>
            
            
            
                <span class="category">
                    <a href="/categories/nlp/">NLP</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="트랜스포머-네트워크"><a href="#트랜스포머-네트워크" class="headerlink" title="트랜스포머 네트워크"></a>트랜스포머 네트워크</h1><p><br></p>
<h5 id="본-포스팅은-“한국어-임베딩”-책을-바탕으로-합니다"><a href="#본-포스팅은-“한국어-임베딩”-책을-바탕으로-합니다" class="headerlink" title="본 포스팅은 “한국어 임베딩” 책을 바탕으로 합니다."></a>본 포스팅은 “한국어 임베딩” 책을 바탕으로 합니다.</h5><p><br><hr><br></p>
<p>트랜스포머(Vaswani et al., 2017) 네트워크는 구글 연구 팀이 NIPS에 공개한 딥러닝 아키텍처이다. 뛰어난 성능으로 주목받았다. 이후 발표된 GPT, BERT 등 기법은 트랜스포머 블록을 기본 모델로 쓰고 있다. 이제부터 트랜스포머 모델 가운데 기본 블록의 산 과정과 그 작동 원리를 살펴보도록 한다. 하단 멀티헤드 어텐션과 상단 피드포워 네트워크를 설명한다.</p>
<p><br></p>
<h4 id="Scaled-Dot-Product-Attention"><a href="#Scaled-Dot-Product-Attention" class="headerlink" title="Scaled Dot-Product Attention"></a>Scaled Dot-Product Attention</h4><p>트랜스포머 블록의 주요 구성 요소 가운데 하나가 바로 Scaled Dot-Product Attention이다. 여기서 입력은 기본적으로 행렬 형태를 가지며 그 크기는 입력 문장의 단어 수 <em> 입력 임베딩의 차원 수다. 예컨대 “드디어, 금요일, 이다”라는 문장이 Scaled Dot-Product Attention 입력으로 들어가고 그 히든 차원 수가 768차원이라면 이 레이어의 력 행렬의 크기는 3 </em> 768이 된다.</p>
<p><br></p>
<p>트랜스포머의 Scaled Dot-Product Attention 메터니즘은 쿼리, 키, 값 세 가지 사이의 다이나믹스가 핵심이다. 입력 행렬과 쿼리, 키, 값에 해당하는 행렬을 각각 곱해 계한다. 이후 쿼리와 키가 얼마나 관련을 맺고 있는지를 나타내기 위해 입력 행렬과 쿼리 행렬을 곱한 결과와 입력 행렬과 키 행렬을 곱한 결과를 내적하여 키 벡터의 차원 수의 제곱근을 나누어준 뒤 소프트맥스를 취한다. 마지막으로 이 확률 값을 가중치 삼아 값에 해당하는 벡터들을 가중합한다.</p>
<p><br></p>
<p>Scaled Dot-Product Attention은 어떻게 단어들 사이의 의미적, 문법적 관계를 포착해낼 수 있는 걸까. 그 비결 중 일부는 기법 이름 속에 숨어 있다. 첫째는 dot-product, 둘째는 attention, 셋째는 scale이다. 선형대수학에서 dot-product는 내적을 달리 이르는 말이다. 내적은 벡터 간 유사도 측정 기법의 일종인 코사인 유사도와 깊은 관련 가진다. 두 벡터를 내적하고 이들 길이의 곱으로 나눠준 값이 바로 코사인 유사도다. 두 벡터가 모두 길이 1인 단위 벡터라면 두 벡터의 내적 자체가 코사인 유사도이며 그 값이 크면 클수록 코사인 유사도는 높아진다. 코사인 유사도는 두 벡터 사이의 각가 0도로 완전히 같을 경우 최대값 1, 180도로 완전히 반대인 경우 최소값 -1이 된다.</p>
<p><br></p>
<p>어떤 쿼리와 키가 특정 태스크 수행에 중요한 역할을 하고 있다면 트랜스포머 블록은 이들 사이의 내적 값을 키우는 방식으로 학습한다. 내적 값이 커지면 해당 쿼리와 키 벡터 공간상 가까이에 있을 가능성이 높아진다. 셀프 어텐션은 같은 문장 내 모든 어 쌍 사이의 의미적, 문법적 관계를 포착해낸다는 뜻이다. Scaled Dot-Production Attention은 소프트맥스 행렬과 값 행렬을 내적하는 것으로 마무리된다. 이는 소프트맥스 확률을 가중치 삼아 각 값 벡터들을 가중합하는 것과 같다. 따라서 Scaled Dot-Production Attention 결과 새롭게 만드어진 벡터는 해당 문장 내 단어 쌍 관계가 모두 축된 결과다.</p>
<p><br></p>
<p>셀프 어텐션은 기존 RNN, CNN 보다 장점이 많다. CNN의 경우 사용자가 정한 특정 윈도우 내의 로컬 문맥만 살핀다. 예컨대 문장 길이가 꽤 길고 맨 처음 단어와 마지막 단 사이의 연관성 파악이 태스크 수행에 중요한 데이터라면 CNN으로 이를 해결하기는 지 않다. 한편 RNN은 시퀀스 길이가 길어질수록 그래디언트 문제가 발생할 염려가 있다. 다시 말해 시퀀스가 길면 처음 입력받았던 단어는 RNN 모델이 잊어버릴 가능성이 높다는 이야기다. 하지만 트랜스포머와 같은 셀프 어텐션 기법은 문장 내 모든 단어쌍 사이의 관계를 늘 전체적으로 파악할 수 있다. 이 덕분에 트랜스포머는 컨볼루션 필나 RNN 셀 없이도 자연어 처리 태스크를 성공적으로 수행할 수 있었다.</p>
<p><br></p>
<p>또 다른 중요 요소는 scale이다. Scaled Dot-Product Attention에서는 쿼리와 키 행렬을 내적한 뒤 키 행렬 차원 수의 제곱근을 나눠줘 스케일을 하고 있다. Vaswani et al. (2017)에 따르면 이 경우에 쿼리-키 내적 행렬의 분산을 줄이게 돼 소프트맥스의 그래디언트가 지나치게 작아지는 것을 방지할 수 있다.</p>
<p><br><br></p>
<h4 id="멀티헤드-어텐션"><a href="#멀티헤드-어텐션" class="headerlink" title="멀티헤드 어텐션"></a>멀티헤드 어텐션</h4><p>트랜스포머 블록에서 멀티헤드 어텐션은 Scaled Dot-Product Attention을 여러 번 시하는 것을 가리킨다. 동일한 문장을 여러 명의 독자가 동시에 분석해 최선의 결과를 내려고 하는 것에 비유할 수 있겠다. 멀티헤드 어텐션의 계산 과정은 미리 만들어놓은 쿼리, 키, 값에 Scaled Dot-Production을 h번 수행한다. 이후 각 헤드의 결과 행렬을 이어 붙여 긴 행렬을 만들어 사용한다.</p>
<p><br><br></p>
<h4 id="Position-wise-Feedforward-Networks"><a href="#Position-wise-Feedforward-Networks" class="headerlink" title="Position-wise Feedforward Networks"></a>Position-wise Feedforward Networks</h4><p>멀티헤드 어텐션 레이어의 입력 행렬과 출력 행렬의 크기는 입력 단어 수 * 히든 벡터 차원 수로 동일하다. Position-wise Feedforward Networks 레이어에서는 멀티헤드 어텐션 레이어의 출력 행렬을 행 벡터 단위로, 다시 말해 단어 벡터 각각에 관해 수식을 적용한다. 멀티헤드 어텐션 레이어의 출력 행렬 가운데 하나의 단어 벡터에 관해 두 번의 선형변환을 수행하며 그 사이에 ReLU를 적용한다.</p>
<p><br><br></p>
<h4 id="트랜스포머의-학습-전략"><a href="#트랜스포머의-학습-전략" class="headerlink" title="트랜스포머의 학습 전략"></a>트랜스포머의 학습 전략</h4><p>트랜스포머의 학습 전략은 웜업(warm up)이다. 사용자가 정한 스텝 수에 이르기까지 습률을 올렸다가 스텝 수를 만족하면 조금씩 떨어뜨리는 방식이다. 대규모 데이터,  모델 학습에 적합하다. 이 전략은 BERT 등 이후 제안된 모델에도 널리 쓰이고 있다. 이밖에 레이어 정규화 등도 트랜스포머의 안정적인 학습에 기여하고 있는 것으로 보다.</p>
<p><br><br></p>
<h4 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h4><p>BERT(Bidirectional Encoder Representations from Transformer)는 구글에서 공개한 모델이다. 성능이 뛰어나 널리 쓰이고 있다. BERT의 성공 비결은 그 퍼포먼스가 검증된 트랜스포머 블록을 썼을뿐더러 모델의 속성이 양방향을 지향한다는 점에 있다. GPT는 단어 시퀀스를 왼쪽에서 오른쪽으로 한 방향으로만 모든 아키텍처이다. ELMo는 Bi-LSTM 레이어의 상단은 양방향이지만 중간 레이어 역시 한 방향인 모델이다. 반면 BERT의 경우 모든 레이어에서 양방향 성질을 잃지 않고 있다.</p>
<p><br></p>
<p>BERT와 GPT 모델은 모두 트랜스포머 블록을 사용하고 있다. 그렇다면 GPT는 왜 단어들을 양방향으로 보지 못하는 것일까? 그 이유는 GPT가 언어 모델이기 때문이다. GPT는 주어진 단어 시퀀스를 가지고 그다음 단어를 예측하는 과정에서 학습한다. 이 경우 현재 입력 단어 이후의 단어를 모델에게 알려주는 것은 반칙이다. 언어 모델은 주어진 시퀀스를 가지고 다음 단어를 맞춰야 하는데, 맞춰야할 정답을 미리 알려줄 수는 없기 때문이다. Devline et al. (2018)은 이 문제를 극복하기 위해 마스크 언어 모델(masked language model)을 제안했다. 주어진 시퀀스 다음 단어를 맞추는 것에서 벗어나, 일단 문장 전체를 모델에게 알려주고, 빈칸(MASK)에 해당하는 단어가 어떤 단어일지 예측하는 과정에서 학습을 해보자는 아이디어다. 마스크 언어 모델 태스크에서는 모델에 문장 전체를 다 주어도 반칙이 될 수 없다. BERT 모델은 빈칸을 채워야 하기 때문이다.</p>
<p><br></p>
<p>GPT는 Scaled Dot-Product Attention을 하는 과정에서 예측해야 할 단어를 보지 않기 위해 소프트맥스 스코어 행렬의 일부 값을 0으로 만든다. 예컨대 입력 문장이 꿈, 보다, 해몽이고 이번에 예측해야 할 단어가 보다라면 GPT는 이전 단어인 꿈만 참고할 수 있다. 해몽이라는 단어를 맞춰야 할 순서라면 GPT는 꿈, 보다만을 참고해야 한다. 반면 BERT는 빈칸만 맞추면 되기 때문에 그림처럼 문장 내 단어 쌍 사이의 관계를 모두 볼 수 있다.</p>
<p><br></p>
<p>Devlin et al. (2018)은 BERT 임베딩을 각종 다운스트림 태스크에 적용해 실험한 결과 BERT의 임베딩 품질이 GPT보다 좋음을 입증했다. 그만큼 모델이 양방향 전후 문맥을 모두 보게 하는 것이 중요하다는 이야기다. BERT가 양방향 모델이 될 수 있었던 배경은 모델이 순방향, 역방향 문맥을 모두 볼 수 있도록 하는 학습 태스크 덕분이다. BERT의 프리트레인 태스크에는 크게 마스크 언어 모델, 다음 문장인지 여부 맞추기 두 가지가 있다. 먼저 마스크 언어 모델 태스크 수행을 위한 학습 데이터는 다음과 같이 만든다.</p>
<p><br></p>
<ul>
<li>학습 데이터 한 문장 토큰의 15%를 마스킹한다.</li>
<li>마스킹 대상 토큰 가운데 80%는 실제 빈칸으로 만들고, 모델은 그 빈칸을 채운다.</li>
<li>마스킹 대상 토큰 가운데 10%는 랜덤으로 다른 토큰으로 대체하고, 모델은 해당 위치의 정답 언어가 무엇일지 맞추도록 한다.</li>
<li>마스킹 대상 토큰 가운데 10%는 토큰 그대로 두고, 모델은 해당 위치의 정답 단어가 무엇일지 맞추도록 한다.</li>
</ul>
<p><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/01/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%B2%88%EC%99%B8%ED%8E%B8-1/">
                [iOS] 앱 개발 번외편 (1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-01</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="iOS-영화-목록을-받아와-보여주는-영화정보-제공-App-만들기"><a href="#iOS-영화-목록을-받아와-보여주는-영화정보-제공-App-만들기" class="headerlink" title="[iOS] 영화 목록을 받아와 보여주는 영화정보 제공 App 만들기"></a>[iOS] 영화 목록을 받아와 보여주는 영화정보 제공 App 만들기</h1><p><br></p>
<h4 id="오픈-API를-사용하여-앱을-개발하는-과정"><a href="#오픈-API를-사용하여-앱을-개발하는-과정" class="headerlink" title="오픈 API를 사용하여 앱을 개발하는 과정"></a>오픈 API를 사용하여 앱을 개발하는 과정</h4><ul>
<li>1단계: 원하는 정보를 제공하는 웹 서비스와 사용할 API 검색</li>
<li>2단계: 오픈 API 사용을 위한 신청과 인증 키 발급</li>
<li>3단계: 앱 내에서 네트워크를 통해 데이터를 받아오도록 코드 구현</li>
<li>4단계: 전달받은 데이터를 파싱하여 사용</li>
</ul>
<p><br><hr><br></p>
<h4 id="API-기본-정보"><a href="#API-기본-정보" class="headerlink" title="API 기본 정보"></a>API 기본 정보</h4><ul>
<li>Request URI : <a href="https://yts.mx/api/v2/list_movies.json?minimum_rating={평점}&amp;limit={갯수}" target="_blank" rel="noopener">https://yts.mx/api/v2/list_movies.json?minimum_rating={평점}&amp;limit={갯수}</a></li>
</ul>
<p><br></p>
<p>Request URI는 영화 차트 API를 호출하기 위한 네트워크상의 주소입니다. 우리는 다만 이 URL을 그대로 사용하는 것이 아니라 중괄호로 둘러싸인 부분을 적절한 값으로 치환한 다음에 호출해야 합니다. 어떤 값을 대입해야 할지는 뒤에 이어지는 Querystring Parameters 부분을 확인하면 알 수 있습니다. 이 API는 REST 프로토콜 형식을 사용하여 GET 방식으로 호출해야 합니다.</p>
<p><br></p>
<p><img src="/image/ios9.png" alt="ios9"></p>
<p><br></p>
<p>위 URI에 원하는 정보에 맞게 대입하여 경로를 만들어 네트워크 객체에 넣어 호출하면 원하는 영화 목록을 회신받을 수 있습니다. 이 주소는 일반 브라우저에서도 동작하기 때문에, 크롬과 같은 브라우저에서 주소 줄 위에 URI를 입력하면 위와 같은 결과를 볼 수 있습니다.</p>
<p><br></p>
<h4 id="응답-데이터-형식"><a href="#응답-데이터-형식" class="headerlink" title="응답 데이터 형식"></a>응답 데이터 형식</h4><p><br></p>
<p><img src="/image/ios10.png" alt="ios10"></p>
<p><br></p>
<p>URI를 통해 응답받은 영화 목록은 JSON 형태로 이루어져 있습니다. JSON 정렬 사이트 등을 이용하여 미리 데이터를 정렬하는 것이 좋습니다. 위 화면에서 각각의 항목은 계층 관계를 이루고 있으며 이를 들여쓰기를 통해 표시하고 있습니다. 우리가 앱 내에서 URI를 호출했을 때 응답받을 데이터 항목은 실제로 이와 같은 구조를 가지고 있으므로 데이터를 파싱하기 위해서는 위 구조를 잘 이해해야 합니다. 영화 정보 목록은 배열 형식으로 이루어지는데, 이 값들은 data -&gt; movies 아래에 저장됩니다. 배열 형식에서 반복 작성된 영화 정보들은 각각 id, url, imdb_code, title 등을 제공합니다. 이제 직접 요청 URI를 만들어 호출해 보고, 그 결과값을 받아 파싱처리하는 코드를 작성해 보겠습니다.</p>
<p><br></p>
<h4 id="네비게이션-컨트롤러를-이용한-화면-전환"><a href="#네비게이션-컨트롤러를-이용한-화면-전환" class="headerlink" title="네비게이션 컨트롤러를 이용한 화면 전환"></a>네비게이션 컨트롤러를 이용한 화면 전환</h4><p>그 전에 먼저 Navigation Controller를 사용하여 기본적인 화면 전환을 구성해 보도록 하겠습니다. 네비게이션 컨트롤러는 뷰 컨트롤러의 특별한 종류로, 계층적인 성격을 띠는 콘텐츠 구조를 관리하기 위한 컨트롤러입니다. 앱의 네비게이션을 표시해줄 수 있는 내비게이션 바가 내장되어 있죠.</p>
<p><br></p>
<p>네비게이션 컨트롤러는 뷰 컨트롤러들의 전환을 직접 컨트롤하고, 앱의 네비게이션 정보를 표시하는 역할을 할 뿐만 아니라 화면 전환이 발생하는 뷰 컨트롤러들의 포인터를 스택으로 관리하여 원하는 화면에 접근하기 쉽게 합니다.</p>
<p><br></p>
<p>네비게이션 컨트롤러는 뷰 컨트롤러들의 계층적 구조를 관리하는 역할이기 때문에, 직접 콘텐츠를 담고 화면을 구성하지는 않습니다. 대신 다른 뷰 컨트롤러들을 포함하고 있죠. 이 때문에 스토리보드에서 보이는 것과 다르게 독립된 자신만의 화면을 가지지 않는 대신, 이 컨트롤러가 제어하는 모든 뷰 컨트롤러에 네비게이션 바를 생성하는 특징이 있습니다.</p>
<p><br></p>
<p><img src="/image/ios11.jpeg" alt="ios11"></p>
<p><br></p>
<p>위 그림은 네비게이션 컨트롤러가 관리하는 뷰 컨트롤러 객체 관계를 나타냅니다. 네비게이션 컨트롤러는 항상 콘텐츠 계층 구조의 시작점 역할을 하는 뷰 컨트롤러와 함께 다니는데, 이를 루트 뷰 컨트롤러라고 합니다. 거의 뭐 베스트 프렌드라고 할 수 있죠. 루트 뷰 컨트롤러는 네비게이션 컨트롤러에 직접 연결된 컨트롤러이므로 화면 UI 상단에 네비게이션 바가 표시됩니다. 류트 뷰 컨트롤러에서 화면 전환이 발생하면 다음 뷰 컨트롤러가 그 위로 올라오지만, 이때에도 역시 상단에 추가된 네비게이션 바는 그대로 유지됩니다.</p>
<p><br></p>
<p>네비게이션 컨트롤러는 화면에 현재 표시되고 있는 뷰 컨트롤러들을 네비게이션 스택을 이용하여 관리합니다. 네비게이션 스택은 배열 형식으로 되어 있죠. 배열을 세로로 쌓았다고 할 때, 가장 아래에 있는 첫 번째 뷰 컨트롤러는 루트 뷰 컨트롤러이고, 최상위에 있는 마지막 뷰 컨트롤러는 현재 화면에 표시되고 있는 뷰 컨트롤러입니다. 네비게이션 컨트롤러 객체의 메소드를 사용하려면 스택의 정보를 수정할 수 있는데, 기본적으로 스택의 최상위에 뷰 컨트롤러를 추가할 때는 pushViewController(_:animated:) 메소드를 사용합니다. 반대로 스택의 최상위 뷰 컨트롤러를 제거할 때에는 popViewController(animated:) 메소드를 사용합니다. 네비게이션 컨트롤러를 사용해서 화면을 전환하고 복귀하는 기능을 실제로 구현해봅시다.</p>
<p><br><hr><br></p>
<p><img src="/image/ios12.png" alt="ios12"></p>
<p><br></p>
<p>영화 리스트를 보여줄 새로운 뷰 컨트롤러까지 추가한 상태입니다. 영화 리스트를 보여줄 뷰 컨트롤러의 아이덴티티 인스펙터 탭에서 Storyboard ID 항목에 ‘MovieList’를 입력합니다. 다시 첫 번째 뷰 컨트롤러에 돌아가서, 버튼을 추가합니다. 추가된 버튼을 ViewController 클래스로 드래그합니다. 연결 정보창에서는 [Connection] 항목을 Action으로 선택하고, [Name] 항목을 MoveToList로 입력하였습니다. ViewController 클래스에 추가된 moveToList 메소드에 다음과 같은 내용을 작성합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewController.swift</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">moveToList</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">        <span class="comment">// MovieList 뷰 컨트롤러 인스턴스를 가져온다.</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> uvc = <span class="keyword">self</span>.storyboard?.instantiateViewController(identifier: <span class="string">"MovieList"</span>) <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 화면을 전환한다.</span></span><br><span class="line">        <span class="keyword">self</span>.navigationController?.pushViewController(uvc, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>메소드에 추가된 내용을 살펴봅시다. 스토리보드에서 설정했던 아이디를 이용하여 뷰 컨트롤러를 읽어오고, 객체로 생성하는 내용이 먼저 나옵니다. 안전한 코드를 위해 self.storyboard를 옵셔널 체인으로 처리하여 instantiateViewController(withIdentifier:) 메소드를 호출하여 뷰 컨트롤러의 인스턴스를 받아온 다음, 옵셔널 타입을 해제하기 위해 상수 uve에 바인딩합니다. 만약 바인딩이 실패할 경우, 해당 메소드의 실행은 중지됩니다.</p>
<p><br></p>
<p>화면 전환을 처리하는 부분에는 pushViewController(_:animated:) 메소드가 사용되었습니다. 기술적 관점에서 네비게이션 스택 최상위에 뷰 컨트롤러 객체 uvc를 추가하는 것이지만, 사용자들에게는 화면을 전환하는 결과로 나타납니다. 유의할 점은 메소드를 호출하는 대상입니다. 해당 메소드는 호출하는 대상이 네비게이션 컨트롤러입니다. self.navigationController는 현재의 뷰 컨트롤러에 연결된 네비게이션 컨트롤러를 가리키는 것으로, 만약 뷰 컨트롤러에 네비게이션 컨트롤러가 연결되어 있지 않을 경우 nil 값을 반환합니다.</p>
<p><br></p>
<p>잠깐만! 여기까지 코드를 통해 화면 전환을 하는 법을 알아보았고, 다음은 스토리보드에서 간단히 세그웨이 지정을 통해 원하는 구성대로 화면 전환이 되도록 만들어보았습니다. 이를 바탕으로 네트워크 객체를 통한 데이터 요청 기능 구현을 살펴보도록 하겠습니다. 그 전에 먼저 세그웨이를 이용하여 화면 전환하면서 값을 전달하는 방법을 알아보도록 하겠습니다.<br><br></p>
<p><img src="/image/ios13.png" alt="ios13"></p>
<p><br></p>
<h4 id="세그웨이를-이용하여-화면-전환하면서-값을-전달하기"><a href="#세그웨이를-이용하여-화면-전환하면서-값을-전달하기" class="headerlink" title="세그웨이를 이용하여 화면 전환하면서 값을 전달하기"></a>세그웨이를 이용하여 화면 전환하면서 값을 전달하기</h4><p>화면을 전환해주는 객체인 세그웨이는 수동으로 실행할 수 있는 매뉴얼 세그웨이와 자동으로 실행되는 액션 세그웨이로 나누어집니다. 하지만 어느 세그웨이를 사용하든 값을 전달하는 방식은 모두 동일합니다. 가장 먼저 할 일은 세그웨이를 위 처럼 연결하는 겁니다. 세그웨이 종류는 네비게이션 바가 추가되었으니 [Show] 타입으로 생성하면 될 것 같네요. 메인 화면에서 영화 리스트를 보여주는 화면으로 전환되는 세그웨이에 MovieList로 [Identifier] 항목의 값을 입력하였습니다.</p>
<p><br></p>
<p>자, 그러면 여기서 문제입니다. 값을 전달하는 코드는 어디에 넣어야 할까요? 정답은 “세그웨이 실행을 위한 준비 메소드 부분에 값을 전달해준다”입니다. 세그웨이 전처리 메소드 prepare(for:sender:) 메소드는 세그웨이가 실행되기 직전에 호출되는 메소드입니다. 이 메소드는 우리가 직접 호출하는 것이 아니라 필요한 내용을 작성해 둔 다음 가만히 놔두면 iOS 시스템이 알아서 적절한 시점에 호출하는 지뢰 같은 존재입니다. 메뉴얼 세그웨이나 액션 세그웨이에 구분없이 모든 세그웨이가 실행되기 전에 iOS는 prepare(for:sender:) 메소드를 먼저 호출합니다. 커스텀 클래스에서 오버라이드하지 않았다면 그보다 상위 클래스에 정의된 동일 메소드를 호출하죠. 이 메소드를 커스텀 클래스에서 오버라이드한 다음, 여기에다 값을 전달하는 코드를 넣으면 우리가 원하는 대로 값을 전달할 수 있습니다.</p>
<p><br></p>
<p>여기서 다음 문제입니다. 값을 전달할 뷰 컨트롤러의 인스턴스 정보는 어떻게 얻어올 수 있을까요? 세그웨이를 다룰 때에는 이동할 대상 뷰 컨트롤러의 인스턴스를 우리가 직접 생성해서는 안됩니다. 세그웨이의 목적지로 연결된 뷰 컨트롤러의 인스턴스는 세그웨이에 의해 자동으로 생성되기 때문에, 세그웨이 객체를 통해 생성된 뷰 컨트롤러 인스턴스 참조를 읽어와야 합니다. 이 정보는 prepare(for:sender:) 메소드의 첫 번째 인자값인, segue 매개변수를 통해 얻을 수 있습니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> rating: <span class="type">UITextField!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">(<span class="keyword">for</span> segue: UIStoryboardSegue, sender: <span class="keyword">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 목적지 뷰 컨트롤러 인스턴스 읽어오기</span></span><br><span class="line">        <span class="keyword">let</span> dest = segue.destination</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> rvc = dest <span class="keyword">as</span>? <span class="type">ListViewController</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 값 전달</span></span><br><span class="line">        rvc.paramRating = <span class="keyword">self</span>.rating.text! <span class="comment">// 평점</span></span><br><span class="line">        </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>메소드 매개변수 segue 속성 destination을 이용하여 목적지 뷰 컨트롤러의 인스턴스 참조를 가져옵니다.</li>
<li>인스턴스의 타입을 UIViewController에서 ListViewController 타입으로 캐스팅합니다. 실패하면 메소드를 종료합니다.</li>
<li>캐스팅된 인스턴스 상수 rvc를 이용하여 값을 전달합니다.</li>
</ol>
<p><br></p>
<h4 id="네트워크-객체를-통한-데이터-요청-기능-구현"><a href="#네트워크-객체를-통한-데이터-요청-기능-구현" class="headerlink" title="네트워크 객체를 통한 데이터 요청 기능 구현"></a>네트워크 객체를 통한 데이터 요청 기능 구현</h4><p>본격적으로 API를 호출하고 응답 데이터를 받아 화면에 표시해봅시다. 우선 네트워크를 통해 주어진 API를 호출하고 데이터를 받아오는 과정을 처리하겠습니다. 가장 먼저 처리해야 할 것은 ListViewController.swift 파일을 열고, viewDidLoad() 메소드 내부에 REST API를 호출하는 코드를 작성하는 일입니다. 스위프트나 파운데이션 프레임워크에는 REST API 호출을 위한 전용 객체가 따로 준비되어 있지 않지만, REST 방식의 구현은 일반 웹 페이지를 호출할 때와 거의 동일한 코드로 구현이 가능하므로 단순히 웹 페이지를 호출하는 코드를 작성한다고 생각하면 구현하기 쉽습니다.</p>
<p><br></p>
<p>스위프트에서 웹 페이지를 호출할 때에는 POST 방식과 GET 방식에 따라 각각 작성해야 하는 소스 코드가 다릅니다. 서로 다른 객체를 사용해야 하죠. 특히 POST 방식으로 HTTP 요청을 전송하기 위해 작성해냐 하는 코드는 다소 길고 복잡하지만, 다행이 우리가 사용할 API는 GET 방식으로 호출하면 되기 때문에 비교적 간단하게 작성할 수 있습니다. 스위프트에서 GET 방식으로 REST API를 호출하여 데이터를 읽어오는 방법은 다음과 같습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="type">Data</span>(contentsOf: <span class="type">URL</span>타입의 객체)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>Data는 파운데이션 프레임워크에서 제공하는 클래스입니다. 다양한 종류의 데이터를 변환 과정 없이 저장하기 위해 사용하는 객체는 텍스트 기반의 데이터뿐만 아니라 이미지나 동영상과 같은 바이너리 데이터도 담을 수 있어 여러 가지 종류의 데이터를 처리하는 데에 탁월한 효율성을 자랑합니다.</p>
<p><br></p>
<p>이 객체는 동일한 기능을 제공하는 NSData 객체를 원본으로 하여 스위프트 3 버전부터 새롭게 정의되었습니다. 실제로 Data 클래스의 레퍼런스를 보면 내부적으로는 NSData 객체를 참조하고 있는 것이 확인됩니다. 이같은 구조적 특성 때문에 Data 객체는 NSData 객체가 가지고 있는 기능 대부분을 지원할뿐만 아니라 NSData 객체와 서로 타입 캐스팅도 가능합니다. NSData로 만들어진 객체를 필요에 따라 Data 타입으로 바꾸어 쓰거나 그 반대의 경우가 모두 가능하다는 뜻입니다. 이들은 상위/하위 관계가 아니기 때문에 캐스팅 시 옵셔널 연산자를 붙이지 않아도 됩니다. 이같은 특성을 지닌 Data 객체에서 제공되는 Data(ContentsOf:) 초기화 구문은 복잡한 과정 없이도 손쉽게 GET  방식으로 RESTful 서비스를 호출하고 응답을 받아올 수 있도록 지원합니다. 물론 이 과정에서 잘못된 URL이 입력되었거나 서버에 문제가 있는 등의 이유로 응답을 받지 못하는 경우도 존재하는데, 이때에는 Data 객체에 nil 값이 담기기도 합니다. 따라서 Data(contentsOf:)를 통해 생성되는 인스턴스는 항상 옵셔널 타입입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rating 값을 받을 변수</span></span><br><span class="line">    <span class="keyword">var</span> paramRating: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 영화 API 호출을 위한 URI를 생성</span></span><br><span class="line">        <span class="keyword">let</span> url = <span class="string">"https://yts.mx/api/v2/list_movies.json?limit=10&amp;minimum_rating="</span> + paramRating</span><br><span class="line">        <span class="keyword">let</span> apiURI: <span class="type">URL!</span> = <span class="type">URL</span>(string: url)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. REST API 호출</span></span><br><span class="line">        <span class="keyword">let</span> apidata = <span class="keyword">try</span>! <span class="type">Data</span>(contentsOf: apiURI)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 데이터 전송 결과를 로그로 출력 (확인용)</span></span><br><span class="line">        <span class="keyword">let</span> log = <span class="type">NSString</span>(data: apidata, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8.rawValue) ?? <span class="string">""</span></span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"API Result = \( log )"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="영화-API-호출을-위한-URI-생성"><a href="#영화-API-호출을-위한-URI-생성" class="headerlink" title="영화 API 호출을 위한 URI 생성"></a>영화 API 호출을 위한 URI 생성</h5><p>REST API 호출은 Data(contentsOf:)이 담당하지만, 호출에 필요한 네트워크 주소를 URL 객체 타입으로 넣어주어야 합니다. URL은 파운데이션 프레임워크에 정의된 객체로, NSURL 클래스를 바탕으로 하여 스위프트에 적합하도록 구현된 객체입니다. URL 클래스는 문자열 형태의 네트워크 주소를 인자값으로 입력받아 파운데이션 프레임워크에서 사용하는 형식의 주소 객체를 생성합니다. 예제에서 문자열로 사용하고 있는 주소는 영화 목록 API를 호출하기 위한 Request URI 입니다. 이렇게 생성한 URL 객체는 다음 행의 Data 클래스 초기화 과정에 인자값으로 전달하기 위해 apiURL라는 이름의 상수에 대입되는데, 여기까지가 1번 부분에 작성된 내용입니다.</p>
<p><br></p>
<h5 id="REST-API-호출"><a href="#REST-API-호출" class="headerlink" title="REST API 호출"></a>REST API 호출</h5><p>두 번째 부분에서는 URI 객체가 저장된 apiURI 상수를 인자값으로 사용하여 REST API를 호출하고 있습니다. 내부적으로는 입력받은 URL 객체를 이용하여 네트워크 통신을 하고, 이 결과로 응답받은 데이터를 Data 객체에 저장한 다음 이 객체를 필요한 순간에 사용하기 위해 apidata 상수에 저장하는 거죠. 이렇게 apidata에 저장된 Data 객체는 이후 용도에 맞는 다른 객체로 다시 변환하여 사용합니다.</p>
<p><br><br></p>
<h4 id="전달받은-데이터를-파싱하여-화면에-출력"><a href="#전달받은-데이터를-파싱하여-화면에-출력" class="headerlink" title="전달받은 데이터를 파싱하여 화면에 출력"></a>전달받은 데이터를 파싱하여 화면에 출력</h4><p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ListViewController.swift</span></span><br><span class="line"><span class="comment">//  Prography</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 조성지 on 2020/03/01.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 조성지. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 테이블 뷰를 구성할 리스트 데이터</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> list: [<span class="type">MovieVO</span>] = &#123;</span><br><span class="line">        <span class="keyword">var</span> datalist = [<span class="type">MovieVO</span>]()</span><br><span class="line">        <span class="keyword">return</span> datalist</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rating 값을 받을 변수</span></span><br><span class="line">    <span class="keyword">var</span> paramRating: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 영화 API 호출을 위한 URI를 생성</span></span><br><span class="line">        <span class="keyword">let</span> url = <span class="string">"https://yts.mx/api/v2/list_movies.json?limit=10&amp;minimum_rating="</span> + paramRating</span><br><span class="line">        <span class="keyword">let</span> apiURI: <span class="type">URL!</span> = <span class="type">URL</span>(string: url)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. REST API 호출</span></span><br><span class="line">        <span class="keyword">let</span> apidata = <span class="keyword">try</span>! <span class="type">Data</span>(contentsOf: apiURI)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 데이터 전송 결과를 로그로 출력 (확인용)</span></span><br><span class="line"><span class="comment">//        let log = NSString(data: apidata, encoding: String.Encoding.utf8.rawValue) ?? ""</span></span><br><span class="line"><span class="comment">//        NSLog("API Result = \( log )")</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. JSON 객체를 파싱하여 NSDictionary 객체로 받음</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> apiDictionary = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject(with: apidata, options: []) <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 데이터 구조에 따라 차례대로 캐스팅하며 읽어온다.</span></span><br><span class="line">            <span class="keyword">let</span> data = apiDictionary[<span class="string">"data"</span>] <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line">            <span class="keyword">let</span> movies = data[<span class="string">"movies"</span>] <span class="keyword">as</span>! <span class="type">NSArray</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 6. Iterator 처리를 하면서 API 데이터를 MovieVO 객체에 저장한다.</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> movies&#123;</span><br><span class="line">                <span class="comment">// 순회 상수를 NSDictionary 타입으로 캐스팅</span></span><br><span class="line">                <span class="keyword">let</span> r = row <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 테이블 뷰 리스트를 구성할 때 데이터 형식</span></span><br><span class="line">                <span class="keyword">let</span> mvo = <span class="type">MovieVO</span>()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// movie 배열의 각 데이터를 mvo 상수의 속성에 대입</span></span><br><span class="line">                mvo.title = r[<span class="string">"title"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">                mvo.rating = r[<span class="string">"rating"</span>] <span class="keyword">as</span>? <span class="type">Double</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// list 배열에 추가</span></span><br><span class="line">                <span class="keyword">self</span>.list.append(mvo)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="comment">// 주어진 행에 맞는 데이터 소스를 읽어온다.</span></span><br><span class="line">        <span class="keyword">let</span> row = <span class="keyword">self</span>.list[indexPath.row]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// as! UITableViewCell</span></span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"ListCell"</span>)!</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 데이터 소스에 저장된 값을 각 아울렛 변수에 할당</span></span><br><span class="line">        cell.textLabel?.text = row.title</span><br><span class="line">        cell.detailTextLabel?.text = <span class="string">"\(row.rating!)"</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 셀 객체를 반환</span></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"선택된 행은 \(indexPath.row)번째 행입니다"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // MARK: - Navigation</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // In a storyboard-based application, you will often want to do a little preparation before navigation</span></span><br><span class="line"><span class="comment">    override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;</span></span><br><span class="line"><span class="comment">        // Get the new view controller using segue.destination.</span></span><br><span class="line"><span class="comment">        // Pass the selected object to the new view controller.</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="JSON-객체를-파싱하여-NSDictionary-객체로-변환"><a href="#JSON-객체를-파싱하여-NSDictionary-객체로-변환" class="headerlink" title="JSON 객체를 파싱하여 NSDictionary 객체로 변환"></a>JSON 객체를 파싱하여 NSDictionary 객체로 변환</h5><p>네트워크를 통해 호출한 API 데이터는 apidata 상수에 저장되어 있습니다. 하지만 이 apidata 상수는 Data 타입이어서 우리가 바로 꺼내 쓰기는 어렵습니다. 로그를 출력하기 위해 NSString 타입의 문자열로 변환하였듯이, 테이블을 구성하는 데이터로 사용하려면 NSDictionary 객체로 변환해야 합니다. NSDictionary는 키-값으로 된 데이터 구조를 저장하므로 JSONObject 포맷의 데이터와 호환됩니다. 만약 데이터가 리스트 형태로 전달되었다면 JSONArray 포맷과 호환되는 NSArray 객체를 사용해야 합니다.</p>
<p><br></p>
<p>데이터를 파싱할 때는 파운데이션 프레임워크에서 제공하는 JSONSerialization 객체의 jsonObject() 메소드를 사용하는 것이 좋습니다. 이 메소드는 두 개의 인자값을 입력받는데, 첫 번째는 파싱할 데이터이며 두 번째는 파싱 옵션입니다. 파싱할 데이터에는 apidata 상수를, 파싱 옵션에 넣을 것은 아무것도 없으므로 빈 배열을 넣어주면 됩니다.</p>
<p><br></p>
<p>jsonObject() 메소드는 파싱 과정에서 오류가 발생하면 이를 예외로 던지도록 설계되어 있습니다. 이 때문에 메소드를 사용하기 위해서는 do ~ try ~ catch 구문으로 감싸주어야 합니다. 진행 도중에 오류가 발생하면 진행하던 과정을 멈추고 catch 블록 쪽으로 오류와 함께 실행 흐름이 전달되죠. jsonObject() 메소드의 실행 결과는 입력된 데이터에 따라 NSDictionary 혹은 NSArray 형태로 나올 수 있습니다. 양쪽을 모두 지원하기 위해 이 메소드는 옵셔널 Any 타입으로 정의된 결과값을 반환하므로 최종적으로는 이 결과값을 원하는 객체로 캐스팅해서 받아야 합니다.</p>
<p><br></p>
<p>여기서는 실행 결과를 NSDictionary로 캐스팅하여 apiDictionary 변수에 저장하고 있습니다. 캐스팅을 위한 as 키워드에 옵셔널 연산자가 붙은 것을 볼 수 있는데, as! 는 옵셔널 타입의 객체를 캐스팅할 때 강제로 해제하여 캐스팅하라는 의미입니다. 물론 해제하지 않고 옵셔널 타입을 유지한 채 하려면 as?를 사용하면 됩니다.</p>
<p><br></p>
<h5 id="데이터-구조에-따라-차례대로-캐스팅하며-읽어옴"><a href="#데이터-구조에-따라-차례대로-캐스팅하며-읽어옴" class="headerlink" title="데이터 구조에 따라 차례대로 캐스팅하며 읽어옴"></a>데이터 구조에 따라 차례대로 캐스팅하며 읽어옴</h5><p>apiDictionary 변수에 저장된 JSON 데이터를 분해하여 원하는 값을 단계적으로 찾아가는 부분입니다. 최상위에 data라는 노드에서 그 하위 노드의 movies에 접근하여 노드 하위에 반복되면서 정의된 영화 아이디와 제목, 그리고 평점을 함께 반복하는 식입니다. 이 구조에 따라, 우리가 원하는 영화 목록 정보에 접근합니다.</p>
<p><br></p>
<h5 id="배열을-순회하면서-영화-정보-데이터를-차례로-MovieVO-객체로-생성한-다음-이를-list-배열에-추가"><a href="#배열을-순회하면서-영화-정보-데이터를-차례로-MovieVO-객체로-생성한-다음-이를-list-배열에-추가" class="headerlink" title="배열을 순회하면서 영화 정보 데이터를 차례로 MovieVO 객체로 생성한 다음, 이를 list 배열에 추가"></a>배열을 순회하면서 영화 정보 데이터를 차례로 MovieVO 객체로 생성한 다음, 이를 list 배열에 추가</h5><p>for ~ in 구문을 이용하여 movies 배열에 저장된 영화 정보를 순회하면서 MovieVO 타입의 객체를 만든 다음, 이를 self.list에 담아주는 과정입니다.</p>
<p><br><br></p>
<p>화면이 정상적으로 출력된 모든 분들에게 축하를!</p>
<p><br><br></p>
<h1 id="ScreenShots"><a href="#ScreenShots" class="headerlink" title="ScreenShots"></a>ScreenShots</h1><p><br></p>
<p><img src="/image/prog1.png" alt="prog1"></p>
<p><br></p>
<p><img src="/image/prog2.png" alt="prog2"></p>
<p><br></p>
<p><img src="/image/prog3.png" alt="prog3"></p>
<p><br></p>
<p><img src="/image/prog4.png" alt="prog4"></p>
<p><br></p>
<p><img src="/image/prog5.png" alt="prog5"></p>
<p><br></p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/3/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo" target="_blank" rel="noopener">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/04/09/beakjoon-1-7/">[BaekJoon] A/B</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/04/07/fnlp-%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC-4/">[FNLP] 밑바닥부터 시작하는 자연어처리 (</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/04/07/hci-paper-summary/">[HCI]</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/04/04/SEM-%EC%B8%A1%EC%A0%95%EB%AA%A8%ED%98%95/">[SEM] 측정모형</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/algorithm/">algorithm</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/algorithm/selection-sort/">selection sort</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/edwith/">edwith</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/vuejs/">vuejs</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

</body>

</html>