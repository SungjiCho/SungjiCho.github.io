<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="Sunny Cho">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="QuantPsy"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="QuantPsy"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - QuantPsy</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">QuantPsy</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/09/fnlp-%EC%B2%9C%EC%9E%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC-1/">
                [nlp] 천장부터 시작하는 자연어처리 (1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-09</span>
            
            
            
                <span class="category">
                    <a href="/categories/natural-language-processing/">Natural Language Processing</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="트랜스포머-네트워크"><a href="#트랜스포머-네트워크" class="headerlink" title="트랜스포머 네트워크"></a>트랜스포머 네트워크</h1><p><br></p>
<h5 id="본-포스팅은-“한국어-임베딩”-책을-바탕으로-합니다"><a href="#본-포스팅은-“한국어-임베딩”-책을-바탕으로-합니다" class="headerlink" title="본 포스팅은 “한국어 임베딩” 책을 바탕으로 합니다."></a>본 포스팅은 “한국어 임베딩” 책을 바탕으로 합니다.</h5><p><br><hr><br></p>
<p>트랜스포머(Vaswani et al., 2017) 네트워크는 구글 연구 팀이 NIPS에 공개한 딥러닝 아키텍처이다. 뛰어난 성능으로 주목받았다. 이후 발표된 GPT, BERT 등 기법은 트랜스포머 블록을 기본 모델로 쓰고 있다. 이제부터 트랜스포머 모델 가운데 기본 블록의 산 과정과 그 작동 원리를 살펴보도록 한다. 하단 멀티헤드 어텐션과 상단 피드포워 네트워크를 설명한다.</p>
<p><br></p>
<h4 id="Scaled-Dot-Product-Attention"><a href="#Scaled-Dot-Product-Attention" class="headerlink" title="Scaled Dot-Product Attention"></a>Scaled Dot-Product Attention</h4><p>트랜스포머 블록의 주요 구성 요소 가운데 하나가 바로 Scaled Dot-Product Attention이다. 여기서 입력은 기본적으로 행렬 형태를 가지며 그 크기는 입력 문장의 단어 수 <em> 입력 임베딩의 차원 수다. 예컨대 “드디어, 금요일, 이다”라는 문장이 Scaled Dot-Product Attention 입력으로 들어가고 그 히든 차원 수가 768차원이라면 이 레이어의 력 행렬의 크기는 3 </em> 768이 된다.</p>
<p><br></p>
<p>트랜스포머의 Scaled Dot-Product Attention 메터니즘은 쿼리, 키, 값 세 가지 사이의 다이나믹스가 핵심이다. 입력 행렬과 쿼리, 키, 값에 해당하는 행렬을 각각 곱해 계한다. 이후 쿼리와 키가 얼마나 관련을 맺고 있는지를 나타내기 위해 입력 행렬과 쿼리 행렬을 곱한 결과와 입력 행렬과 키 행렬을 곱한 결과를 내적하여 키 벡터의 차원 수의 제곱근을 나누어준 뒤 소프트맥스를 취한다. 마지막으로 이 확률 값을 가중치 삼아 값에 해당하는 벡터들을 가중합한다.</p>
<p><br></p>
<p>Scaled Dot-Product Attention은 어떻게 단어들 사이의 의미적, 문법적 관계를 포착해낼 수 있는 걸까. 그 비결 중 일부는 기법 이름 속에 숨어 있다. 첫째는 dot-product, 둘째는 attention, 셋째는 scale이다. 선형대수학에서 dot-product는 내적을 달리 이르는 말이다. 내적은 벡터 간 유사도 측정 기법의 일종인 코사인 유사도와 깊은 관련 가진다. 두 벡터를 내적하고 이들 길이의 곱으로 나눠준 값이 바로 코사인 유사도다. 두 벡터가 모두 길이 1인 단위 벡터라면 두 벡터의 내적 자체가 코사인 유사도이며 그 값이 크면 클수록 코사인 유사도는 높아진다. 코사인 유사도는 두 벡터 사이의 각가 0도로 완전히 같을 경우 최대값 1, 180도로 완전히 반대인 경우 최소값 -1이 된다.</p>
<p><br></p>
<p>어떤 쿼리와 키가 특정 태스크 수행에 중요한 역할을 하고 있다면 트랜스포머 블록은 이들 사이의 내적 값을 키우는 방식으로 학습한다. 내적 값이 커지면 해당 쿼리와 키 벡터 공간상 가까이에 있을 가능성이 높아진다. 셀프 어텐션은 같은 문장 내 모든 어 쌍 사이의 의미적, 문법적 관계를 포착해낸다는 뜻이다. Scaled Dot-Production Attention은 소프트맥스 행렬과 값 행렬을 내적하는 것으로 마무리된다. 이는 소프트맥스 확률을 가중치 삼아 각 값 벡터들을 가중합하는 것과 같다. 따라서 Scaled Dot-Production Attention 결과 새롭게 만드어진 벡터는 해당 문장 내 단어 쌍 관계가 모두 축된 결과다.</p>
<p><br></p>
<p>셀프 어텐션은 기존 RNN, CNN 보다 장점이 많다. CNN의 경우 사용자가 정한 특정 윈도우 내의 로컬 문맥만 살핀다. 예컨대 문장 길이가 꽤 길고 맨 처음 단어와 마지막 단 사이의 연관성 파악이 태스크 수행에 중요한 데이터라면 CNN으로 이를 해결하기는 지 않다. 한편 RNN은 시퀀스 길이가 길어질수록 그래디언트 문제가 발생할 염려가 있다. 다시 말해 시퀀스가 길면 처음 입력받았던 단어는 RNN 모델이 잊어버릴 가능성이 높다는 이야기다. 하지만 트랜스포머와 같은 셀프 어텐션 기법은 문장 내 모든 단어쌍 사이의 관계를 늘 전체적으로 파악할 수 있다. 이 덕분에 트랜스포머는 컨볼루션 필나 RNN 셀 없이도 자연어 처리 태스크를 성공적으로 수행할 수 있었다.</p>
<p><br></p>
<p>또 다른 중요 요소는 scale이다. Scaled Dot-Product Attention에서는 쿼리와 키 행렬을 내적한 뒤 키 행렬 차원 수의 제곱근을 나눠줘 스케일을 하고 있다. Vaswani et al. (2017)에 따르면 이 경우에 쿼리-키 내적 행렬의 분산을 줄이게 돼 소프트맥스의 그래디언트가 지나치게 작아지는 것을 방지할 수 있다.</p>
<p><br><br></p>
<h4 id="멀티헤드-어텐션"><a href="#멀티헤드-어텐션" class="headerlink" title="멀티헤드 어텐션"></a>멀티헤드 어텐션</h4><p>트랜스포머 블록에서 멀티헤드 어텐션은 Scaled Dot-Product Attention을 여러 번 시하는 것을 가리킨다. 동일한 문장을 여러 명의 독자가 동시에 분석해 최선의 결과를 내려고 하는 것에 비유할 수 있겠다. 멀티헤드 어텐션의 계산 과정은 미리 만들어놓은 쿼리, 키, 값에 Scaled Dot-Production을 h번 수행한다. 이후 각 헤드의 결과 행렬을 이어 붙여 긴 행렬을 만들어 사용한다.</p>
<p><br><br></p>
<h4 id="Position-wise-Feedforward-Networks"><a href="#Position-wise-Feedforward-Networks" class="headerlink" title="Position-wise Feedforward Networks"></a>Position-wise Feedforward Networks</h4><p>멀티헤드 어텐션 레이어의 입력 행렬과 출력 행렬의 크기는 입력 단어 수 * 히든 벡터 차원 수로 동일하다. Position-wise Feedforward Networks 레이어에서는 멀티헤드 어텐션 레이어의 출력 행렬을 행 벡터 단위로, 다시 말해 단어 벡터 각각에 관해 수식을 적용한다. 멀티헤드 어텐션 레이어의 출력 행렬 가운데 하나의 단어 벡터에 관해 두 번의 선형변환을 수행하며 그 사이에 ReLU를 적용한다.</p>
<p><br><br></p>
<h4 id="트랜스포머의-학습-전략"><a href="#트랜스포머의-학습-전략" class="headerlink" title="트랜스포머의 학습 전략"></a>트랜스포머의 학습 전략</h4><p>트랜스포머의 학습 전략은 웜업(warm up)이다. 사용자가 정한 스텝 수에 이르기까지 습률을 올렸다가 스텝 수를 만족하면 조금씩 떨어뜨리는 방식이다. 대규모 데이터,  모델 학습에 적합하다. 이 전략은 BERT 등 이후 제안된 모델에도 널리 쓰이고 있다. 이밖에 레이어 정규화 등도 트랜스포머의 안정적인 학습에 기여하고 있는 것으로 보다.</p>
<p><br><br></p>
<h4 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h4><p>BERT(Bidirectional Encoder Representations from Transformer)는 구글에서 공개한 모델이다. 성능이 뛰어나 널리 쓰이고 있다. BERT의 성공 비결은 그 퍼포먼스가 검증된 트랜스포머 블록을 썼을뿐더러 모델의 속성이 양방향을 지향한다는 점에 있다. GPT는 단어 시퀀스를 왼쪽에서 오른쪽으로 한 방향으로만 모든 아키텍처이다. ELMo는 Bi-LSTM 레이어의 상단은 양방향이지만 중간 레이어 역시 한 방향인 모델이다. 반면 BERT의 경우 모든 레이어에서 양방향 성질을 잃지 않고 있다.</p>
<p><br></p>
<p>BERT와 GPT 모델은 모두 트랜스포머 블록을 사용하고 있다. 그렇다면 GPT는 왜 단어들을 양방향으로 보지 못하는 것일까? 그 이유는 GPT가 언어 모델이기 때문이다. GPT는 주어진 단어 시퀀스를 가지고 그다음 단어를 예측하는 과정에서 학습한다. 이 경우 현재 입력 단어 이후의 단어를 모델에게 알려주는 것은 반칙이다. 언어 모델은 주어진 시퀀스를 가지고 다음 단어를 맞춰야 하는데, 맞춰야할 정답을 미리 알려줄 수는 없기 때문이다. Devline et al. (2018)은 이 문제를 극복하기 위해 마스크 언어 모델(masked language model)을 제안했다. 주어진 시퀀스 다음 단어를 맞추는 것에서 벗어나, 일단 문장 전체를 모델에게 알려주고, 빈칸(MASK)에 해당하는 단어가 어떤 단어일지 예측하는 과정에서 학습을 해보자는 아이디어다. 마스크 언어 모델 태스크에서는 모델에 문장 전체를 다 주어도 반칙이 될 수 없다. BERT 모델은 빈칸을 채워야 하기 때문이다.</p>
<p><br></p>
<p>GPT는 Scaled Dot-Product Attention을 하는 과정에서 예측해야 할 단어를 보지 않기 위해 소프트맥스 스코어 행렬의 일부 값을 0으로 만든다. 예컨대 입력 문장이 꿈, 보다, 해몽이고 이번에 예측해야 할 단어가 보다라면 GPT는 이전 단어인 꿈만 참고할 수 있다. 해몽이라는 단어를 맞춰야 할 순서라면 GPT는 꿈, 보다만을 참고해야 한다. 반면 BERT는 빈칸만 맞추면 되기 때문에 그림처럼 문장 내 단어 쌍 사이의 관계를 모두 볼 수 있다.</p>
<p><br></p>
<p>Devlin et al. (2018)은 BERT 임베딩을 각종 다운스트림 태스크에 적용해 실험한 결과 BERT의 임베딩 품질이 GPT보다 좋음을 입증했다. 그만큼 모델이 양방향 전후 문맥을 모두 보게 하는 것이 중요하다는 이야기다. BERT가 양방향 모델이 될 수 있었던 배경은 모델이 순방향, 역방향 문맥을 모두 볼 수 있도록 하는 학습 태스크 덕분이다. BERT의 프리트레인 태스크에는 크게 마스크 언어 모델, 다음 문장인지 여부 맞추기 두 가지가 있다. 먼저 마스크 언어 모델 태스크 수행을 위한 학습 데이터는 다음과 같이 만든다.</p>
<p><br></p>
<ul>
<li>학습 데이터 한 문장 토큰의 15%를 마스킹한다.</li>
<li>마스킹 대상 토큰 가운데 80%는 실제 빈칸으로 만들고, 모델은 그 빈칸을 채운다.</li>
<li>마스킹 대상 토큰 가운데 10%는 랜덤으로 다른 토큰으로 대체하고, 모델은 해당 위치의 정답 언어가 무엇일지 맞추도록 한다.</li>
<li>마스킹 대상 토큰 가운데 10%는 토큰 그대로 두고, 모델은 해당 위치의 정답 단어가 무엇일지 맞추도록 한다.</li>
</ul>
<p><br></p>
<p>이같이 학습 데이터를 만들게 되면 우리는 다음을 기대할 수 있다.</p>
<ul>
<li>빈칸을 채워야 하기 때문에 문장 내 어느 자리에 어떤 단어를 쓰는 게 자연스러운지 앞뒤 문맥을 읽어낼 수 있게 된다.</li>
<li>주어진 문장을 비교해 보면서 문장이 의미/문법상 비문인지 아닌지 가려낼 수 있다.</li>
<li>모델은 어떤 단어가 마스킹될지 전혀 모르기 때문에 문장 내 모든 단어 사이의 의미적, 문법적 관계를 세밀히 살피게 된다.</li>
</ul>
<p><br></p>
<p>다음 문장인지 여부를 맞추기 위한 학습 데이터는 다음과 같이 만든다.</p>
<ul>
<li>모든 학습 데이터는 1건당 문장 두 개로 구성된다.</li>
<li>이 가운데 절반은 동일한 문서에서 실제 이어지는 문장을 두 개 뽑고, 그 정답으로 참을 부여한다.</li>
<li>나머지 절반은 서로 다른 문서에서 문장 하나씩 뽑고, 그 정답으로 거짓을 부여한다.</li>
<li>max_num_tokens를 정의한다.</li>
<li>이전에 뽑은 문장 두 개의 단어 총 수가 max_num_token을 넘지 못할 때까지 두 문장 중 단어 수가 많은 쪽을 50%의 확률로 무장 맨 앞 또는 맨 뒤 단어 하나씩 제거한다.</li>
</ul>
<p><br></p>
<p>이같이 학습 데이터를 만들게 되면 우리는 다음을 기대할 수 있다.</p>
<ul>
<li>모델은 주어진 문장이 이어진 문장인지 아닌지 반복 학습한다. 따라서 문장 간 의미 관계를 이해할 수 있다.</li>
<li>일부 문장 성분이 없어도 전체 의미를 이해하는 데 큰 무리가 없다. NSP 태스크가 너무 쉬워지는 것을 방지하기 위해 문장 맨 앞 또는 맨 뒤쪽 단어 일부를 삭제했기 때문이다.</li>
<li>학습 데이터에 짧은 문장이 포함돼 있어도 성능이 크게 떨어지지 않는다.</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/09/nlp-%EC%B2%9C%EC%9E%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC-1/">
                [nlp] 천장부터 시작하는 자연어처리 (1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-09</span>
            
            
            
                <span class="category">
                    <a href="/categories/nlp/">NLP</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="트랜스포머-네트워크"><a href="#트랜스포머-네트워크" class="headerlink" title="트랜스포머 네트워크"></a>트랜스포머 네트워크</h1><p><br></p>
<h5 id="본-포스팅은-“한국어-임베딩”-책을-바탕으로-합니다"><a href="#본-포스팅은-“한국어-임베딩”-책을-바탕으로-합니다" class="headerlink" title="본 포스팅은 “한국어 임베딩” 책을 바탕으로 합니다."></a>본 포스팅은 “한국어 임베딩” 책을 바탕으로 합니다.</h5><p><br><hr><br></p>
<p>트랜스포머(Vaswani et al., 2017) 네트워크는 구글 연구 팀이 NIPS에 공개한 딥러닝 아키텍처이다. 뛰어난 성능으로 주목받았다. 이후 발표된 GPT, BERT 등 기법은 트랜스포머 블록을 기본 모델로 쓰고 있다. 이제부터 트랜스포머 모델 가운데 기본 블록의 산 과정과 그 작동 원리를 살펴보도록 한다. 하단 멀티헤드 어텐션과 상단 피드포워 네트워크를 설명한다.</p>
<p><br></p>
<h4 id="Scaled-Dot-Product-Attention"><a href="#Scaled-Dot-Product-Attention" class="headerlink" title="Scaled Dot-Product Attention"></a>Scaled Dot-Product Attention</h4><p>트랜스포머 블록의 주요 구성 요소 가운데 하나가 바로 Scaled Dot-Product Attention이다. 여기서 입력은 기본적으로 행렬 형태를 가지며 그 크기는 입력 문장의 단어 수 <em> 입력 임베딩의 차원 수다. 예컨대 “드디어, 금요일, 이다”라는 문장이 Scaled Dot-Product Attention 입력으로 들어가고 그 히든 차원 수가 768차원이라면 이 레이어의 력 행렬의 크기는 3 </em> 768이 된다.</p>
<p><br></p>
<p>트랜스포머의 Scaled Dot-Product Attention 메터니즘은 쿼리, 키, 값 세 가지 사이의 다이나믹스가 핵심이다. 입력 행렬과 쿼리, 키, 값에 해당하는 행렬을 각각 곱해 계한다. 이후 쿼리와 키가 얼마나 관련을 맺고 있는지를 나타내기 위해 입력 행렬과 쿼리 행렬을 곱한 결과와 입력 행렬과 키 행렬을 곱한 결과를 내적하여 키 벡터의 차원 수의 제곱근을 나누어준 뒤 소프트맥스를 취한다. 마지막으로 이 확률 값을 가중치 삼아 값에 해당하는 벡터들을 가중합한다.</p>
<p><br></p>
<p>Scaled Dot-Product Attention은 어떻게 단어들 사이의 의미적, 문법적 관계를 포착해낼 수 있는 걸까. 그 비결 중 일부는 기법 이름 속에 숨어 있다. 첫째는 dot-product, 둘째는 attention, 셋째는 scale이다. 선형대수학에서 dot-product는 내적을 달리 이르는 말이다. 내적은 벡터 간 유사도 측정 기법의 일종인 코사인 유사도와 깊은 관련 가진다. 두 벡터를 내적하고 이들 길이의 곱으로 나눠준 값이 바로 코사인 유사도다. 두 벡터가 모두 길이 1인 단위 벡터라면 두 벡터의 내적 자체가 코사인 유사도이며 그 값이 크면 클수록 코사인 유사도는 높아진다. 코사인 유사도는 두 벡터 사이의 각가 0도로 완전히 같을 경우 최대값 1, 180도로 완전히 반대인 경우 최소값 -1이 된다.</p>
<p><br></p>
<p>어떤 쿼리와 키가 특정 태스크 수행에 중요한 역할을 하고 있다면 트랜스포머 블록은 이들 사이의 내적 값을 키우는 방식으로 학습한다. 내적 값이 커지면 해당 쿼리와 키 벡터 공간상 가까이에 있을 가능성이 높아진다. 셀프 어텐션은 같은 문장 내 모든 어 쌍 사이의 의미적, 문법적 관계를 포착해낸다는 뜻이다. Scaled Dot-Production Attention은 소프트맥스 행렬과 값 행렬을 내적하는 것으로 마무리된다. 이는 소프트맥스 확률을 가중치 삼아 각 값 벡터들을 가중합하는 것과 같다. 따라서 Scaled Dot-Production Attention 결과 새롭게 만드어진 벡터는 해당 문장 내 단어 쌍 관계가 모두 축된 결과다.</p>
<p><br></p>
<p>셀프 어텐션은 기존 RNN, CNN 보다 장점이 많다. CNN의 경우 사용자가 정한 특정 윈도우 내의 로컬 문맥만 살핀다. 예컨대 문장 길이가 꽤 길고 맨 처음 단어와 마지막 단 사이의 연관성 파악이 태스크 수행에 중요한 데이터라면 CNN으로 이를 해결하기는 지 않다. 한편 RNN은 시퀀스 길이가 길어질수록 그래디언트 문제가 발생할 염려가 있다. 다시 말해 시퀀스가 길면 처음 입력받았던 단어는 RNN 모델이 잊어버릴 가능성이 높다는 이야기다. 하지만 트랜스포머와 같은 셀프 어텐션 기법은 문장 내 모든 단어쌍 사이의 관계를 늘 전체적으로 파악할 수 있다. 이 덕분에 트랜스포머는 컨볼루션 필나 RNN 셀 없이도 자연어 처리 태스크를 성공적으로 수행할 수 있었다.</p>
<p><br></p>
<p>또 다른 중요 요소는 scale이다. Scaled Dot-Product Attention에서는 쿼리와 키 행렬을 내적한 뒤 키 행렬 차원 수의 제곱근을 나눠줘 스케일을 하고 있다. Vaswani et al. (2017)에 따르면 이 경우에 쿼리-키 내적 행렬의 분산을 줄이게 돼 소프트맥스의 그래디언트가 지나치게 작아지는 것을 방지할 수 있다.</p>
<p><br><br></p>
<h4 id="멀티헤드-어텐션"><a href="#멀티헤드-어텐션" class="headerlink" title="멀티헤드 어텐션"></a>멀티헤드 어텐션</h4><p>트랜스포머 블록에서 멀티헤드 어텐션은 Scaled Dot-Product Attention을 여러 번 시하는 것을 가리킨다. 동일한 문장을 여러 명의 독자가 동시에 분석해 최선의 결과를 내려고 하는 것에 비유할 수 있겠다. 멀티헤드 어텐션의 계산 과정은 미리 만들어놓은 쿼리, 키, 값에 Scaled Dot-Production을 h번 수행한다. 이후 각 헤드의 결과 행렬을 이어 붙여 긴 행렬을 만들어 사용한다.</p>
<p><br><br></p>
<h4 id="Position-wise-Feedforward-Networks"><a href="#Position-wise-Feedforward-Networks" class="headerlink" title="Position-wise Feedforward Networks"></a>Position-wise Feedforward Networks</h4><p>멀티헤드 어텐션 레이어의 입력 행렬과 출력 행렬의 크기는 입력 단어 수 * 히든 벡터 차원 수로 동일하다. Position-wise Feedforward Networks 레이어에서는 멀티헤드 어텐션 레이어의 출력 행렬을 행 벡터 단위로, 다시 말해 단어 벡터 각각에 관해 수식을 적용한다. 멀티헤드 어텐션 레이어의 출력 행렬 가운데 하나의 단어 벡터에 관해 두 번의 선형변환을 수행하며 그 사이에 ReLU를 적용한다.</p>
<p><br><br></p>
<h4 id="트랜스포머의-학습-전략"><a href="#트랜스포머의-학습-전략" class="headerlink" title="트랜스포머의 학습 전략"></a>트랜스포머의 학습 전략</h4><p>트랜스포머의 학습 전략은 웜업(warm up)이다. 사용자가 정한 스텝 수에 이르기까지 습률을 올렸다가 스텝 수를 만족하면 조금씩 떨어뜨리는 방식이다. 대규모 데이터,  모델 학습에 적합하다. 이 전략은 BERT 등 이후 제안된 모델에도 널리 쓰이고 있다. 이밖에 레이어 정규화 등도 트랜스포머의 안정적인 학습에 기여하고 있는 것으로 보다.</p>
<p><br><br></p>
<h4 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h4><p>BERT(Bidirectional Encoder Representations from Transformer)는 구글에서 공개한 모델이다. 성능이 뛰어나 널리 쓰이고 있다. BERT의 성공 비결은 그 퍼포먼스가 검증된 트랜스포머 블록을 썼을뿐더러 모델의 속성이 양방향을 지향한다는 점에 있다. GPT는 단어 시퀀스를 왼쪽에서 오른쪽으로 한 방향으로만 모든 아키텍처이다. ELMo는 Bi-LSTM 레이어의 상단은 양방향이지만 중간 레이어 역시 한 방향인 모델이다. 반면 BERT의 경우 모든 레이어에서 양방향 성질을 잃지 않고 있다.</p>
<p><br></p>
<p>BERT와 GPT 모델은 모두 트랜스포머 블록을 사용하고 있다. 그렇다면 GPT는 왜 단어들을 양방향으로 보지 못하는 것일까? 그 이유는 GPT가 언어 모델이기 때문이다. GPT는 주어진 단어 시퀀스를 가지고 그다음 단어를 예측하는 과정에서 학습한다. 이 경우 현재 입력 단어 이후의 단어를 모델에게 알려주는 것은 반칙이다. 언어 모델은 주어진 시퀀스를 가지고 다음 단어를 맞춰야 하는데, 맞춰야할 정답을 미리 알려줄 수는 없기 때문이다. Devline et al. (2018)은 이 문제를 극복하기 위해 마스크 언어 모델(masked language model)을 제안했다. 주어진 시퀀스 다음 단어를 맞추는 것에서 벗어나, 일단 문장 전체를 모델에게 알려주고, 빈칸(MASK)에 해당하는 단어가 어떤 단어일지 예측하는 과정에서 학습을 해보자는 아이디어다. 마스크 언어 모델 태스크에서는 모델에 문장 전체를 다 주어도 반칙이 될 수 없다. BERT 모델은 빈칸을 채워야 하기 때문이다.</p>
<p><br></p>
<p>GPT는 Scaled Dot-Product Attention을 하는 과정에서 예측해야 할 단어를 보지 않기 위해 소프트맥스 스코어 행렬의 일부 값을 0으로 만든다. 예컨대 입력 문장이 꿈, 보다, 해몽이고 이번에 예측해야 할 단어가 보다라면 GPT는 이전 단어인 꿈만 참고할 수 있다. 해몽이라는 단어를 맞춰야 할 순서라면 GPT는 꿈, 보다만을 참고해야 한다. 반면 BERT는 빈칸만 맞추면 되기 때문에 그림처럼 문장 내 단어 쌍 사이의 관계를 모두 볼 수 있다.</p>
<p><br></p>
<p>Devlin et al. (2018)은 BERT 임베딩을 각종 다운스트림 태스크에 적용해 실험한 결과 BERT의 임베딩 품질이 GPT보다 좋음을 입증했다. 그만큼 모델이 양방향 전후 문맥을 모두 보게 하는 것이 중요하다는 이야기다. BERT가 양방향 모델이 될 수 있었던 배경은 모델이 순방향, 역방향 문맥을 모두 볼 수 있도록 하는 학습 태스크 덕분이다. BERT의 프리트레인 태스크에는 크게 마스크 언어 모델, 다음 문장인지 여부 맞추기 두 가지가 있다. 먼저 마스크 언어 모델 태스크 수행을 위한 학습 데이터는 다음과 같이 만든다.</p>
<p><br></p>
<ul>
<li>학습 데이터 한 문장 토큰의 15%를 마스킹한다.</li>
<li>마스킹 대상 토큰 가운데 80%는 실제 빈칸으로 만들고, 모델은 그 빈칸을 채운다.</li>
<li>마스킹 대상 토큰 가운데 10%는 랜덤으로 다른 토큰으로 대체하고, 모델은 해당 위치의 정답 언어가 무엇일지 맞추도록 한다.</li>
<li>마스킹 대상 토큰 가운데 10%는 토큰 그대로 두고, 모델은 해당 위치의 정답 단어가 무엇일지 맞추도록 한다.</li>
</ul>
<p><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/01/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%B2%88%EC%99%B8%ED%8E%B8-1/">
                [iOS] 앱 개발 번외편 (1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-01</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="iOS-영화-목록을-받아와-보여주는-영화정보-제공-App-만들기"><a href="#iOS-영화-목록을-받아와-보여주는-영화정보-제공-App-만들기" class="headerlink" title="[iOS] 영화 목록을 받아와 보여주는 영화정보 제공 App 만들기"></a>[iOS] 영화 목록을 받아와 보여주는 영화정보 제공 App 만들기</h1><p><br></p>
<h4 id="오픈-API를-사용하여-앱을-개발하는-과정"><a href="#오픈-API를-사용하여-앱을-개발하는-과정" class="headerlink" title="오픈 API를 사용하여 앱을 개발하는 과정"></a>오픈 API를 사용하여 앱을 개발하는 과정</h4><ul>
<li>1단계: 원하는 정보를 제공하는 웹 서비스와 사용할 API 검색</li>
<li>2단계: 오픈 API 사용을 위한 신청과 인증 키 발급</li>
<li>3단계: 앱 내에서 네트워크를 통해 데이터를 받아오도록 코드 구현</li>
<li>4단계: 전달받은 데이터를 파싱하여 사용</li>
</ul>
<p><br><hr><br></p>
<h4 id="API-기본-정보"><a href="#API-기본-정보" class="headerlink" title="API 기본 정보"></a>API 기본 정보</h4><ul>
<li>Request URI : <a href="https://yts.mx/api/v2/list_movies.json?minimum_rating={평점}&amp;limit={갯수}" target="_blank" rel="noopener">https://yts.mx/api/v2/list_movies.json?minimum_rating={평점}&amp;limit={갯수}</a></li>
</ul>
<p><br></p>
<p>Request URI는 영화 차트 API를 호출하기 위한 네트워크상의 주소입니다. 우리는 다만 이 URL을 그대로 사용하는 것이 아니라 중괄호로 둘러싸인 부분을 적절한 값으로 치환한 다음에 호출해야 합니다. 어떤 값을 대입해야 할지는 뒤에 이어지는 Querystring Parameters 부분을 확인하면 알 수 있습니다. 이 API는 REST 프로토콜 형식을 사용하여 GET 방식으로 호출해야 합니다.</p>
<p><br></p>
<p><img src="/image/ios9.png" alt="ios9"></p>
<p><br></p>
<p>위 URI에 원하는 정보에 맞게 대입하여 경로를 만들어 네트워크 객체에 넣어 호출하면 원하는 영화 목록을 회신받을 수 있습니다. 이 주소는 일반 브라우저에서도 동작하기 때문에, 크롬과 같은 브라우저에서 주소 줄 위에 URI를 입력하면 위와 같은 결과를 볼 수 있습니다.</p>
<p><br></p>
<h4 id="응답-데이터-형식"><a href="#응답-데이터-형식" class="headerlink" title="응답 데이터 형식"></a>응답 데이터 형식</h4><p><br></p>
<p><img src="/image/ios10.png" alt="ios10"></p>
<p><br></p>
<p>URI를 통해 응답받은 영화 목록은 JSON 형태로 이루어져 있습니다. JSON 정렬 사이트 등을 이용하여 미리 데이터를 정렬하는 것이 좋습니다. 위 화면에서 각각의 항목은 계층 관계를 이루고 있으며 이를 들여쓰기를 통해 표시하고 있습니다. 우리가 앱 내에서 URI를 호출했을 때 응답받을 데이터 항목은 실제로 이와 같은 구조를 가지고 있으므로 데이터를 파싱하기 위해서는 위 구조를 잘 이해해야 합니다. 영화 정보 목록은 배열 형식으로 이루어지는데, 이 값들은 data -&gt; movies 아래에 저장됩니다. 배열 형식에서 반복 작성된 영화 정보들은 각각 id, url, imdb_code, title 등을 제공합니다. 이제 직접 요청 URI를 만들어 호출해 보고, 그 결과값을 받아 파싱처리하는 코드를 작성해 보겠습니다.</p>
<p><br></p>
<h4 id="네비게이션-컨트롤러를-이용한-화면-전환"><a href="#네비게이션-컨트롤러를-이용한-화면-전환" class="headerlink" title="네비게이션 컨트롤러를 이용한 화면 전환"></a>네비게이션 컨트롤러를 이용한 화면 전환</h4><p>그 전에 먼저 Navigation Controller를 사용하여 기본적인 화면 전환을 구성해 보도록 하겠습니다. 네비게이션 컨트롤러는 뷰 컨트롤러의 특별한 종류로, 계층적인 성격을 띠는 콘텐츠 구조를 관리하기 위한 컨트롤러입니다. 앱의 네비게이션을 표시해줄 수 있는 내비게이션 바가 내장되어 있죠.</p>
<p><br></p>
<p>네비게이션 컨트롤러는 뷰 컨트롤러들의 전환을 직접 컨트롤하고, 앱의 네비게이션 정보를 표시하는 역할을 할 뿐만 아니라 화면 전환이 발생하는 뷰 컨트롤러들의 포인터를 스택으로 관리하여 원하는 화면에 접근하기 쉽게 합니다.</p>
<p><br></p>
<p>네비게이션 컨트롤러는 뷰 컨트롤러들의 계층적 구조를 관리하는 역할이기 때문에, 직접 콘텐츠를 담고 화면을 구성하지는 않습니다. 대신 다른 뷰 컨트롤러들을 포함하고 있죠. 이 때문에 스토리보드에서 보이는 것과 다르게 독립된 자신만의 화면을 가지지 않는 대신, 이 컨트롤러가 제어하는 모든 뷰 컨트롤러에 네비게이션 바를 생성하는 특징이 있습니다.</p>
<p><br></p>
<p><img src="/image/ios11.jpeg" alt="ios11"></p>
<p><br></p>
<p>위 그림은 네비게이션 컨트롤러가 관리하는 뷰 컨트롤러 객체 관계를 나타냅니다. 네비게이션 컨트롤러는 항상 콘텐츠 계층 구조의 시작점 역할을 하는 뷰 컨트롤러와 함께 다니는데, 이를 루트 뷰 컨트롤러라고 합니다. 거의 뭐 베스트 프렌드라고 할 수 있죠. 루트 뷰 컨트롤러는 네비게이션 컨트롤러에 직접 연결된 컨트롤러이므로 화면 UI 상단에 네비게이션 바가 표시됩니다. 류트 뷰 컨트롤러에서 화면 전환이 발생하면 다음 뷰 컨트롤러가 그 위로 올라오지만, 이때에도 역시 상단에 추가된 네비게이션 바는 그대로 유지됩니다.</p>
<p><br></p>
<p>네비게이션 컨트롤러는 화면에 현재 표시되고 있는 뷰 컨트롤러들을 네비게이션 스택을 이용하여 관리합니다. 네비게이션 스택은 배열 형식으로 되어 있죠. 배열을 세로로 쌓았다고 할 때, 가장 아래에 있는 첫 번째 뷰 컨트롤러는 루트 뷰 컨트롤러이고, 최상위에 있는 마지막 뷰 컨트롤러는 현재 화면에 표시되고 있는 뷰 컨트롤러입니다. 네비게이션 컨트롤러 객체의 메소드를 사용하려면 스택의 정보를 수정할 수 있는데, 기본적으로 스택의 최상위에 뷰 컨트롤러를 추가할 때는 pushViewController(_:animated:) 메소드를 사용합니다. 반대로 스택의 최상위 뷰 컨트롤러를 제거할 때에는 popViewController(animated:) 메소드를 사용합니다. 네비게이션 컨트롤러를 사용해서 화면을 전환하고 복귀하는 기능을 실제로 구현해봅시다.</p>
<p><br><hr><br></p>
<p><img src="/image/ios12.png" alt="ios12"></p>
<p><br></p>
<p>영화 리스트를 보여줄 새로운 뷰 컨트롤러까지 추가한 상태입니다. 영화 리스트를 보여줄 뷰 컨트롤러의 아이덴티티 인스펙터 탭에서 Storyboard ID 항목에 ‘MovieList’를 입력합니다. 다시 첫 번째 뷰 컨트롤러에 돌아가서, 버튼을 추가합니다. 추가된 버튼을 ViewController 클래스로 드래그합니다. 연결 정보창에서는 [Connection] 항목을 Action으로 선택하고, [Name] 항목을 MoveToList로 입력하였습니다. ViewController 클래스에 추가된 moveToList 메소드에 다음과 같은 내용을 작성합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewController.swift</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">moveToList</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">        <span class="comment">// MovieList 뷰 컨트롤러 인스턴스를 가져온다.</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> uvc = <span class="keyword">self</span>.storyboard?.instantiateViewController(identifier: <span class="string">"MovieList"</span>) <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 화면을 전환한다.</span></span><br><span class="line">        <span class="keyword">self</span>.navigationController?.pushViewController(uvc, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>메소드에 추가된 내용을 살펴봅시다. 스토리보드에서 설정했던 아이디를 이용하여 뷰 컨트롤러를 읽어오고, 객체로 생성하는 내용이 먼저 나옵니다. 안전한 코드를 위해 self.storyboard를 옵셔널 체인으로 처리하여 instantiateViewController(withIdentifier:) 메소드를 호출하여 뷰 컨트롤러의 인스턴스를 받아온 다음, 옵셔널 타입을 해제하기 위해 상수 uve에 바인딩합니다. 만약 바인딩이 실패할 경우, 해당 메소드의 실행은 중지됩니다.</p>
<p><br></p>
<p>화면 전환을 처리하는 부분에는 pushViewController(_:animated:) 메소드가 사용되었습니다. 기술적 관점에서 네비게이션 스택 최상위에 뷰 컨트롤러 객체 uvc를 추가하는 것이지만, 사용자들에게는 화면을 전환하는 결과로 나타납니다. 유의할 점은 메소드를 호출하는 대상입니다. 해당 메소드는 호출하는 대상이 네비게이션 컨트롤러입니다. self.navigationController는 현재의 뷰 컨트롤러에 연결된 네비게이션 컨트롤러를 가리키는 것으로, 만약 뷰 컨트롤러에 네비게이션 컨트롤러가 연결되어 있지 않을 경우 nil 값을 반환합니다.</p>
<p><br></p>
<p>잠깐만! 여기까지 코드를 통해 화면 전환을 하는 법을 알아보았고, 다음은 스토리보드에서 간단히 세그웨이 지정을 통해 원하는 구성대로 화면 전환이 되도록 만들어보았습니다. 이를 바탕으로 네트워크 객체를 통한 데이터 요청 기능 구현을 살펴보도록 하겠습니다. 그 전에 먼저 세그웨이를 이용하여 화면 전환하면서 값을 전달하는 방법을 알아보도록 하겠습니다.<br><br></p>
<p><img src="/image/ios13.png" alt="ios13"></p>
<p><br></p>
<h4 id="세그웨이를-이용하여-화면-전환하면서-값을-전달하기"><a href="#세그웨이를-이용하여-화면-전환하면서-값을-전달하기" class="headerlink" title="세그웨이를 이용하여 화면 전환하면서 값을 전달하기"></a>세그웨이를 이용하여 화면 전환하면서 값을 전달하기</h4><p>화면을 전환해주는 객체인 세그웨이는 수동으로 실행할 수 있는 매뉴얼 세그웨이와 자동으로 실행되는 액션 세그웨이로 나누어집니다. 하지만 어느 세그웨이를 사용하든 값을 전달하는 방식은 모두 동일합니다. 가장 먼저 할 일은 세그웨이를 위 처럼 연결하는 겁니다. 세그웨이 종류는 네비게이션 바가 추가되었으니 [Show] 타입으로 생성하면 될 것 같네요. 메인 화면에서 영화 리스트를 보여주는 화면으로 전환되는 세그웨이에 MovieList로 [Identifier] 항목의 값을 입력하였습니다.</p>
<p><br></p>
<p>자, 그러면 여기서 문제입니다. 값을 전달하는 코드는 어디에 넣어야 할까요? 정답은 “세그웨이 실행을 위한 준비 메소드 부분에 값을 전달해준다”입니다. 세그웨이 전처리 메소드 prepare(for:sender:) 메소드는 세그웨이가 실행되기 직전에 호출되는 메소드입니다. 이 메소드는 우리가 직접 호출하는 것이 아니라 필요한 내용을 작성해 둔 다음 가만히 놔두면 iOS 시스템이 알아서 적절한 시점에 호출하는 지뢰 같은 존재입니다. 메뉴얼 세그웨이나 액션 세그웨이에 구분없이 모든 세그웨이가 실행되기 전에 iOS는 prepare(for:sender:) 메소드를 먼저 호출합니다. 커스텀 클래스에서 오버라이드하지 않았다면 그보다 상위 클래스에 정의된 동일 메소드를 호출하죠. 이 메소드를 커스텀 클래스에서 오버라이드한 다음, 여기에다 값을 전달하는 코드를 넣으면 우리가 원하는 대로 값을 전달할 수 있습니다.</p>
<p><br></p>
<p>여기서 다음 문제입니다. 값을 전달할 뷰 컨트롤러의 인스턴스 정보는 어떻게 얻어올 수 있을까요? 세그웨이를 다룰 때에는 이동할 대상 뷰 컨트롤러의 인스턴스를 우리가 직접 생성해서는 안됩니다. 세그웨이의 목적지로 연결된 뷰 컨트롤러의 인스턴스는 세그웨이에 의해 자동으로 생성되기 때문에, 세그웨이 객체를 통해 생성된 뷰 컨트롤러 인스턴스 참조를 읽어와야 합니다. 이 정보는 prepare(for:sender:) 메소드의 첫 번째 인자값인, segue 매개변수를 통해 얻을 수 있습니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> rating: <span class="type">UITextField!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">(<span class="keyword">for</span> segue: UIStoryboardSegue, sender: <span class="keyword">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 목적지 뷰 컨트롤러 인스턴스 읽어오기</span></span><br><span class="line">        <span class="keyword">let</span> dest = segue.destination</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> rvc = dest <span class="keyword">as</span>? <span class="type">ListViewController</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 값 전달</span></span><br><span class="line">        rvc.paramRating = <span class="keyword">self</span>.rating.text! <span class="comment">// 평점</span></span><br><span class="line">        </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>메소드 매개변수 segue 속성 destination을 이용하여 목적지 뷰 컨트롤러의 인스턴스 참조를 가져옵니다.</li>
<li>인스턴스의 타입을 UIViewController에서 ListViewController 타입으로 캐스팅합니다. 실패하면 메소드를 종료합니다.</li>
<li>캐스팅된 인스턴스 상수 rvc를 이용하여 값을 전달합니다.</li>
</ol>
<p><br></p>
<h4 id="네트워크-객체를-통한-데이터-요청-기능-구현"><a href="#네트워크-객체를-통한-데이터-요청-기능-구현" class="headerlink" title="네트워크 객체를 통한 데이터 요청 기능 구현"></a>네트워크 객체를 통한 데이터 요청 기능 구현</h4><p>본격적으로 API를 호출하고 응답 데이터를 받아 화면에 표시해봅시다. 우선 네트워크를 통해 주어진 API를 호출하고 데이터를 받아오는 과정을 처리하겠습니다. 가장 먼저 처리해야 할 것은 ListViewController.swift 파일을 열고, viewDidLoad() 메소드 내부에 REST API를 호출하는 코드를 작성하는 일입니다. 스위프트나 파운데이션 프레임워크에는 REST API 호출을 위한 전용 객체가 따로 준비되어 있지 않지만, REST 방식의 구현은 일반 웹 페이지를 호출할 때와 거의 동일한 코드로 구현이 가능하므로 단순히 웹 페이지를 호출하는 코드를 작성한다고 생각하면 구현하기 쉽습니다.</p>
<p><br></p>
<p>스위프트에서 웹 페이지를 호출할 때에는 POST 방식과 GET 방식에 따라 각각 작성해야 하는 소스 코드가 다릅니다. 서로 다른 객체를 사용해야 하죠. 특히 POST 방식으로 HTTP 요청을 전송하기 위해 작성해냐 하는 코드는 다소 길고 복잡하지만, 다행이 우리가 사용할 API는 GET 방식으로 호출하면 되기 때문에 비교적 간단하게 작성할 수 있습니다. 스위프트에서 GET 방식으로 REST API를 호출하여 데이터를 읽어오는 방법은 다음과 같습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="type">Data</span>(contentsOf: <span class="type">URL</span>타입의 객체)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>Data는 파운데이션 프레임워크에서 제공하는 클래스입니다. 다양한 종류의 데이터를 변환 과정 없이 저장하기 위해 사용하는 객체는 텍스트 기반의 데이터뿐만 아니라 이미지나 동영상과 같은 바이너리 데이터도 담을 수 있어 여러 가지 종류의 데이터를 처리하는 데에 탁월한 효율성을 자랑합니다.</p>
<p><br></p>
<p>이 객체는 동일한 기능을 제공하는 NSData 객체를 원본으로 하여 스위프트 3 버전부터 새롭게 정의되었습니다. 실제로 Data 클래스의 레퍼런스를 보면 내부적으로는 NSData 객체를 참조하고 있는 것이 확인됩니다. 이같은 구조적 특성 때문에 Data 객체는 NSData 객체가 가지고 있는 기능 대부분을 지원할뿐만 아니라 NSData 객체와 서로 타입 캐스팅도 가능합니다. NSData로 만들어진 객체를 필요에 따라 Data 타입으로 바꾸어 쓰거나 그 반대의 경우가 모두 가능하다는 뜻입니다. 이들은 상위/하위 관계가 아니기 때문에 캐스팅 시 옵셔널 연산자를 붙이지 않아도 됩니다. 이같은 특성을 지닌 Data 객체에서 제공되는 Data(ContentsOf:) 초기화 구문은 복잡한 과정 없이도 손쉽게 GET  방식으로 RESTful 서비스를 호출하고 응답을 받아올 수 있도록 지원합니다. 물론 이 과정에서 잘못된 URL이 입력되었거나 서버에 문제가 있는 등의 이유로 응답을 받지 못하는 경우도 존재하는데, 이때에는 Data 객체에 nil 값이 담기기도 합니다. 따라서 Data(contentsOf:)를 통해 생성되는 인스턴스는 항상 옵셔널 타입입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rating 값을 받을 변수</span></span><br><span class="line">    <span class="keyword">var</span> paramRating: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 영화 API 호출을 위한 URI를 생성</span></span><br><span class="line">        <span class="keyword">let</span> url = <span class="string">"https://yts.mx/api/v2/list_movies.json?limit=10&amp;minimum_rating="</span> + paramRating</span><br><span class="line">        <span class="keyword">let</span> apiURI: <span class="type">URL!</span> = <span class="type">URL</span>(string: url)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. REST API 호출</span></span><br><span class="line">        <span class="keyword">let</span> apidata = <span class="keyword">try</span>! <span class="type">Data</span>(contentsOf: apiURI)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 데이터 전송 결과를 로그로 출력 (확인용)</span></span><br><span class="line">        <span class="keyword">let</span> log = <span class="type">NSString</span>(data: apidata, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8.rawValue) ?? <span class="string">""</span></span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"API Result = \( log )"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="영화-API-호출을-위한-URI-생성"><a href="#영화-API-호출을-위한-URI-생성" class="headerlink" title="영화 API 호출을 위한 URI 생성"></a>영화 API 호출을 위한 URI 생성</h5><p>REST API 호출은 Data(contentsOf:)이 담당하지만, 호출에 필요한 네트워크 주소를 URL 객체 타입으로 넣어주어야 합니다. URL은 파운데이션 프레임워크에 정의된 객체로, NSURL 클래스를 바탕으로 하여 스위프트에 적합하도록 구현된 객체입니다. URL 클래스는 문자열 형태의 네트워크 주소를 인자값으로 입력받아 파운데이션 프레임워크에서 사용하는 형식의 주소 객체를 생성합니다. 예제에서 문자열로 사용하고 있는 주소는 영화 목록 API를 호출하기 위한 Request URI 입니다. 이렇게 생성한 URL 객체는 다음 행의 Data 클래스 초기화 과정에 인자값으로 전달하기 위해 apiURL라는 이름의 상수에 대입되는데, 여기까지가 1번 부분에 작성된 내용입니다.</p>
<p><br></p>
<h5 id="REST-API-호출"><a href="#REST-API-호출" class="headerlink" title="REST API 호출"></a>REST API 호출</h5><p>두 번째 부분에서는 URI 객체가 저장된 apiURI 상수를 인자값으로 사용하여 REST API를 호출하고 있습니다. 내부적으로는 입력받은 URL 객체를 이용하여 네트워크 통신을 하고, 이 결과로 응답받은 데이터를 Data 객체에 저장한 다음 이 객체를 필요한 순간에 사용하기 위해 apidata 상수에 저장하는 거죠. 이렇게 apidata에 저장된 Data 객체는 이후 용도에 맞는 다른 객체로 다시 변환하여 사용합니다.</p>
<p><br><br></p>
<h4 id="전달받은-데이터를-파싱하여-화면에-출력"><a href="#전달받은-데이터를-파싱하여-화면에-출력" class="headerlink" title="전달받은 데이터를 파싱하여 화면에 출력"></a>전달받은 데이터를 파싱하여 화면에 출력</h4><p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ListViewController.swift</span></span><br><span class="line"><span class="comment">//  Prography</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 조성지 on 2020/03/01.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 조성지. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 테이블 뷰를 구성할 리스트 데이터</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> list: [<span class="type">MovieVO</span>] = &#123;</span><br><span class="line">        <span class="keyword">var</span> datalist = [<span class="type">MovieVO</span>]()</span><br><span class="line">        <span class="keyword">return</span> datalist</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rating 값을 받을 변수</span></span><br><span class="line">    <span class="keyword">var</span> paramRating: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 영화 API 호출을 위한 URI를 생성</span></span><br><span class="line">        <span class="keyword">let</span> url = <span class="string">"https://yts.mx/api/v2/list_movies.json?limit=10&amp;minimum_rating="</span> + paramRating</span><br><span class="line">        <span class="keyword">let</span> apiURI: <span class="type">URL!</span> = <span class="type">URL</span>(string: url)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. REST API 호출</span></span><br><span class="line">        <span class="keyword">let</span> apidata = <span class="keyword">try</span>! <span class="type">Data</span>(contentsOf: apiURI)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 데이터 전송 결과를 로그로 출력 (확인용)</span></span><br><span class="line"><span class="comment">//        let log = NSString(data: apidata, encoding: String.Encoding.utf8.rawValue) ?? ""</span></span><br><span class="line"><span class="comment">//        NSLog("API Result = \( log )")</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. JSON 객체를 파싱하여 NSDictionary 객체로 받음</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> apiDictionary = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject(with: apidata, options: []) <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 데이터 구조에 따라 차례대로 캐스팅하며 읽어온다.</span></span><br><span class="line">            <span class="keyword">let</span> data = apiDictionary[<span class="string">"data"</span>] <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line">            <span class="keyword">let</span> movies = data[<span class="string">"movies"</span>] <span class="keyword">as</span>! <span class="type">NSArray</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 6. Iterator 처리를 하면서 API 데이터를 MovieVO 객체에 저장한다.</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> movies&#123;</span><br><span class="line">                <span class="comment">// 순회 상수를 NSDictionary 타입으로 캐스팅</span></span><br><span class="line">                <span class="keyword">let</span> r = row <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 테이블 뷰 리스트를 구성할 때 데이터 형식</span></span><br><span class="line">                <span class="keyword">let</span> mvo = <span class="type">MovieVO</span>()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// movie 배열의 각 데이터를 mvo 상수의 속성에 대입</span></span><br><span class="line">                mvo.title = r[<span class="string">"title"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">                mvo.rating = r[<span class="string">"rating"</span>] <span class="keyword">as</span>? <span class="type">Double</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// list 배열에 추가</span></span><br><span class="line">                <span class="keyword">self</span>.list.append(mvo)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="comment">// 주어진 행에 맞는 데이터 소스를 읽어온다.</span></span><br><span class="line">        <span class="keyword">let</span> row = <span class="keyword">self</span>.list[indexPath.row]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// as! UITableViewCell</span></span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"ListCell"</span>)!</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 데이터 소스에 저장된 값을 각 아울렛 변수에 할당</span></span><br><span class="line">        cell.textLabel?.text = row.title</span><br><span class="line">        cell.detailTextLabel?.text = <span class="string">"\(row.rating!)"</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 셀 객체를 반환</span></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"선택된 행은 \(indexPath.row)번째 행입니다"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // MARK: - Navigation</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // In a storyboard-based application, you will often want to do a little preparation before navigation</span></span><br><span class="line"><span class="comment">    override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;</span></span><br><span class="line"><span class="comment">        // Get the new view controller using segue.destination.</span></span><br><span class="line"><span class="comment">        // Pass the selected object to the new view controller.</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="JSON-객체를-파싱하여-NSDictionary-객체로-변환"><a href="#JSON-객체를-파싱하여-NSDictionary-객체로-변환" class="headerlink" title="JSON 객체를 파싱하여 NSDictionary 객체로 변환"></a>JSON 객체를 파싱하여 NSDictionary 객체로 변환</h5><p>네트워크를 통해 호출한 API 데이터는 apidata 상수에 저장되어 있습니다. 하지만 이 apidata 상수는 Data 타입이어서 우리가 바로 꺼내 쓰기는 어렵습니다. 로그를 출력하기 위해 NSString 타입의 문자열로 변환하였듯이, 테이블을 구성하는 데이터로 사용하려면 NSDictionary 객체로 변환해야 합니다. NSDictionary는 키-값으로 된 데이터 구조를 저장하므로 JSONObject 포맷의 데이터와 호환됩니다. 만약 데이터가 리스트 형태로 전달되었다면 JSONArray 포맷과 호환되는 NSArray 객체를 사용해야 합니다.</p>
<p><br></p>
<p>데이터를 파싱할 때는 파운데이션 프레임워크에서 제공하는 JSONSerialization 객체의 jsonObject() 메소드를 사용하는 것이 좋습니다. 이 메소드는 두 개의 인자값을 입력받는데, 첫 번째는 파싱할 데이터이며 두 번째는 파싱 옵션입니다. 파싱할 데이터에는 apidata 상수를, 파싱 옵션에 넣을 것은 아무것도 없으므로 빈 배열을 넣어주면 됩니다.</p>
<p><br></p>
<p>jsonObject() 메소드는 파싱 과정에서 오류가 발생하면 이를 예외로 던지도록 설계되어 있습니다. 이 때문에 메소드를 사용하기 위해서는 do ~ try ~ catch 구문으로 감싸주어야 합니다. 진행 도중에 오류가 발생하면 진행하던 과정을 멈추고 catch 블록 쪽으로 오류와 함께 실행 흐름이 전달되죠. jsonObject() 메소드의 실행 결과는 입력된 데이터에 따라 NSDictionary 혹은 NSArray 형태로 나올 수 있습니다. 양쪽을 모두 지원하기 위해 이 메소드는 옵셔널 Any 타입으로 정의된 결과값을 반환하므로 최종적으로는 이 결과값을 원하는 객체로 캐스팅해서 받아야 합니다.</p>
<p><br></p>
<p>여기서는 실행 결과를 NSDictionary로 캐스팅하여 apiDictionary 변수에 저장하고 있습니다. 캐스팅을 위한 as 키워드에 옵셔널 연산자가 붙은 것을 볼 수 있는데, as! 는 옵셔널 타입의 객체를 캐스팅할 때 강제로 해제하여 캐스팅하라는 의미입니다. 물론 해제하지 않고 옵셔널 타입을 유지한 채 하려면 as?를 사용하면 됩니다.</p>
<p><br></p>
<h5 id="데이터-구조에-따라-차례대로-캐스팅하며-읽어옴"><a href="#데이터-구조에-따라-차례대로-캐스팅하며-읽어옴" class="headerlink" title="데이터 구조에 따라 차례대로 캐스팅하며 읽어옴"></a>데이터 구조에 따라 차례대로 캐스팅하며 읽어옴</h5><p>apiDictionary 변수에 저장된 JSON 데이터를 분해하여 원하는 값을 단계적으로 찾아가는 부분입니다. 최상위에 data라는 노드에서 그 하위 노드의 movies에 접근하여 노드 하위에 반복되면서 정의된 영화 아이디와 제목, 그리고 평점을 함께 반복하는 식입니다. 이 구조에 따라, 우리가 원하는 영화 목록 정보에 접근합니다.</p>
<p><br></p>
<h5 id="배열을-순회하면서-영화-정보-데이터를-차례로-MovieVO-객체로-생성한-다음-이를-list-배열에-추가"><a href="#배열을-순회하면서-영화-정보-데이터를-차례로-MovieVO-객체로-생성한-다음-이를-list-배열에-추가" class="headerlink" title="배열을 순회하면서 영화 정보 데이터를 차례로 MovieVO 객체로 생성한 다음, 이를 list 배열에 추가"></a>배열을 순회하면서 영화 정보 데이터를 차례로 MovieVO 객체로 생성한 다음, 이를 list 배열에 추가</h5><p>for ~ in 구문을 이용하여 movies 배열에 저장된 영화 정보를 순회하면서 MovieVO 타입의 객체를 만든 다음, 이를 self.list에 담아주는 과정입니다.</p>
<p><br><br></p>
<p>화면이 정상적으로 출력된 모든 분들에게 축하를!</p>
<p><br><br></p>
<h1 id="ScreenShots"><a href="#ScreenShots" class="headerlink" title="ScreenShots"></a>ScreenShots</h1><p><br></p>
<p><img src="/image/prog2.png" alt="prog2"></p>
<p><br></p>
<p><img src="/image/prog3.png" alt="prog3"></p>
<p><br></p>
<p><img src="/image/prog4.png" alt="prog4"></p>
<p><br></p>
<p><img src="/image/prog5.png" alt="prog5"></p>
<p><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/24/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%8F%84%EC%A0%84%EA%B8%B0-4/">
                [IOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (4)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-24</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="밑바닥부터-시작하는-iOS-앱-개발-4"><a href="#밑바닥부터-시작하는-iOS-앱-개발-4" class="headerlink" title="밑바닥부터 시작하는 iOS 앱 개발 (4)"></a>밑바닥부터 시작하는 iOS 앱 개발 (4)</h1><p><br></p>
<h5 id="본-포스팅은-“꼼꼼한-재은씨의-Swift”와-“Do-it-스위프트로-아이폰-앱-만들기-입문-”를-정리한-내용입니다"><a href="#본-포스팅은-“꼼꼼한-재은씨의-Swift”와-“Do-it-스위프트로-아이폰-앱-만들기-입문-”를-정리한-내용입니다" class="headerlink" title="본 포스팅은 “꼼꼼한 재은씨의 Swift”와 “Do it! 스위프트로 아이폰 앱 만들기(입문)”를 정리한 내용입니다."></a>본 포스팅은 “꼼꼼한 재은씨의 Swift”와 “Do it! 스위프트로 아이폰 앱 만들기(입문)”를 정리한 내용입니다.</h5><p><br></p>
<h4 id="엔트리-포인트"><a href="#엔트리-포인트" class="headerlink" title="엔트리 포인트"></a>엔트리 포인트</h4><p>C 언어에 뿌리를 둔 모든 애플리케이션은 main() 함수로부터 시작됩니다. 이를 엔트리 포인트라고 하죠. 운영체제가 애플리케이션 내부에 정의된 main() 함수를 찾아 호출하면 여기에 작성된 코드들이 연쇄적으로 실행되면서 우리가 작성한 커스텀 코드에까지 도달하게 되는 식입니다.</p>
<p><br></p>
<p>main() 함수가 하는 일은 단순합니다. 실행 시 시스템으로부터 전달받은 두 개의 인자값과 AppDelegate 클래스를 이용하여 UIApplicationMain() 함수를 호출하고, 그 결과로 UIApplication 객체를 반환합니다. 생성된 UIApplication 객체는 UIKit 프레임워크에 속해 있으므로 이후의 앱 제어권은 UIKit 프레임워크로 이관됩니다.</p>
<p><br></p>
<p>main() 함수가 C 기반 애플리케이션의 엔트리 포인트라면, UIApplicationMain() 함수는 그 중에서도 iOS 앱에 속하는 부분의 엔트리 포인트라고 할 수 있습니다. 이 함수는 앱의 핵심 객체를 생성하는 프로세스를 핸들링하고, 스토리보드 파일로부터 앱의 유저 인터페이스를 읽어들일뿐만 아니라 우리가 작성한 커스텀 코드를 호출해 줌으로써 앱 생성 초기에 필요한 설정을 구현할 수 있게 해 줍니다. 여기에 더해서 이벤트를 입력받기 위한 이벤트 루프를 실행시키기도 하죠. 이 과정에서 우리가 직접 구현해야 하는 것은 스토리보트 파일이나 초기화를 위한 커스텀 코드뿐입니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// AppDelegate.swift</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionKey: <span class="keyword">Any</span>]?)</span></span> -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="comment">// 스토리보드 인스턴스        </span></span><br><span class="line">        <span class="keyword">let</span> introStoryboard = <span class="type">UIStoryboard</span>(name: <span class="string">"IntroViewController"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 뷰컨트롤러 인스턴스</span></span><br><span class="line">        <span class="keyword">let</span> introViewController = introStoryboard.instantiateViewController(withIdentifier: <span class="string">"IntroViewController"</span>) <span class="keyword">as</span>? <span class="type">IntroViewController</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// window 만들어주기</span></span><br><span class="line">        <span class="keyword">self</span>.window = <span class="type">UIWindow</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// window의 루트 뷰컨트롤러 설정</span></span><br><span class="line">        <span class="keyword">self</span>.window?.rootViewController = introViewController</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 화면에 보여주기</span></span><br><span class="line">        <span class="keyword">self</span>.window?.makeKeyAndVisible()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h4 id="앱을-구성하는-핵심-객체들"><a href="#앱을-구성하는-핵심-객체들" class="headerlink" title="앱을 구성하는 핵심 객체들"></a>앱을 구성하는 핵심 객체들</h4><p><br></p>
<ul>
<li>iOS 유저 인터페이스의 표현 구조</li>
</ul>
<p><br></p>
<p>iOS는 일반 데스크톱과 유저 인터페이스 표현 구조가 다소 다릅니다. 하나의 스크린에 여러 개의 창을 띄울 수 있는 데스크톱과 달리 iOS는 항상 디바이스 스크린에 꽉 들어차는 하나의 화면만을 표시할 수 있으며, 다른 프로그램이 실행되면 기존의 화면은 내려가고 그 자리를 새로운 화면이 대신 채웁니다. 이런 일련의 과정을 구현하는 데에 윈도우와 뷰 객체가 사용됩니다.</p>
<p><br></p>
<p>윈도우는 iOS에서 디바이스의 스크린을 빈틈없이 채우기 위한 객체로, 항상 유저 인터페이스 표현 계층의 최상위에 위치합니다. 뷰의 일종이지만 직접 콘텐츠를 가지지는 않으며 콘텐츠를 가진 뷰를 내부에 배치하여 화면에 출력하는 역할을 하죠. 화면이 전환되더라도 윈도우 객체는 전환되지 않으며 단지 내부에 배치된 뷰의 콘텐츠만 변경됩니다.</p>
<p><br></p>
<ul>
<li>뷰 컨트롤러</li>
</ul>
<p><br></p>
<p>뷰 컨트롤러는 앱의 근간을 이루는 객체로, 모든 앱은 최소한 하나 이상의 뷰 컨트롤러로 구성됩니다. 이들의 주된 역할은 화면 구성 요소들, 즉 뷰를 관리하는 것이지만, 단순히 여기서 그치지 않고 화면과 데이터 사이의 상호 작용까지 관리하기도 합니다.<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IntroViewController.swift</span></span><br><span class="line"><span class="keyword">import</span> Foudation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SwiftGifOrigin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntroViewController</span>: <span class="title">UIViewController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imgView: <span class="type">UIImageView!</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line">        imgView.loadGif(asset: <span class="string">"intro"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 딜레이 이후 실행하기</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + .seconds(<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="type">MainViewController</span>.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br></p>
<p>여기까지 시도하다가 다음과 같은 1차 오류를 만났다…</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Storyboard</span> (&lt;<span class="type">NSStoryboard</span>: <span class="number">0x600000000f70</span>&gt;) doesn't contain a controller with identifier '<span class="type">ViewController'</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이후 Initial Controller로 IntroViewController를 지정해 준 후, 다시 시작 화면으로 지정하고자 하는 스토리보드에서 커스텀 클래스를 살펴보니 IntroViewController가 보이지 않았다. 여기서 도대체 시작화면을 어떻게 지정해 줄 수 있는지 난감해 하다가 Launch Screen 스토리보드가 해당 역할을 수행한다는 것을 꼼꼼한 재은씨의 책에서 찾을 수 있었다… 그래서 우선 Launch Screen을 사용해 보고, 차후에 해당 문제를 다시금 파헤쳐보자…! 우선 쭉 따라하다보면 큰 틀은 감이 올 것 같다.</p>
<p><br><br></p>
<h4 id="시작-화면-제어하기"><a href="#시작-화면-제어하기" class="headerlink" title="시작 화면 제어하기"></a>시작 화면 제어하기</h4><p>사실 앱을 실행시키면 처음부터 우리가 만든 뷰 컨트롤러 화면이 나타나는 것은 아닙니다. 앱이 실행되면 처음에 어떤 화면이 잠깐 표시되었다가 잠시 후에 자동으로 첫 번째 뷰 컨트롤러로 화면이 전환되는데, 이를 론치 스크린(Launch Screen)이라고 합니다. 다른 말로 스플래시(Splash)라고 부르는데, 저는 시작 화면이라는 단어가 더 좋군요.</p>
<p><br></p>
<p>iOS에서 시작 화면은 별도의 파일로 제공됩니다. 스토리보드 형식의 파일이지만, Main.storyboard 파일에 시작 화면이 포함되어 있는 것이 아니라 시작 화면을 위한 별도의 파일이 제작되어 있죠. 우리가 만든 프로젝트에서도 시작 화면 파일이 따로 제공되는데, 바로 LaunchScreen.storyboard 파일입니다. 이 파일을 열어 내용을 편집하는 것으로 원하는 시작 화면을 구성할 수 있습니다.</p>
<p><br></p>
<p>그런데 특별한 것이 없는 일반 스토리보드 형식인 이 파일이 왜 시작 화면 역할을 하는 것인지 궁금한 분 없으신가요? 이에 대한 답으로 프로젝트 메타 정보의 항목을 설명하던 [App Icons and Launch images] 부분이 중요한 실마리를 제공하죠. 여기에 설정된 항목 중에서 [Launch Screen File]을 보면, 현재의 시작 화면 파일의 이름과 동일한 LaunchScreen이 입력되어 있는 것을 볼 수 있습니다. .storyboard 확장자가 빠져 있지만, 그건 자동으로 붙일 수 있는 것이니 신경 쓰지 맙시다.</p>
<p><br></p>
<p>분명 여기까지 정리한 후 직접 스토리보드를 보면서 속이 후련하였는데, 만들어 놓은 시작 화면 이미지를 Image View 객체로 추가하려고 보니 오토레이아웃이라는 익숙치 않은 거대한 벽에 또 한번 좌절하였다… 그래서 우선 스토리보드에서 배경화면 색을 지정하고 Label 객체로 문자열을 넣어 주었다. 여기까지 실행에 성공하였다.</p>
<p><br></p>
<p>그런데, 시작 화면 출력 시간이 너무 짧아 충분히 감상하기 어렵습니다. 시작 화면이 표시되는 시간을 늘려봅시다. 프로젝트 네비게이터에서 AppDelegate.swift 파일을 찾아 클릭합니다. 이 파일에는 AppDelegate 클래스가 정의되어 있는데, 이 클래스는 앱 전체의 실행 흐름을 컨트롤하는 객체로서 앱이 처음 실행되거나 종료될 때, 혹은 백그라운드 상태로 들어가거나 포그라운드 상태로 활성화될 때 호출되는 매소드들로 구성되어 있습니다. 하지만 이들 메소드들은 모두 텅 비어 있습니다. 우리가 여기에 커스텀 코드를 작성하여 컨트롤해주기를 기다리고 있는 것이죠.</p>
<p><br></p>
<p>기본으로 정의되어 있는 여러 개의 메소드 중에서 우리에게 필요한 것은 application(_:didFinishLaunchWithOptions:)입니다. 이 메소드는 앱이 처음 실행될 때, 필요한 시스템적 처리를 모두 끝내고 메인 화면을 표시하기 직전에 호출됩니다. 다시 말해, 앱이 맨 처음 실행될 때 시작 화면이 모바일 기기의 스크린에 표시된 후 이 메소드가 호출되고, 이 메소드 내부에 작성된 내용이 모두 실행되고 나면 우리가 앞에서 구현한 Main.storyboard 파일의 화면이 스크린에 표시되는 겁니다. 그러니 이 메소드에 뭔가 수작질(?)을 하는 것으로 시작 화면이 표시되는 시간을 제어할 수 있습니다. 이 메소드에 아래 표시된 것과 같이 sleep(5) 구문을 추가합니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class="keyword">Any</span>]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    <span class="comment">// 이 부분은 프로세스의 진행을 멈춰 시작 화면이 표시되는 시간을 늘려주는 역할을 합니다.</span></span><br><span class="line">    sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>sleep(5)는 5초간 앱을 잠들게 한다는 뜻으로서, 앱 실행을 지연시키는 역할을 합니다. 앞에서 설명한 진행 흐름에 따라 application(_:didFinishLaunchingWithOptions:) 메소드의 실행이 완전히 끝나지 않는 한 메인 화면은 실행되지 않기 때문에 메소드 내부에서 프로세스의 실행이 5초 동안 지연되면 그 시간만큼 로딩 화면이 계속 표시되는 효과가 생깁니다. 이것이 우리가 원하는 대로 로딩 화면이 표시되는 시간을 늘릴 수 있는 원리입니다.</p>
<p><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/24/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%8F%84%EC%A0%84%EA%B8%B0-5/">
                [iOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (5)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-24</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="밑바닥부터-시작하는-iOS-앱-개발-5"><a href="#밑바닥부터-시작하는-iOS-앱-개발-5" class="headerlink" title="밑바닥부터 시작하는 iOS 앱 개발 (5)"></a>밑바닥부터 시작하는 iOS 앱 개발 (5)</h1><p><br></p>
<h5 id="본-포스팅은-“꼼꼼한-재은씨의-Swift”와-“야곰의-iOS-프로그래밍”을-정리한-내용입니다"><a href="#본-포스팅은-“꼼꼼한-재은씨의-Swift”와-“야곰의-iOS-프로그래밍”을-정리한-내용입니다" class="headerlink" title="본 포스팅은 “꼼꼼한 재은씨의 Swift”와 “야곰의 iOS 프로그래밍”을 정리한 내용입니다."></a>본 포스팅은 “꼼꼼한 재은씨의 Swift”와 “야곰의 iOS 프로그래밍”을 정리한 내용입니다.</h5><p><br></p>
<h4 id="로그인-페이지"><a href="#로그인-페이지" class="headerlink" title="로그인 페이지"></a>로그인 페이지</h4><ul>
<li>View Controller</li>
<li>Navigation</li>
<li>MVC Programming Design Pattern</li>
<li>Alert Controller</li>
<li>Application: Life Cycle / Execution States</li>
<li>UIViewController: View Status callback methods</li>
</ul>
<p><br><br></p>
<h4 id="CHAPTER-07-함수-함수가-갑입니다"><a href="#CHAPTER-07-함수-함수가-갑입니다" class="headerlink" title="CHAPTER 07 함수: 함수가 갑입니다"></a>CHAPTER 07 함수: 함수가 갑입니다</h4><p><br></p>
<p>함수(Function)는 대부분의 프로그래밍 언어에서 지원하는 개념으로, 프로그램의 실행 과정 중에서 독립적으로 처리될 수 있는 부분을 분리하여 구조화한 객체를 의미합니다. 즉, 외부에 의존하는 부분 없이 툭 떼어 분리할 수 있는 실행 단위를 일종의 캡슐처럼 포장해놓은 것이죠. 이렇게 독립적으로 작성된 함수는 간단한 방식으로 여러 번 호출하여 사용할 수 있어서 같은 코드를 반복해서 작성할 필요가 없습니다.</p>
<p><br></p>
<p>스위프트는 함수형 프로그래밍 패러다임을 채택하고 있는 언어이므로 함수형 프로그래밍의 특성을 이해하는 것은 매우 중요합니다. 함수의 인자값은 하나도 없을 수도 있고, 하나 이상일 수도 있습니다. 특별한 경우에는 인자값의 개수가 제한되지 않는 형태를 가지기도 합니다. 함수의 반환값 역시 내부의 실행 과정 후 특정 결과값을 반환하는 형태와 실행 후 아무것도 반환하지 않는 형태 두 가지로 나눌 수 있습니다. 이 중에서 특정 결과값을 반환하는 함수는 일반적으로 하나의 값만을 반환합니다. 만약 둘 이상의 값을 반환해야 할 필요가 있다면 반환할 값들을 집단 자료형 하나에 담아 반환합니다. 즉, 실질적으로 반환하는 값이 여러 개더라도, 반환하는 객체 자체는 하나라는 거죠.</p>
<p><br></p>
<p>기본적으로 함수는 의존성 없이 독립 실행되는 코드를 뗴어 놓은 것이지만, 크게 보면 전체 프로세스의 일부분으로 동작하므로 함수 대신 함수 내부의 실행 코드만 가져다 전체 코드에 포함해서 사용해도 됩니다. 다시 말해 프로그래밍에서 함수를 반드시 사용해야 하는 것은 아니라는 겁니다. 그런데도 함수를 만들어서 사용하는 것은 다음과 같은 이점들 때문입니다.</p>
<p><br></p>
<ul>
<li>동일한 코드가 여러 곳에서 사용될 때 이를 함수화하면 재작성할 필요 없이 함수 호출만으로 처리할 수 있습니다.</li>
<li>전체 프로세스를 하나의 소스 코드에서 연속적으로 작성하는 것보다 기능 단위로 함수화하면 가독성이 좋아지고, 코드와 로직을 이해하기 쉽습니다.</li>
<li>비즈니스 로직을 변경해야 할 때 함수 내부만 수정하면 되므로 유지보수가 용이합니다.</li>
</ul>
<p><br></p>
<p>함수의 기본은 인자값을 입력받아 내부적으로 처리하고, 그 결과를 외부로 다시 반환하는 과정에 있습니다. 함수는 값을 반환하고 나면 실행이 종료되므로 사실상 return 구문이 함수의 종료 구문이라고 생각해도 됩니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(name: String?)</span></span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> _name = name <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(_name)님, 안녕하세요"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>return은 함수의 실행을 명시적으로 종료할 목적으로 사용됩니다. 위 함수는 매개변수의 값을 사용하여 메시지를 출력하는데, 이 과정에서 옵셔널 바인딩이 실패했을 경우 return 구문을 호출하여 실행을 종료합니다.</p>
<p><br></p>
<p>인자 레이블은 함수의 호출 시 인자값을 구분하기 위해 사용되는 레이블입니다. 스위프트에서 인자값이 있는 함수를 호출할 때에는 인자값 앞에 반드시 인자 레이블을 붙여서 호출해 주어야 합니다. 만약 인자 레이블 없이 인자값을 호출하면 컴파일 오류가 발생합니다. 일반적으로 스위프트에서 인자 레이블은 매개변수명과 동일합니다.</p>
<p><br></p>
<p>최초에 발표된 스위프트가 언어 자체의 특성에 초점을 맞추었다면 그다음의 스위프트는 코코아 터치 프레임워크를 사용하기 위한 역할로서의 언어에 초점을 맞추었습니다. 이에 따라 코코아 터치 프레임워크에 적용하기 좋은 형태로 문법이 변화된 겁니다. 정리하자면 함수의 식별자에 포함되는 것은 인자 레이블일 뿐, 결코 매개변수가 아님을 확실하게 인지해야 합니다. </p>
<p><br><br></p>
<h4 id="함수의-반환값과-튜플"><a href="#함수의-반환값과-튜플" class="headerlink" title="함수의 반환값과 튜플"></a>함수의 반환값과 튜플</h4><p>함수는 반드시 하나의 값만을 반환해야 합니다. 여러 개의 값을 반환해야 한다면, 이 값들을 담을 수 있는 집단 자료형이 필요하죠. 이때 사용할 수 있는 집단 자료형에는 딕셔너리나 배열, 튜플, 또는 구조체나 클래스가 있습니다. 앞에서 이미 배운 딕셔너리나 배열, 튜플은 물론이거니와 나중에 배우게 될 구조체와 클래스 역시 내부에 여러 개의 변수를 담을 수 있는 객체이므로 함수의 반환값으로 사용할 수 있습니다. 이 중, 활용도가 꽤 높으면서도 반환 타입의 표시 방법이 다른 자료형과 차이가 있는 튜플을 사용하는 예를 살펴보겠습니다.</p>
<p><br></p>
<p>튜플에는 여러 종류의 자료형이 다양하게 섞여 정의될 수 있으므로 이를 빠짐없이 표시해야 하죠. 튜플을 반환하는 변수를 받아 사용하는 방법을 다시 한번 확인해 보겠습니다. 튜플을 반환하는 함수의 반환값을 대입 받은 변수나 상수는 튜플의 인덱스를 이용하여 튜플 내부의 요소를 사용할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUserInfo</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Character</span>, <span class="type">String</span>)&#123;</span><br><span class="line">    <span class="comment">// 데이터 타입이 String으로 추론되는 것을 방지하기 위해 타입 어노테이션 선언</span></span><br><span class="line">    <span class="keyword">let</span> gender: <span class="type">Character</span> = <span class="string">"M"</span></span><br><span class="line">    <span class="keyword">let</span> height = <span class="number">180</span></span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"꼼꼼한 재은씨"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (height, gender, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uInfo = getUserInfo()</span><br><span class="line">uInfo.<span class="number">0</span></span><br><span class="line">uInfo.<span class="number">1</span></span><br><span class="line">uInfo.<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>인덱스를 사용하는 대신 가독성과 편리성을 위해 튜플 요소 각각을 변수로 직접 받을 수도 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (a, b, <span class="built_in">c</span>) = getUserInfo()</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="built_in">c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (height, <span class="number">_</span>, name) = getUserInfo()</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUserInfo</span><span class="params">()</span></span> -&gt; (h: <span class="type">Int</span>, g: <span class="type">Character</span>, n: <span class="type">String</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> gender: <span class="type">Character</span> = <span class="string">"M"</span></span><br><span class="line">    <span class="keyword">let</span> height = <span class="number">100</span></span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"꼼꼼한 재은씨"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (height, gender, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = getUserInfo()</span><br><span class="line">result.h</span><br><span class="line">result.g</span><br><span class="line">result.n</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>실행 결과로 반환되는 튜플의 각 아이템을 함수 정의 구문을 통해 변수에 미리 할당해 둘 수도 있습니다. 반환값 타입을 설정할 때 튜플 항목 하나하나에 미리 변수를 정의해 놓는 겁니다. 이렇게 정의해 두면 함수를 실행할 때 결과값을 바인딩하지 않아도 특정 변수명으로 바인딩된 튜플 인지라르 사용할 수 있습니다.</p>
<p><br></p>
<p>함수가 여러 개의 값을 반환할 때 이를 간단하게 묶기 위해 사용하는 것이 튜플이지만, 특정 튜플 타입이 여러 곳에서 사용될 경우에는 타입 알리어스를 통해 새로운 축약형 타입을 정의하는 것이 좋습니다. 타입 알리어스는 이름이 길거나 사용하기 복잡한 타입 표현을 새로운 타입명으로 정의해주는 문법으로, typealias 키워드를 사용하여 정의합니다. 타입 알리어스를 사용하면 길고 복잡한 형태의 타입 표현도 짧게 줄일 수 있어 전체적으로 소스 코드가 간결해지는 효과를 가져올 수 있습니다.</p>
<p><br></p>
<p>사용 방법도 간단합니다. 타입 알리어스를 정의하고 나면 컴파일러는 새로운 타입 이름을 타입 표현과 동일하게 간주합니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> infoResult = (<span class="type">Int</span>, <span class="type">Character</span>, <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUserInfo</span><span class="params">()</span></span> -&gt; infoResult&#123;</span><br><span class="line">    <span class="keyword">let</span> gender: <span class="type">Character</span> = <span class="string">"M"</span></span><br><span class="line">    <span class="keyword">let</span> height = <span class="number">100</span></span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"꼼꼼한 재은씨"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (height, gender, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info = getUserInfo()</span><br><span class="line">info.<span class="number">0</span></span><br><span class="line">info.<span class="number">1</span></span><br><span class="line">info.<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>함수에 튜플을 활용하는 예를 몇 가지 케이스별로 살펴보았습니다. 튜플이라는 타입의 단조로움과는 달리 튜플을 활용하는 방법이 상당히 많은 것을 잘 알았을 겁니다. 이처럼 함수에 튜플을 활용하면 코드를 쉽게 처리할 수 있어 활용도가 무척 높습니다. </p>
<p><br><br></p>
<h4 id="매개변수"><a href="#매개변수" class="headerlink" title="매개변수"></a>매개변수</h4><p>스위프트에서는 함수를 정의할 때 매개변수를 용도에 따라 두 가지로 분리할 수 있습니다. 내부 매개변수와 외부 매개변수가 그것이죠. 외부 매개변수는 함수를 호출할 때 인자값에 대한 레이블 역할을 하며, 동시에 함수의 식별자 일부로 사용되기도 합니다. 반면 내부 매개변수는 입력된 인자값을 함수 내부에서 참조하기 위해 사용하는 변수입니다. 함수의 범위 내에서는 내부 매개변수를 일반 변수처럼 사용하여 인자값을 얼마든지 참조할 수 있죠. 사실 정확하게 말하자면 변수가 아니라 상수입니다.</p>
<p><br></p>
<p>외부 매개변수를 사용하지 않은 일반 함수입니다. 이 함수에는 name과 msg라는 두 개의 매개변수가 정의되어 있죠. 매개변수가 나누어져 있지 않을 때에는 그냥 매개변수명을 인자 레이블로 사용하면 되므로 호출 구문에는 name, msg를 인자 레이블로 붙여주어야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(name: String, msg: String)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name)님, \(msg)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printHello(name: <span class="string">"홍길동"</span>, msg: <span class="string">"안녕하세요"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이제 변화를 주어, 외부 매개변수를 지정해 보겠습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(to name: String, welcomeMessage msg: String)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name)님, \(msg)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printHello(to: <span class="string">"홍길동"</span>, welcomeMessage: <span class="string">"안녕하세요"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이 함수는 여전히 name과 msg라는 두 개의 매개변수를 사용합니다. 하지만 외부 매개변수인 to, welcomeMessage가 추가되면서 name과 msg는 내부 매개변수가 되었습니다. 외부 매개변수가 정의되어 있지 않을 때에는 함수를 호출할 때 이 매개변수를 사용ㅎ야 하지만, 지금은 각각의 매개변수 앞에 외부 매개변수가 추가된 상태이므로 이를 사용하여 호출해야 합니다. 물론 이 to와 welcomeMessage라는 매개변수명은 어디까지나 외부에서 호출할 때 사용하는 이름에 지나지 않습니다. 함수 내부에서 인자값을 받아 사용할 때는 내부 매개변수명이 그대로 사용됩니다.</p>
<p><br></p>
<p>외부 매개변수를 따로 지정할 경우에는 함수의 이름 변화에도 주의해야 합니다. 기존 매개변수명이 아닌, 따로 지정된 외부 매개변수명이 함수 이름에 사용되기 때문이죠. 외부 매개변수의 사용을 달가워하지 않는 사람들을 위해 함수의 호출 시 매개변수를 생략할 수 있는 옵션도 있습니다. 함수 정의 구문에서 외부 매개변수 자리에 언더바를 넣어주면 함수를 호출할 때 매개변수를 사용하지 않아도 됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(<span class="number">_</span> name: String, <span class="number">_</span> msg: String)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name)님, \(msg)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>함수의 외부 매개변수명이 들어갈 자리에 대신 언더바를 사용했습니다. 스위프트에서 언더바는 대부분 문법은 적용하되 사용하지 않는다, 생략하겠다라는 의미로 많이 사용됩니다. 튜플의 각 아이템을 받는 개별 변수를 선언할 때도 굳이 받고싶지 않은 아이템의 경웅 언더바로 변수를 대체했던 기억이 날 겁니다. 그와 유사합니다. 외부 매개변수명 자리에 언더바를 사용하면 내부 매개변수와 외부 매개변수를 분리하지만 외부 매개변수명을 사용하지는 않겠다라는 뜻이 되어 매개변수를 생략하고 호출할 수 있습니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printHello(<span class="string">"홍길동"</span>, <span class="string">"안녕하세요"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>인자값 앞에 붙던 매개변수명이 사라지고 다른 언어에서처럼 단순히 인자값만을 이용해서 호출할 수 있게 되었습니다. 이제는 함수 호출 시 매개변수명을 붙이려고 하면 오히려 오류가 발생합니다. 매개변수가 여러 개일 때는 일부만 매개변수를 생략할 수도 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(<span class="number">_</span> name: String, welcomeMessage msg: String)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name)님, \(msg)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printHello(<span class="string">"홍길동"</span>, welcomeMessage: <span class="string">"안녕하세요"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>맨 앞의 매개변수를 생략한 이 구조는 코코아 터치 프레임워크에서 굉장히 많이 사용되는 방식입니다. 매개변수가 생략될 경우, 함수의 이름에도 변화가 생깁니다. 외부 매개변수가 사용될 자리에 대신 언더바가 들어갔으므로, 함수명 역시 외부 매개변수 자리에 언더바를 넣어 표시해 주어야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printHello(<span class="number">_</span>:<span class="number">_</span>:)</span><br><span class="line">printHello(to:<span class="number">_</span>:)</span><br><span class="line">printHello(<span class="number">_</span>:welcomeMessgae:)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>스위프트 언어의 특징이라 할 수 있는 외부 매개변수명은 매개변수명이 내부와 외부에서 바라보는 의미가 달라 외부와 내부로 구분하여 사용할 필요가 있을 때, 혹은 내부 매개변수명을 외부로 공개하기를 원치 않을 때 사용됩니다. 또 내부 매개변수명이 너무 길어서 호출 과정이 불편해질때도 사용됩니다. 하지만 가장 큰 목적은 뭐니뭐니해도 오브젝티브-C와의 호환성 때문이라고 할 수 있습니다.</p>
<p><br></p>
<h4 id="가변-인자"><a href="#가변-인자" class="headerlink" title="가변 인자"></a>가변 인자</h4><p>일반적으로 함수는 미리 정의된 형식과 개수에 맞는 인자값만 처리하지만, 때에 따라서는 가변적인 개수의 인자값을 입력받아야 할 때도 있습니다. 스위프트에서는 매개변수명 다음에 … 연산자를 추가하여 개수를 제한하지 않고 인자값을 입력받으며, 입력된 인자값을 배열로 저장합니다. 함수의 실행 블록 내에서 for~in 구문을 사용하면 입력된 모든 인자값을 순서대로 읽어 들일 수 있죠. 다음 예제를 보면서 개수의 제한 없이 점수를 입력받아 평균값을 산출하는 함수를 구현해봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">avg</span><span class="params">(score: Int...)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> score&#123;</span><br><span class="line">        total += r</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">Double</span>(total) / <span class="type">Double</span>(score.<span class="built_in">count</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(avg(score: <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>))  <span class="comment">// 25.0</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>매개변수 score는 가변 인자로 설정된 Int 타입입니다. 여기에 저장된 값은 배열로 처리됩니다. 따라서 for~in 구문에 넣고 순회 탐색을 처리하면 입력된 전체 인자값을 읽어 들일 수 있죠. 이 값들을 순회하면서 점수 합계에 더하고, 최종적으로 더한 값을 score 배열의 크기로 나누어 평균을 구합니다. 이때 total 변수와 배열의 크기는 모두 정수이므로 형변환 없이 그대로 계산하면 정수값으로 계산됩니다. 이를 방지하기 위해 Double 타입의 실수로 형변환을 해준 다음 평균을 구하는 연산을 수행하는 것이 위 예제의 내용입니다. 이처럼 가변 인자값은 입력 개수를 특정할 수 없는 형태의 매개변수에 사용됩니다.</p>
<p><br><br></p>
<h4 id="기본값을-갖는-매개변수"><a href="#기본값을-갖는-매개변수" class="headerlink" title="기본값을 갖는 매개변수"></a>기본값을 갖는 매개변수</h4><p>함수의 매개변수에는 유용한 기능이 있는데, 바로 기본값을 지정할 수 있다는 것입니다. 스위프트는 함수 호출할 때 반드시 직접 입력받아야 하는 값이 아니라면 인자값을 생략할 수 있도록, 함수 정의 시 매개변수에 기본 값을 지정할 수 있는 문법을 제공합니다. 이렇게 작성된 매개변수는 호출 시 인자값을 생략할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기본값이 지정된 함수</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(message: String, newline: Bool = <span class="literal">true</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> newline == <span class="literal">true</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(message, <span class="literal">true</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(message, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>작성된 echo 함수는 첫 번째 인자값으로 출력할 메시지를 입력받고, 두 번째 인자값으로 줄 바꿈 처리 여부를 결정합니다. 그런데 대부분 특별한 경우가 아니라면 기본적인 내용이 출력되고 난 다음 줄 바꿈 처리가 되기를 기대합니다. 이 때문에 줄 바꿈 여부에 대한 두 번째 인자값은 매번 똑같은 값을 넣어주어야 하는, 거추장스러운 인자값입니다. 이런 경우 두 번째 인자값에 기본값을 할당해주면 일반적인 출력 구문을 원할 때 단순히 출력할 메시지만 입력해주면 되고, 굳이 줄 바꿈을 하지 않고자 할 경우에만 두 번째 인자값에 false를 할당해주면 됩니다. 두 번째 인자값을 생략하여 호출하면 기본값 true가 두 번째 매개변수에 할당됩니다. 만약 두 번째 인자값에 명시적으로 false를 할당해주었다면 줄 바꿈 처리가 되지 않을 겁니다.</p>
<p><br><br></p>
<h4 id="매개변수의-수정"><a href="#매개변수의-수정" class="headerlink" title="매개변수의 수정"></a>매개변수의 수정</h4><p>고백할 것이 있습니다. 지금까지 함수를 설명하면서 매개변수라는 단어를 여러 번 사용했는데요. 이 단어에는 약간의 문제가 있습니다. 변수는 원래 마음대로 값을 수정할 수 있어야 하지만, 매개변수에 입력된 인자값을 함수 내에서 수정하려고 하면 오류가 발생하거든요. 이것은 스위프트에서 함수의 인자값이 변수가 아니라 상수로 정의되었기 때문으로, 정확한 표현은 매개상수라고 해야 맞습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 입력받은 값을 +1 하여 리턴해주는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementBy</span><span class="params">(base: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    base += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Left side of mutating operator isn't mutable: 'base' is a 'let' constant</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">이 함수는 입력받은 인자값을 base라는 정수 타입의 매개변수에 할당하고, 이 값을 += <span class="number">1</span> 연산 처리하여 반환합니다. += <span class="number">1</span> 연산은 앞에서 배운 바와 같이 그 자신의 값에 <span class="number">1</span>을 더한 다음 그 자신에게 다시 할당하는 연산입니다. 여기서 보여주고자 하는 것은 입력된 인자값에 대한 변경이 일어난다는 점입니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">오류 메시지를 해석해보면 <span class="string">"base는 '상수'로 정의되었으므로 왼쪽 수정 연산자가 값을 변경할 수 없다."</span>는 뜻입니다. 이처럼 함수의 인자값은 함수 내부에서 변수가 아니라 상수임에 주의해야 합니다. 인자값에 값을 새로 할당하거나 수정하는 구문을 작성해서는 안 된다는 거죠. 이는 변수를 함수의 인자값으로 대입해 준 경우도 마찬가지입니다. 인자값으로 전달된 값이 변수더라도 실제로는 값의 복사를 통해 상수가 새로 정의된 다음 전달됩니다. 변수 자체가 전달되는 것이 아니라 값만 전달된다는 겁니다. 그것도 원본이 아니라 복사된 값으로 말입니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">결론적으로 함수에 입력된 인자값은 함수 내부에서 항상 상수로 정의됩니다. 인자값을 변경할 수는 없습니다. 이런 사실들을 종합해보면 상수로서의 특징을 정확히 표현하기 위해 스위프트에서는 '매개상수'라는 단어를 사용해야 합니다. 스위프트에서 매개변수라고 일컫는 것은 특별한 언급이 없는 한 상수로 받아들이면 됩니다. 그런데 뜬금없이 지금 시점에서 이런 고백을 왜 했을까요? 그것은 상수로 정의되는 함수의 인자값이라 할지라도 내부에서 인자값을 수정하는 방법이 있다는 것을 설명하기 위해서입니다. 방법은 단순합니다. 기본적으로 매개변수와 동일한 이름으로 변수를 정의하고 매개변수의 값을 대입해 주면 됩니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementBy</span><span class="params">(base: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base = base</span><br><span class="line">    base += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>앞에서 오류가 발생했던 함수에서 매개변수의 이름과 동일한 변수 base를 정의하고, 여기에 매개변수를 대입하는 구문이죠. 이렇게 동일한 이름의 변수를 작성해서 값을 대입하고 나면, 이후로 base라는 이름의 호출은 모두 매개변수 base가 아니라 변수 base를 가리키게 됩니다. 여기에는 값을 수정하는 기존 구문을 그대로 사용해도 아무런 문제가 없습니다. 그저 변수의 값을 변경하는 것일 뿐이니까요.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">descAge</span><span class="params">(name: String, <span class="number">_</span> paramAge: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = name</span><br><span class="line">    <span class="keyword">var</span> paramAge = paramAge</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 입력된 값을 변경합니다.</span></span><br><span class="line">    name = name + <span class="string">"씨"</span></span><br><span class="line">    paramAge += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(name)의 내년 나이는 \(paramAge)세입니다."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>앞의 예제와 비슷하지만 이번에는 매개변수가 두 개입니다. 이 경우에도 크게 다른 점은 없습니다. 각각의 매개변수에 대해 변수화하는 구문을 추가해주면 되기 때문입니다. </p>
<p><br><br></p>
<h4 id="InOut-매개변수"><a href="#InOut-매개변수" class="headerlink" title="InOut 매개변수"></a>InOut 매개변수</h4><p>스위프트에서는 함수 내부에서 발생하는 사건은 함수 외부에 영향을 미칠 수 없습니다. 함수 내부에도, 외부에도 동일한 인자값이 존재하고 있지만 함수 내부에서 변경된 인자값은 4차원 공간 바깥에 있는 주인공의 과거 존재처럼 함수 외부의 인자값에는 아무런 영향도 끼칠 수 없습니다. 단순히 같은 값을 가지고 있을뿐, 둘은 단절된 서로 다른 객체이기 때문입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cnt = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">autoIncrement</span><span class="params">(value: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = value</span><br><span class="line">    value += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(autoIncrement(value: cnt))  <span class="comment">// 함수 내부의 value 변수값: 31</span></span><br><span class="line"><span class="built_in">print</span>(cnt) <span class="comment">// 외부에서 정의된 cnt 변수값: 30</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>외부에서 입력한 인자값이 직접 함수 내부로 전달되는 것이 아니라 그 값이 복사된 다음 전달됩니다. 다시 말해, 인자값으로 전달된 cnt와 매개변수 value는 서로 다른 변수입니다. 하지만 함수에서도 내부에서 수정된 인자값이 외부까지 영향을 미칠 수 있는 방법이 존재합니다. 물론 반환값을 이용하지 않고 말입니다. 이를 위해 사용되는 키워드가 inout입니다. 이 키워드를 이용하면 스위프트에서는 함수 내부에서 수정된 인자값을 함수 외부까지 전달할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(paramCount: <span class="keyword">inout</span> Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    paramCount += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> paramCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>inout 키워드가 붙은 매개변수는 인자값이 전달될 때 새로운 내부 상수를 만들어 복사하는 대신 인자값 자체를 함수 내부로 전달합니다. 함수 내부에서 사용하는 매개변수명이 외부의 변수명과 다를지라도 마찬가지입니다. inout 키워드가 붙은 매개변수는 인자값으로 사용된 변수와 동일한 객체입니다. 단순히 값만 똑같은 짝퉁 변수와는 다르죠.</p>
<p><br></p>
<p>사실 inout 키워드의 정확한 의미는 값 자체를 전달하는 것이 아니라 값이 저장된 메모리 주소를 전달한다는 의미입니다. 인자값에 할당된 데이터가 저장되어 있는 메모리 주소를 함수에 전달하는 것이죠. C를 해본 분들이라면 ‘어? 포인터인데.’라고 생각하실지도 모르겠네요. 맞습니다. C에서의 포인터와 유사합니다. 이 때문에 inout 키워드가 사용된 함수는 호출 시 주의가 필요합니다. 인자값을 전달할 때 값이 아닌 주소를 전달해야 하거든요. 따라서 inout 매개변수에 들어갈 인자값에는 주소 추출 연산자 &amp;을 붙여주어야 정상적으로 전달할 수 있습니다. 이 연산자는 변수나 상수 앞에 붙어서 값이 저장된 메모리 주소를 읽어오는 역할을 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(foo(paramCount: &amp;<span class="built_in">count</span>))  <span class="comment">// 함수 내부의 paramCount 변수값: 31</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">count</span>)  <span class="comment">// 외부에서 정의된 count 변수값: 31</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>함수를 호출하는 구문입니다. 변수 count가 인자값으로 사용된 부분에 주소 추출 연산자인 &amp; 연산자가 붙어 있죠. 함수를 호출할 때 인자값으로 사용된 변수 앞에 &amp;를 붙이면 값이 아닌 주소가 전달되며, 이 주소를 읽어 들이기 위해 함수에서는 매개변수에 inout 키워드가 추가된다고 보면 됩니다. 함수는 전달받은 메모리 주소를 통해 외부의 변수에 직접 접근할 수 있고, 값을 변경하면 그 결과가 외부 변수에도 바로 반영됩니다. 이처럼 주소를 전달하는 것을 프로그래밍 용어로 참조에 의한 전달이라고 하며, 기존처럼 값을 복사하여 전달하는 것을 값에 의한 전달이라고 합니다.</p>
<p><br></p>
<h4 id="값에-의한-전달과-참조에-의한-전달"><a href="#값에-의한-전달과-참조에-의한-전달" class="headerlink" title="값에 의한 전달과 참조에 의한 전달"></a>값에 의한 전달과 참조에 의한 전달</h4><p>값에 의한 전달은 인자값을 전달하면 내부적으로 값의 복사가 이루어져서 복사된 값을 이용하여 구문을 실행하는 것을 이야기합니다. 지금까지 우리가 대부분 사용해왔던 방식이죠. 이 방식은 내부적으로 복사를 통해 생성된 새로운 변수나 상수를 이용하여 함수의 기능을 실행하므로 인자값의 수정이 발생하더라도 원본 데이터에는 영향을 미치지 않습니다.</p>
<p><br></p>
<p>우리가 많이 사용하는 String, Int, Double, Float, Bool 등 기본 자료형들 대부분이 이처럼 값에 의한 전달 방식으로 인자값을 전달합니다. 원본 값은 그대로 둔 채 복사된 새로운 값이 전달되는 것이죠. 따라서 우리는 인자값을 내부에서 수정하더라도 외부 값의 변경을 고려할 필요가 없습니다. 값이 전달되는 순간 내부 인자값과 외부 인자값은 서로 상관없는 남남이 되기 때문입니다.</p>
<p><br></p>
<p>반면 참조에 의한 전달은 내부적으로 복사가 이루어지는 대신 값이 저장된 주소가 전달됩니다. 인자값을 저장하고 있는 객체 자체가 전달된다고 할 수 있죠. 이 방식은 외부의 인자값을 직접 참조하므로 함수 내부에서 인자값이 수정되면 그 결과가 외부 인자값 원본에도 고스란히 반영됩니다.</p>
<p><br></p>
<p>이처럼 주소를 직접 전달하는 참조에 의한 전달은 함수에서 inout 키워드를 사용했을 때 적용되지만, 예외적으로 클래스로 구현된 인스턴스는 inout 키워드를 사용하지 않아도 항상 참조에 의해 전달됩니다. 따라서 함수의 인자값으로 전달한 클래스 인스턴스는 함수 내부에서 값이 수정되면 원본 객체에도 영향을 미치므로 주의해야 합니다. </p>
<p><br></p>
<p>inout 키워드가 붙은 매개변수에 인자값을 입력할 때는 인자값 객체의 종류에 주의해야 합니다. 함수 내부에서 원본 객체에 직접 값을 수정할 수 있어야 하므로 상수는 전달 대상이 될 수 없습니다. 같은 이유에서 리터럴 역시 전달 대상이 될 수 없습니다. 오직 변수만 인자값으로 사용할 수 있습니다.</p>
<p><br></p>
<p>매개변수와 관련된 것은 아니지만, 참조에 의한 전달 방식이 적용되는 경우가 한 가지 더 있습니다. 변수의 범위 특성을 이용하는 것으로, 일반적으로 상위 범위에 정의된 변수는 하위 범위에서도 사용할 수 있다는 특성을 가집니다. 이 점을 이용하여 함수 외부에서 정의된 변수를 함수 내부에서 가져다 사용하면 inout 키워드를 사용하지 않고도 외부의 변수를 내부에서 바로 참조할 수 있을 뿐만 아니라 함수 내부에서 값을 변경하면 함수 외부에도 그대로 반영됩니다.</p>
<p><br><br></p>
<h4 id="변수의-생존-범위와-생명-주기"><a href="#변수의-생존-범위와-생명-주기" class="headerlink" title="변수의 생존 범위와 생명 주기"></a>변수의 생존 범위와 생명 주기</h4><p>범위를 기준으로 변수를 구분해 보면 크게 전역 변수와 지역 변수로 나눌 수 있습니다. 전역 변수는 프로그램의 최상위 레벨에서 작성된 변수를 의미합니다. 이 변수는 일반적으로 프로그램 내 모든 위치에서 참조할 수 있으며, 특별한 경우를 제외하면 프로그램이 종료되기 전까지는 삭제되지 않습니다.</p>
<p><br></p>
<p>반면 로컬 변수라고도 하는 지역 변수는 특정 범위 내에서만 참조하거나 사용할 수 있는 변수를 의미합니다. 조건절이나 함수 구문 등 특정 실행 블록 내부에서 선언된 변수는 모두 지역변수이며 선언된 블록 범위 안에서만 이 변수를 참조할 수 있습니다. 지역 변수는 선언된 블록이 실행되면서 생겨났다가 실행 블록이 끝나면 제거됩니다. 이를 변수의 생명 주기라고 합니다.</p>
<p><br></p>
<p>do 블록은 일반적으로 오류 처리를 위해 do~catch 구문 형식으로 사용되지만, 단독으로 사용되었을 때에는 단순히 실행 블록을 구분하는 역할을 합니다. do 블록은 중첩해서 사용할 수 있는데, 이때 내부에 중첩된 do 블록을 기준으로 실행 블록은 단계화됩니다. 내부에 더 많이 중첩되어 있을수록 더 하위 블록입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ccnt = <span class="number">3</span></span><br><span class="line">        ccnt += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(ccnt)</span><br><span class="line">    &#125;</span><br><span class="line">    ccnt += <span class="number">1</span>  <span class="comment">// Use of unresolved identifier 'ccnt'</span></span><br><span class="line">    <span class="built_in">print</span>(ccnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>선언된 블록보다 하위 블록에서 변수를 사용하는 과정을 단순히 하나의 코드 내에서 변수를 사용하는 것으로 여길 수도 있겠으나, 자세히 들여다보면 하나의 블록에서 다른 블록으로 참조에 의한 전달 과정이 일어나는 것입니다. 이를 위해 변수의 주소값이 필요하죠. 만약 변수가 초기화되지 않았다면 메모리를 할당받지 못한 상태이므로 주소값도 존재하지 않습니다. 따라서 오류가 발생합니다. </p>
<p><br></p>
<p>함수는 실행 블록을 가지고 있는 객체입니다. 때문에 앞서 설명한 범위가 그대로 적용됩니다. 함수 내에서 선언된 변수는 함수의 실행 블록 안에서만 존재하므로 이 변수에 직접 접근할 수 있는 조건 또한 함수의 실행 블록 내로 제한됩니다. 함수의 실행 블록 내부에 하위 블록이 존재하면 이 하위 블록 역시 함수의 실행 블록 내에 있으므로 변수에 접근할 수 있지만, 함수를 벗어난 블록에서는 변수에 접근할 수 없습니다.</p>
<p><br></p>
<p>전역 변수는 이와 반대입니다. 전역 변수는 최상위 블록에서 선언된 변수이므로 그보다 하위 블록인 함수 내부에서도 얼마든지 접근할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()  <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>인자값을 받지 않는 foo() 함수가 정의되었습니다. 이 함수는 내부에서 count 변수를 1만큼 증가하는 처리를 하고 있죠. count 변수는 상위 블록인 전역 범위에서 선언된 변수입니다. 상위 블록에서 정의된 변수가 하위 블록에서 사용될 때는 값이 참조 방식으로 전달되기 때문에 블록 내부에서 값을 변경하면 외부에도 그대로 적용됩니다. 따라서 함수 내에서는 전역 변수의 값에 접근할 수도 있고, 수정할 수도 있습니다. 이번에는 전역 변수와 지역 변수가 겹칠 때는 어떤 현상이 발생하는지 알아봅시다. 다음은 조금 전의 foo 함수 내부에 전역 변수와 이름 및 타입이 동일한 매개변수를 정의한 예제입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="built_in">count</span></span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="built_in">count</span>: <span class="built_in">count</span>))  <span class="comment">// 함수 내부의 count 변수값 : 31</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">count</span>)  <span class="comment">// 외부에서 정의된 count 변수값 : 30</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>함수 외부에서 count 변수는 전역 범위로 선언되어 있습니다. 그리고 함수 내부에서도 count가 매개변수로, 그리고 지역 변수로도 선언되어 있습니다. foo 함수는 내부적으로 인자값을 1 증가시킨 다음 반환하는 역할을 하죠. 이 함수의 출력 결과는 예상할 수 있는 것처럼 31입니다. 30이라는 값이 입력되어 1만큼 증가한 다음 반환되었으므로 당여한 결과입니다. 그런데 전역 변수 count를 출력해보면 값이 일치하지 않습니다. 값이 바뀌지 않은 그대로이죠.</p>
<p><br></p>
<p>이것으로 보아 스위프트에서 함수의 외부와 내부에 각각 같은 이름의 변수가 존재하면 내부에서 선언된 변수는 외부와 상관없이 새롭게 생성된다는 것을 알 수 있습니다. 그렇지 않다면 외부 변수의 값도 함께 변경되었을 테니까요. 실제로 함수의 외부 영역과 내부 영역에 같은 이름의 변수가 정의되어 존재한다면 두 변수는 동일한 변수가 아닙니다. 위의 예에서 내부 영역에 정의된 count 변수는 지역 변수로서, 외부에서 정의된 count 변수와는 엄연히 다른 객체입니다. 또한, 외부와 내부에서 같은 이름의 변수가 선언되면 변수 사용의 우선순위에 따라 외부 변수가 아닌 내부 변수를 사용하게 됩니다. 이는 블록 내에서 적용되는 변수 우선순위 규칙과 관련됩니다. 함수처럼 블록 내부에서 변수나 상수가 사용될 경우 컴파일러는 이 변수가 정의된 위치를 다음의 순서에 따라 검색합니다.</p>
<p><br></p>
<p>가장 먼저 함수 내부에서 이 변수가 정의되어 있는지 검색하여 정의되어 있다면 이 변수의 값을 읽어오고, 없으면 상위 범위인 함수 외부로 이동합니다. 함수 외부 범위에서 이 변수가 정의되어 있는지 검색하고 있다면 이 변수를 사용하지만 여기에도 없다면 그보다 상위 블록으로 검색 범위를 확장합니다. 이번에도 변수가 발견되지 않으면 글로벌 범위까지 확장하여 변수를 검색합니다. 이처럼 검색 범위를 넓혀 최상위 범위까지 검색했음에도 정의된 변수를 찾을 수 없을 경우 컴파일러는 최종적으로 존재하지 않는 변수라는 오류를 발생시킵니다.</p>
<p><br><br></p>
<h4 id="일급-객체로서의-함수"><a href="#일급-객체로서의-함수" class="headerlink" title="일급 객체로서의 함수"></a>일급 객체로서의 함수</h4><p>스위프트는 객체지향 언어이자 동시에 함수형 언어입니다. 함수형 언어를 학습하게 되면 반드시 일급 객체라는 용어를 접하게 되는데요. 이는 프로그램 언어 안에서 특정 종류의 객체가 일급의 지위를 가지는가에 대한 의미입니다.</p>
<p><br></p>
<p>객체가 다음의 조건을 만족하는 경우 이 객체를 일급 객체로 간주합니다.</p>
<p><br></p>
<ul>
<li>객체가 런타임에도 생성이 가능해야 한다.</li>
<li>인자값으로 객체를 전달할 수 있어야 한다.</li>
<li>반환값으로 객체를 사용할 수 있어야 한다.</li>
<li>변수나 데이터 구조 안에 저장할 수 있어야 한다.</li>
<li>할당에 사용된 이름과 관계없이 고유한 구별이 가능해야 한다.</li>
</ul>
<p><br></p>
<p>함수가 이런 조건을 만족하면 이를 일급 함수라고 하고 그 언어를 함수형 언어로 분류합니다. 즉, 함수형 언어에서는 함수가 일급 객체로 대우받는다는 뜻입니다. 함수가 일급 객체로 대우받는다면 런타임에도 함수의 생성이 가능하고, 매개변수나 반환값으로 함수를 전달할 수 있으며, 함수를 변수나 데이터 구조 안에 저장할 수 있을 뿐만 아니라 함수의 이름과 관계없이 고유한 구별이 가능합니다. 이것들은 일급 객체가 되기 위한 조건이기 때문입니다. 일급 함수가 쉽게 와 닿지 않는다면, 자바에서 클래스의 특성을 떠올려보시기 바랍니다. 자바에서는 클래스가 일급의 지위를 가지니까요.</p>
<p><br></p>
<ul>
<li>변수나 상수에 함수를 대입할 수 있음</li>
</ul>
<p><br></p>
<p>일급 함수의 특성 중에서 처음으로 알아볼 특성은 변수나 상수에 함수를 대입할 수 있다는 점입니다. 변수나 상수에 함수를 대입한다는 것은 말 그대로 함수 자체를 변수에 집어넣는다는 뜻입니다. 이렇게 함수가 대입된 변수나 상수는 함수처럼 실행할 수도 있고, 인자값을 입력받을 수도 있습니다. 반환값을 가질 수도 있죠. </p>
<p><br></p>
<p>일급 함수에서 말하는 변수나 상수에 함수를 대입한다라는 의미는 이것과 다릅니다. 함수의 결과값을 대입하는 것이 아니라 함수 자체를 대입하는 것이니까요. 잠깐 언급했듯이 함수 자체를 변수에 할당하면 변수도 함수처럼 인자값을 받아 실행이 가능하고, 값을 반환할 수도 있습니다. 함수를 대입한 변수가 함수처럼 실행된다는 것은 우리가 학습한 함수 호출 형식이 확장됨을 의미합니다. 지금까지 우리는 함수를 호출할 때 함수의 이름 다음에 함수 호출 연산자를 붙여야 했습니다. 그러나 일급 함수의 특성에 따라 우리는 굳이 함수의 이름이 아니더라도 함수가 할당된 변수라면 그 변수에 함수 호출 연산자 ()를 붙여서 함수를 호출할 수 있습니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(base: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"결과값은 \(base + 1)입니다"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f1 = foo(base: <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(f1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn2 = foo  <span class="comment">// fn2 상수에 foo 함수가 할당됨</span></span><br><span class="line">fn2(<span class="number">5</span>)  <span class="comment">// "결과값은 6입니다"</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>상수 fn2에 foo 함수를 대입하고 있습니다. 함수 자체가 대입되었으므로 이제 fn2는 foo와 이름만 다를 뿐 같은 인자값, 같은 기능, 같은 반환값을 가지는 함수가 됩니다. 따라서 fn2에 함수 호출 연산자인 ()와 인자값 5를 넣어 호출할 수도 있고 그 결과값을 받을 수도 있습니다. fn2는 함수니까요.</p>
<p><br></p>
<p>변수나 상수에 함수를 대입할 때는 함수가 실행되는 것이 아니라 함수라는 객체 자체만 대입됩니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(base: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"함수 foo가 실행됩니다"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"결과값은 \(base + 1)입니다"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn3 = foo(base: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>앞서 작성했던 함수 foo에서 내부에 출력 구문을 추가하였습니다. 이 함수가 실행되면 “함수 foo가 실행됩니다”라는 구문이 출력되도록 말이죠. 이 함수의 결과값을 상수에 할당하였습니다. 함수의 결과값을 fn3에 대입하는 과정에서 함수가 실행되었습니다. 함수 내부에 작성해둔 출력 구문이 플레이그라운드의 콘솔에 찍히는 것을 보면 알 수 있죠. 이처럼 함수의 결과값을 대입할 때는 함수가 실행됩니다. 하지만 함수 자체를 대입하는 구문은 다릅니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn4 = foo</span><br><span class="line"><span class="comment">// 출력결과 없음</span></span><br><span class="line"></span><br><span class="line">fn4(<span class="number">7</span>)  <span class="comment">// 함수 foo가 실행됩니다</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>상수 fn4에 foo 함수를 대입하는 과정에서는 아무런 값도 출력되지 않습니다. foo 함수가 실행되지 않았다는 뜻이죠. 함수를 할당받은 상수 fn4가 인자값 7을 넣어 함수를 실행하면 그때서야 메시지가 출력됩니다. 이번에는 foo 함수가 실행되었다는 것을 알 수 있습니다.</p>
<p><br></p>
<p>이처럼 단순히 함수를 변수나 상수에 대입하는 과정에서는 함수가 실행되지 않습니다. 함수 객체 자체만 전달되기 때문입니다. 함수가 대입된 변수나 상수를 함수처럼 호출하면 그때 비로소 함수가 실행됩니다. 이것이 함수 결과값을 대입하는 것과 함수 자체를 대입하는 것의 차이점이라고 할 수 있습니다.</p>
<p><br></p>
<p>함수를 대입하기 위해 알아야 할 것이 하나 더 있습니다. 바로 타입(Types)입니다. 변수에 함수를 대입하면 그 변수는 일반적인 문자열, 정수, 배열 또는 딕셔너리와는 전혀 다른 타입이 됩니다. 이 타입을 함수 타입(Function Types)이라고 하죠. 함수 타입은 함수의 형태에 따라 셀수 없을 만큼 다양한 구조를 가집니다. 복잡하게 이해하면 어렵지만, 간단하게 생각하면 됩니다. 변수에 정수를 대입하면 Int 타입이, 문자열을 대입하면 String 타입이 되는 것처럼, 변수에 함수를 대입하면 함수 타입이 되는 겁니다.</p>
<p><br></p>
<p>함수 타입은 일반적으로 함수의 형태를 축약한 형태로 사용하는데, 이때 함수의 이름이나 실행 내용 등은 함수 타입에서는 아무런 의미가 없으므로 생략할 수 있습니다. 함수 타입에서 필요한 것은 단지 어떤 값을 입력받는지와 어떤 값을 반환하는지 뿐입니다. 실제 함수를 보면서 함수 타입에 대한 내용을 자세히 익혀 봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boo</span><span class="params">(age: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(age)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>정수 인수를 받고 문자열 타입을 반환하는 boo(age:) 함수입니다. 이 함수를 함수 타입 형태로 표현하면 다음과 같습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(int) -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>앞서 설명한 것처럼 함수명, 매개변수명, 그리고 실행 내용에 해당하는 부분은 모두 생략된 형태입니다. 남아 있는 것은 Int 타입의 인자를 입력받는 것과 그 결과로 String 타입을 반환한다는 것 두 가지죠. 만약 이 함수를 상수에 할당한다면 이 상수의 타입 어노테이션을 포함한 할당 구문은 다음과 같습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn: (<span class="type">Int</span>) -&gt; <span class="type">String</span> = boo</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이번에는 두 개의 인자값을 받는 함수의 타입을 작성해봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boo</span><span class="params">(age: Int, name: String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(name)의 나이는 \(age)세 입니다."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>age라는 정수 값과 name이라는 문자열 값을 인자값으로 받는 boo 함수가 다시 작성되었습니다. 이 함수를 상수 s에 할당해 봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = boo</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>그런데, 우리가 지금 대입 구문에 사용한 boo라는 이름은 우리가 알고 있는 정확한 함수 식별자가 아닙니다. 정확한 식별자는 boo(age:name:)죠. 그래서 위 구문은 다음과 같이 함수 식별자를 대입해주는 구문으로 바꾸어 작성할 수도 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = boo(age:name:)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>boo와 boo(age:name:) 두 가지 모두 함수를 대입하는 구문에 사용해도 아무런 문제가 없습니다. 물론 둘 중에서 정확한 표현을 선택하라면 boo(age:name:)을 선택해야겠지만요. 그러면 boo는 뭘까요? 함수의 이름도 아닌 것이 왜 함수의 대입 구문에 사용해도 아무런 문제가 없는 것일까요?</p>
<p><br></p>
<p>이를 설명하려면 함수의 이름과 함수의 식별자를 구분하는 이야기를 다시 꺼내야 합니다. 앞에서 함수의 이름에 대해 배울 때, 인자 레이블까지 포함된 전체 이름을 함수의 식별자라고 부르고 함수의 이름과는 구분하는 것이 좋겠다고 설명한 적이 있는데요. 기억하나요? 바로 지금과 같은 경우 때문입니다. 만약 boo(age:name:)가 함수의 정확한 이름이라면, boo 만으로도 함수 대입이 가능한 위의 케이스를 설명할 방법이 없기 때문이죠. 이를 설명하기 위해서는 boo는 함수의 이름, boo(age:name:)은 함수의 식별자로 나누어 생각해 주어야 합니다. 물론 함수의 대입구문을 작성할 때는 함수의 이름이나 함수의 식별자 어느 것을 사용해도 됩니다.</p>
<p><br></p>
<p>정확하게는 boo는 매개변수를 제외한 함수의 이름이 boo인 모든 함수를 대변하고, boo(age:name:)은 함수의 이름이 boo이면서 매개변수가 각각 age, name인 함수를 가리킵니다. 따라서 함수의 이름은 조금 더 범용적으로 사용할 수 있는 여지가 있지만, 이로 인해 문제를 일으키기도 합니다. 주로 함수 타입에 대한 타입 어노테이션을 누락하는 경우인데요. 다음 예제를 살펴봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boo</span><span class="params">(age: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(age)"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boo</span><span class="params">(age: Int, name: String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(name)의 나이는 \(age)입니다"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let t = boo  // Ambiguous use of 'boo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 해결방법 1) 타입 어노테이션을 통해 입력받을 함수의 타입을 지정</span></span><br><span class="line"><span class="keyword">let</span> t1: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = boo</span><br><span class="line"><span class="comment">// 해결방법 2) 함수의 식별값을 통해 입력받은 정확한 함수를 지정</span></span><br><span class="line"><span class="keyword">let</span> t2 = boo(age:name:)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">앞에서 등장한 두 함수를 같은 자리에서 정의했습니다. 그리고 t 상수에 boo 함수를 대입하죠. 그러면 이때의 boo 함수는 위쪽일까요, 아래쪽일까요? 두 함수 모두 함수의 이름은 boo이지만, 뒤의 매개변수 차이 때문에 서로 다른 식별값을 가집니다. 따라서 boo로 대입하려면 둘 중 어느 함수를 가리키는 것인지 정확하게 판단할 수 없으므로 오류가 발생합니다. 이 오류를 방지하기 위해서는 대입 구문을 위의 두 가지 중 하나의 형태로 바꾸어 주어야 합니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">타입 어노테이션을 사용하는 경우에는 입력받을 값의 타입이 명확하기 때문에, boo가 가리키는 함수가 다소 불확실하더라도 컴파일러가 찾아서 대입할 수 있습니다. 마찬가지로 식별값을 통해 지정하는 경우도 정확한 함수를 찾아 대입할 수 있기 때문에 문제가 되지 않습니다. 가령, 다음과 같이 타입 어노테이션을 적절히 사용하면, 같은 함수 이름을 사용하여 대입하더라도 서로 다른 결과를 가져오기도 합니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="keyword">let</span> fn01: (<span class="type">Int</span>) -&gt; <span class="type">String</span> = boo <span class="comment">// boo(age:)</span></span><br><span class="line"><span class="keyword">let</span> fn02: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = boo <span class="comment">// boo(age:name:)</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>두 상수 fn01, fn02는 모두 boo라는 함수 이름으로 함수를 할당받고 있습니다. 하지만 타입 어노테이션의 차이로 인해, 각각 다른 함수가 대입됩니다. 먼저 fn01에 대입된 함수는 boo(age:)입니다. 타입 어노테이션이 가리키는 형식이 인자값이 하나인 함수이기 때문이죠. 반면에 fn02에 대입된 함수는 boo(age:name:)입니다. 타입 어노테이션이 Int, String 두 개의 인자값을 가진 함수를 가리키고 있기 때문입니다. 이처럼 동일한 함수 이름을 사용하여 대입하더라도 타입 어노테이션에 의해 대입되는 함수가 달라지기도 하므로 주의해야 합니다.</p>
<p><br></p>
<p>타입 어노테이션과 함수 이름의 조합으로 대입 구문을 구성하면 안 되는 경우도 있습니다. 동일한 함수 타입을 사용하지만 매개변수명이 서로 다른 함수가 이에 해당합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hoo</span><span class="params">(age: Int, name: String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(name)의 나이는 \(age)세 입니다"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boo</span><span class="params">(height: Int, nick: String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(nick)의 키는 \(height)입니다"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn03 = boo(age:name:)</span><br><span class="line"><span class="keyword">let</span> fn04 = boo(height:nick:)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>함수 타입을 표시할 때 반환값이 없는 경우에는 빈 괄호 대신 ‘Void’를 사용하여 명시적으로 ‘값이 없음’을 표시하기도 합니다. Void는 빈 튜플을 나타내는 값으로, 타입 알리어스로 정의된 단어입니다. 클래스나 구조체 등의 객체가 아닌 키워드임에 주의해야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Void</span> = ()</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 코드가 Void 키워드를 선언하는 스위프트 내부 코드입니다. typealias 키워드와 함께 선언된 Void에 빈 튜플을 의미하는 “()”이 대입되어 있죠. 이렇게 선언된 키워드 Void는 빈 괄호를 대신하여 사용할 수 있습니다. Void를 적용해보면 함수 타입은 다음과 같이 표현됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Int</span> -&gt; ()  =&gt; (<span class="type">Int</span>) -&gt; <span class="type">Void</span></span><br><span class="line">() -&gt; () =&gt; () -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>Void 키워드는 본래 빈 인자값의 표현에도 사용할 수 있었으나 4.0 버전부터는 반환 타입에만 사용할 수 있도록 제한되었습니다. 그러면 이렇게 새로 학습한 함수 타입을 직접 사용해보아야겠죠? 그래야 오래오래 머리에 남을테니 말입니다. 그래서 다음 절에서는 함수 타입을 충분히 사용할 수 있는 주제를 준비했습니다. 바로 일급 함수의 두 번째 특성, 함수의 반환 타입으로 함수를 사용하는 방법에 대해서입니다.</p>
<p><br></p>
<ul>
<li>함수의 반환 타입으로 함수를 사용할 수 있음</li>
</ul>
<p><br></p>
<p>일급 함수의 특성 중에서 두 번째로 학습할 부분은 함수의 반환 타입으로 함수를 사용할 수 있다는 특성입니다. 일급 객체로 대우받는 함수는 실행 결과로 정수, 실수, 문장열 등의 기본 자료형이나 클래스, 구조체 등의 객체를 반환할 수 있을 뿐만 아니라 함수 자체를 반환할 수도 있습니다. 함수가 함수를 반환한다는 의미를 알기 위해 다음 예제를 봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">desc</span><span class="params">()</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is desc()"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pass</span><span class="params">()</span></span> -&gt; () -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> desc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = pass()</span><br><span class="line"><span class="built_in">print</span>(p())</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>얼핏 보면 이해하기 힘든 구문일 수도 있으니 차근차근 살펴봅시다. 먼저 가장 위에 작성된 것은 desc 함수입니다. 같은 이름으로 여러 번 등장하고 있는 이 함수는 인자값 없이 문자열을 반환하는 함수 형식으로 정의되어 있습니다. 그 다음으로 작성된 것은 pass 함수입니다. 이 함수의 내부 블록을 살펴보면 다른 실행 구문 없이 desc라는 함수 자체를 반환하는 구문뿐입니다. 여기서 pass 함수의 반환 타입은 함수 타입인 () -&gt; String으로 정의됩니다. 이는 pass 함수가 desc 함수를 반환하기 때문으로, () -&gt; String은 desc 함수의 타입 표현에 해당합니다. desc 함수는 인자값 없이 문자열만 반환하고 있기 때문에 이를 함수 타입으로 표현하면 () -&gt; String 형식이 됩니다. 이 함수 타입의 표현이 pass 함수의 반환 타입으로 사용되고 있는 겁니다. </p>
<p><br></p>
<p>이어서 상수 p는 pass 함수의 실행 결과값을 할당받고 있습니다. 만약 pass 함수 자체를 할당받았다면 상수 p에 할당된 것은 pass 함수였겠지만, pass 함수의 실행 결과는 desc 함수이므로 상수 p에는 desc 함수가 할당됩니다. 이제 p 상수는 desc 함수나 마찬가지입니다. p에 함수호출 연산자를 붙여 실행하면 desc 함수를 실행하는 것이 되죠. 이러한 과정을 거쳐 p()의 실행 결과는”this is desc()”가 됩니다.</p>
<p><br></p>
<p>함수의 반환값이 함수일 경우, 아무래도 함수의 형식이 복잡해질 가능성이 큽니다. 가독성도 매우 떨어지죠. 이를 방지하기 위해 최근의 문법에서는 반드시 인자값 부분에 괄호를 통해 감싸주도록 강제하지만, 점점 더 복잡한 형태의 함수 타입을 사용할수록 형식을 분석하기 어려워질 겁니다. 이어서 함수의 반환 타입으로 함수를 사용하는 조금 복잡한 예제를 살펴보겠습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minus</span><span class="params">(a: Int, b:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">times</span><span class="params">(a: Int, b:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a: Int, b:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> b != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(<span class="number">_</span> operand: String)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> operand &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">        <span class="keyword">return</span> plus</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">        <span class="keyword">return</span> minus</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">        <span class="keyword">return</span> times</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">        <span class="keyword">return</span> divide</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> plus</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = calc(<span class="string">"+"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(calc(<span class="string">"+"</span>)(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>하나하나의 함수는 주석이 필요 없을 만큼 단순한 기능입니다. 각각 덧셈, 뺄셈, 곱셈, 나눗셈 연산을 수행하여 그 결과를 반환하는 함수들이죠. 나눗셈에서만 예외로 나눌 값이 0인 경우를 대비하여 guard 구문이 추가된 것을 제외하면 모든 함수의 구성이 거의 같습니다. 마지막으로 작성된 calc는 조금 다릅니다. 이 함수는 사칙연산의 연산자를 문자열 형식으로 입력받습니다. 이 인자값을 기준으로 switch 구문에서 각 인자값에 대응하는 함수를 반환하는 것이 calc 함수가 처리하는 내용입니다. 반환하는 함수의 인자값과 반환값은 모두 일치하며 이들 함수의 타입 표현식은 (Int, Int) -&gt; Int입니다. 함수 calc에 인자값으로 연산자를 입력하면 그에 해당하는 함수를 반환받을 수 있죠. 외부 매개변수를 언더바로 처리함으로써 함수 호출 시 인자 레이블을 생략할 수 있도록 해 놓은 것도 눈여겨볼 부분입니다.</p>
<p><br></p>
<p>“+” 문자열을 인자값으로 하여 함수를 실행한 결과, switch 구문의 패턴 비교에 의해 plus 함수가 반환됩니다. 이 함수가 상수 c에 할당되었으므로 이를 함수 호출 연산자로 실행하면 plus 함수가 실행됩니다. 결과값은 7이죠. 이처럼 함수의 실행 결과로 다른 함수를 반환할 수 있는 것이 일급 함수의 특성입니다. 이 특성은 중첩 함수(Nested Functions)를 학습할 때 다시 다룹니다.</p>
<p><br></p>
<ul>
<li>함수의 인자값으로 함수를 사용할 수 있음</li>
</ul>
<p><br></p>
<p>일급 함수는 반환값으로 함수를 사용할 수 있을 뿐만 아니라 다른 함수의 인자값으로 함수를 전달할 수 있는 특성도 있습니다. 일급 함수를 다루는 타 언어 중에서 특히 널리 알려진 언어로 자바스크립트가 있는데, 이 언어를 이용하여 웹 프로그래밍에서 Ajax 구현을 해보면 반드시 다루게 되는 개념으로 콜백 함수(Callback Function)가 있습니다. 콜백 함수는 특정 구문의 실행이 끝나면 시스템이 호출하도록 처리된 함수로서, 일반적으로 Ajax 통신을 위한 구문을 작성할 때 콜백 함수를 등록합니다. 콜백 함수 등록이란, 실행하고자 하는 구문을 담은 함수를 인자값으로 넣는 것을 의미하죠. 이때 사용되는 개념이 바로 일급 함수의 특성인 함수를 인자값으로 사용할 수 있다입니다.</p>
<p><br></p>
<p>함수를 인자값으로 전달할 때 그 함수는 하나의 타입이 됩니다. 따라서 함수를 입력받는 인자값은 함수 타입으로 정의되어야 합니다. 이 점을 제외하면 인자값으로 함수를 전달하는 방식에는 특별한 것이 없습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(param: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> param + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broker</span><span class="params">(base: Int, function fn: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn(base)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(broker(base: <span class="number">3</span>, function: incr))</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>incr(param:)은 정수값을 입력받아 +1을 처리한 값을 반환하는 함수입니다. 뒤이어 정의된 broker(base:function:)은 인자로 받은 함수를 실행하는 함수죠. broker(base:funcion:)은 두 번째 매개변수에 대한 인자값에 어떤 함수가 들어오는지 상관하지 않습니다. 단지 정수를 입력받고 정수를 반환하는 타입의 함수이기만 하면 됩니다. 그렇게 매개변수 타입이 정의되어 있기 때문입니다. 정의된 타입에 맞는 함수가 입력되면, 그게 어떤 함수이든 간에 그냥 실행하고 그 결과를 반환해 버립니다. 그러나 broker(base:function:) 함수의 정의 구문만으로는 어떤 연산이 실행될지 짐작하기 어렵습니다. 실질적인 연산은 인자값으로 받는 함수에 달려 있기 때문입니다. 보통 이런 식으로 중개 역할을 하는 함수를 브로커(Broker)라고 합니다.</p>
<p><br></p>
<p>마지막 행에서 broker(base:function:) 함수는 정수 3과 incr(param:) 함수를 인자값으로 하여 호출됩니다. 내부적으로 실행될 함수가 incr(param:)인 것이 파악된 지금에서야 비로소 broker(base:functiion:)가 처리할 내용을 짐작할 수 있게 되는 거죠. 이처럼 함수를 인자로 사용하면 실행 전까지 어떤 구문이 수행될지 컴파일러가 미리 알 수 없으므로 컴파일 시점에서 디버깅할 수 없는 단점이 있습니다. 하지만 잘 활용하면 동적으로 정의되는 훌륭한 함수를 만들 수 있습니다. 이번에는 콜백 함수를 사용하는 예를 살펴봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">successThrough</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"연산 처리가 성공했습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failThrough</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"처리 과정에서 오류가 발생했습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(base: Int, success sCallBack: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>, fail fCallBack: () -&gt; <span class="type">Void</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> base != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        fCallBack() <span class="comment">// 실패 함수를 실행한다.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        sCallBack() <span class="comment">// 성공 함수를 실행한다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> / base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divide(base: <span class="number">30</span>, success: successThrough, fail: failThrough)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위의 예제는 함수 인자를 사용하여 콜백을 처리하고 있습니다. 이 함수는 첫 번째 인자로 받은 정수를 사용하여 100을 나누고, 그 몫을 정수 형태로 반환하는 역할을 합니다. 두 번째 인자는 내부 연산 과정이 성공적으로 완료되었을 때 실행할 함수이며, 세 번째 인자는 내부 연산 과정이 실패했을 때 실행할 함수입니다. divide(base:succfess:fail:) 함수는 내부 연산이 성공하거나 실패했을 때 값을 반환하는 것 이외에는 아무것도 하지 않습니다. 단순히 인자값으로 입력받은 함수를 실행할 뿐입니다.</p>
<p><br></p>
<p>이런 식의 구문을 작성하면 함수가 성공, 또는 실패했을 때의 처리 과정을 외부에서 제어할 수 있습니다. 즉, 함수의 내부 코드를 수정하지 않고도 외부에서 함수 내부의 실행 과정에 간섭할 수 있다는 뜻입니다. 완전히 실행 흐름을 꺾지는 못하지만, 그 실행 흐름에 합류하여 추가 기능을 수행하는 것 정도는 충분히 가능합니다. 첫 번째 입력값이 0이면 divide 함수는 내부 연산을 수행할 수 없습니다. Divide By Zero 오류가 발생하기 때문입니다. 이 때문에 guard 구문을 사용하여 입력값이 0이 되는 경우를 방지해 주어야 합니다.</p>
<p><br></p>
<p>만약 입력된 base가 0이라면 조건 실패로 인해 else 구문의 내용이 실행됩니다. fCallback은 함수처럼 보이지만 실제로는 매개변수입니다. 여기에 함수가 대입되었을 뿐이죠. else 구문은 외부에서 전달된 실패 처리 함수를 fCallBack 매개변수를 통하여 실행한 다음 0을 반환하면서 함수를 종료합니다. 이 때문에 실제로 함수가 실행되기 전에는 실패 처리 내용을 알 수 없습니다. 오로지 ‘fCallBack 매개변수에 대입된 함수를 실행한다’라는 구문만 있을 뿐입니다.</p>
<p><br></p>
<p>마찬가지로 입력된 base의 값이 0이 아닐 경우 나누기 연산이 실행됩니다. 연산이 성공했을 때에는 sCallBack 매개변수에 대입된 함수가 실행되는데, 이때 값을 반환하는 return 구문과 성공 함수를 실행하는 과정 사이에 발생할 수 있는 미묘한 타이밍 차이를 해결하기 위해 defer 구문이 사용됩니다. defer 블록은 함수나 메소드에서 코드의 흐름과 상관없이 가장 마지막에 실행되는 블록입니다. 지연 블록이라고 부르기도 하는 이 블록에 작성된 구문은 작성된 위치에 상관없이 항상 함수의 종료 직전에 실행되기 때문에, 종료 시점에 맞추어 처리해야 할 구문이 있다면 우리는 어디에 작성해야 할지 고민하지 않고 defer 블록에 넣어두기만 하면 됩니다. 실제로 이 블록은 함수에서 사용된 각종 리소스 처리나 해제, 연결 종료 등의 구문을 처리하는 용도로 유용하게 사용됩니다. defer 블록은 다음과 같은 특성을 가지고 있습니다.</p>
<p><br></p>
<ol>
<li>defer 블록은 작성된 위치와 순서에 상관없이 함수가 종료되기 직전에 실행된다.</li>
<li>defer 블록을 읽기 전에 함수의 실행이 종료될 경우 defer 블록은 실행되지 않는다.</li>
<li>하나의 함수나 메소드 내에서 defer 블록을 여러 번 사용할 수 있다. 이때에는 가장 마지막에 작성된 defer 블록부터 역순으로 실행된다.</li>
<li>defer 블록을 중첩해서 사용할 수 있다. 이때에는 바깥쪽 defer 블록부터 실행되며 가장 안쪽에 있는 defer 블록은 가장 마지막에 실행된다.</li>
</ol>
<p><br></p>
<p>defer는 주로 함수가 연산을 처리하는 과정에 영향을 끼치지 않으면서 실행해야 할 다른 내용이 있을 때 사용하거나, 함수를 종료하기 직전에 정리해야 하는 변수나 상수값들을 처리하는 용도로 사용됩니다. 다시 말해, 함수를 종료하기 전에 처리해야 하는 변수나 상수들 중에서 처리 시점이 모두 달라서 적절한 처리 시점을 잡기 어려울 때 defer 구문을 통해 처리하면 된다는 뜻입니다.</p>
<p><br></p>
<p>함수를 인자로 넘기는 가장 큰 목적은 함수 내부의 코드를 건드리지 않고도 외부에서 실행 흐름을 추가하기 위함입니다. 원래대로라면 실행 구문들이 들어가야 하겠지만, 구문 자체를 인자로 넣을 수는 없으므로 구문을 집약한 함수가 인자값으로 사용되는 것입니다. 함수 외부에서 함수 내부에 실행 구문을 추가할 수 있다는 것은, 함수를 그만큼 재활용할 수 있다는 장점이 되기도 합니다.</p>
<p><br></p>
<p>위 함수가 성공/실패 함수를 인자값으로 받지 않는다고 가정하고, 만약 이 함수의 연산을 두 군데에서 호출해야 하는데 호출하는 지점마다 함수가 연산 성공/실패 시 처리해야 하는 내용이 다르다면 어떻게 해야 할까요? 아마도 그때마다 함수를 새로 작성해야 할 겁니다. 성공/실패 처리 구문 차이 때문에 거의 같은 연산을 처리하는 함수가 중복으로 작성되어야 하죠. 하지만 이처럼 호출하는 지점마다 다르게 적용되어야 하는 부분을 함수 인자값으로 받도록 처리하면 함수를 공통으로 사용할 수 있는 범위가 넓어집니다. 공통 코드를 사용하고, 각자 다르게 작용되어야 할 부분만 함수 인자를 통하여 제어하면 되기 때문입니다. 결국, 함수의 재사용성이 높아지는 셈입니다.</p>
<p><br></p>
<p>그런데 인자값으로 사용하기 위해 매번 새로운 성공/실패 함수를 작성해야 하는 것도 번거로운 작업입니다. 특히 재사용하지 않는 코드를 굳이 함수로 작성해야 한다는 것은 매우 비능률적인 일에 틀림없습니다. 이런 문제를 해결하고자 많은 함수형 언어에서는 익명 함수를 지원합니다. 익명 함수는 쉽게 생각해서 일회용 함수라고 생각하면 됩니다. 함수의 형태를 가지지만 이름이 부여되지 않으며, 일회용이기 때문에 여러 가지 간편한 작성 형식을 따른다는 특성이 있습니다.</p>
<p><br></p>
<p>스위프트에서도 익명 함수를 지원합니다. 이를 클로저(Closure)라고 부르죠. 우리는 클로저를 이용하여 익명 함수 형태의 코드 블록을 작성합니다. 클로저에 대해서는 뒤에 자세히 다루게 되므로 여기에서는 위 예제의 호출 부분을 익명 함수를 이용한 코드로 변경하는 내용만 살펴보고 넘어가도록 하겠습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">divide(base: <span class="number">30</span>,</span><br><span class="line">       success: &#123;</span><br><span class="line">        () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"연산 처리가 성공했습니다"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">       fail: &#123;</span><br><span class="line">        () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"처리 과정에 오류가 발생했습니다"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>복잡해 보이지만, 생각보다 단순합니다. 가존에 함수 이름이 입력되었던 부분에 함수 본문이 작성된 것에 지나지 않습니다. 복잡해 보이는 이유는 클로저의 형태로 작성되었기 때문입니다. 자세한 것은 클로저를 학습한 다음에 이해할 수 있으므로 단순히 익명 함수의 형태로 코드를 작섣ㅇ할 수 있다는 것만 이해하고 넘어가면 됩니다.</p>
<p><br><br></p>
<h4 id="함수의-중첩"><a href="#함수의-중첩" class="headerlink" title="함수의 중첩"></a>함수의 중첩</h4><p>스위프트에서 함수는 중첩하여 작성할 수 있습니다. 함수 내에 다른 함수를 작성해서 사용할 수 있다는 것입니다. 이렇게 작성된 함수를 중첩 함수라고 합니다. 함수 내에 작성할 수 있는 내부 함수의 수에는 제한이 없습니다. 외부 함수 내에 여러 개의 내부 함수를 정의할 수도 있고, 외부 함수 내에 작성된 내부 함수에 또 다른 내부 함수를 작성할 수도 있습니다. 구조가 복잡해지고 유지보수가 힘들어질지언정, 중첩 함수의 수에는 제한이 없습니다.</p>
<p><br></p>
<p>함수를 중첩해서 정의하면 내부 함수는 외부 함수가 실행되는 순간 생성되고, 종료되는 순간 소멸합니다. 외부 함수는 프로그램이 실행될 때 생성되고 프로그램이 종료될 때 소멸하지만, 내부 함수는 외부 함수의 실행과 종료 사이에서 생겼다가 사라집니다. 즉 외부 함수가 종료되면 내부 함수도 더는 존재하지 않는 것이죠. 이것이 내부 함수의 생명 주기입니다. 내부 함수는 일반적으로 외부 함수를 거치지 않으면 접근할 수 없습니다. 이 때문에 내부 함수는 외부의 코드로부터 차단되는 결과를 가져옵니다. 이를 함수의 은닉성이라고 합니다. 중첩된 함수를 구현하면 함수의 은닉성을 높일 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 외부함수</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outer</span><span class="params">(base: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="comment">// 내부함수</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inner</span><span class="params">(inc: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\(inc)를 반환했습니다"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = inner(inc: base + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer(base: <span class="number">3</span>)  <span class="comment">// 4를 반환했습니다</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>outer는 Int 타입의 값을 인자로 받아 문자열을 반환하는 함수입니다. 이 함수의 내부에는 inner라는 이름의 함수가 작성되어 있는데, 이 함수의 외부에서 참조할 수 없으며 오로지 outer 함수 내부에서만 참조할 수 있습니다. 직접 인자값을 전달할 수도 없죠. 말하자면 inner 함수는 외부로부터 은닉되어 있습니다.</p>
<p><br></p>
<p>내부 함수의 생명 주기를 알아봅시다. 일반적으로 함수는 자신을 참조하는 곳이 있으면 생성되었다가 참조하는 곳이 사라지면 제거되는 생명 주기를 가집니다. 다시 말해 함수의 생명 주기는 참조 카운트와 관련되어 있습니다. 함수는 참조 카운트가 0에서 1이 되는 순간 생성되어 1 이상인 동안 유지되다가, 0이 되면 소멸하는 과정을 반복합니다. 내부 함수의 경우에는 어떨까요?</p>
<p><br></p>
<p>내부 함수를 참조할 수 있는 곳은 그 함수를 선언해준 외부 함수 이외에는 없습니다. 나머지 외부 범위로부터 내부 함수는 은닉되기 때문이죠. 따라서 이러한 경우 내부 함수의 생명 주기는 전적으로 외부 함수에 의존합니다. 외부 함수가 실행되면서 내부 함수에 대한 참조가 발생하면 생성되고, 외부 함수가 종료되면서 내부 함수에 대한 참조도 종료되면 내부 함수는 소멸합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 외부함수</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outer</span><span class="params">(param: Int)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="comment">// 내부함수</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inner</span><span class="params">(inc: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\(inc)를 리턴합니다"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn1 = outer(param: <span class="number">3</span>)  <span class="comment">// outer()가 실행되고, 그 결과로 inner가 대입됩니다.</span></span><br><span class="line"><span class="keyword">let</span> fn2 = fn1(<span class="number">30</span>)  <span class="comment">// inner(inc: 30)과 동일합니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 예제에서는 함수 outer가 실행 결과로 inner를 반환합니다. 이 값을 할당받은 상수 fn1는 내부 함수 inner와 동일한 함수이므로, 함수 호출 연산자를 통해 인자값을 입력하고 호출하면 inner 함수를 호출한 것과 같은 결과를 얻을 수 있습니다. 실제로도 inner 함수가 실행된 것이라고 볼 수 있습니다. 여기까지는 단순히 앞의 일급 함수 특성에 대한 설명에 지나지 않습니다. 이제 이 예제가 갖는 의미에 대해 해석해봅시다.</p>
<p><br></p>
<p>위 예제에서 주의 깊게 보아야 할 것은 은닉성이 있는 내부 함수 inner를 외부 함수의 실행 결과로 반환함으로써 내부 함수를 외부 함수에서도 접근할 수 있는 길이 열렸다는 점입니다. 이제까지 내부에서 정의된 함수 inner는 오롲지 외부 함수인 outer를 통해서만 접근할 수 있었습니다. 이로 인해 완벽한 은닉성이 제공되었죠. 하지만 내부 함수를 이렇게 반환하면 outer 함수의 실행 결과는 내부 함수 inner 그 자체가 됩니다. 이를 할당받은 상수 fn1에는 내부 함수가 대입되므로 fn1을 사용하여 얼마든지 inner를 호출할 수 있습니다.</p>
<p><br></p>
<p>inner 함수의 생명 주기에 대해서도 주의할 필요가 있습니다. 본래 inner는 외부 함수인 outer가 실행 종료되면 소멸하도록 설계되어 있습니다. 따라서 원래대로라면 let fn1 = outer(param: 3) 구문이 실행되었을 때 inner는 소멸해야 합니다. 그런데 다음 줄을 살펴보면 inner 함수가 소멸하지 않고 fn1에 할당된 채로 생명을 유지하다가 (30)이라는 함수 호출 연산자 구문을 만나 실행되는 것을 확인할 수 있습니다. 즉, 외부 함수에서 내부 함수를 반환하게 되면 외부 함수가 종료되더라도 내부 함수의 생명이 유지되는 것입니다.</p>
<p><br></p>
<p>실제로 중첩된 외부 함수 outer는 let fn1 = outer(param: 3) 구문의 실행 종료와 함께 제거됩니다. 더는 자신을 참조하는 곳이 없기 때문이죠. 만약 outer 함수 내부에 지역 변수가 정의되어 있다면 함수의 종료 시 함께 제거됩니다. 지역 변수는 자신을 선언한 블록의 실행 종료와 운명을 함께하기 때문입니다. 하지만 내부 함수인 inner는 결과값으로 반환되어 상수 fn1에 참조되었으므로 참조 카운트가 존재합니다. 이로 인해 외부 함수의 종료에도 아랑곳하지 않고 생명을 유지할 수 있습니다. 정리하자면 내부 함수 inner는 혼자만 살아남은 겁니다. 그렇다면 만약 내부 함수에 외부 함수의 지역 상수, 또는 지역 변수가 참조되면 어떤 일이 벌어질까요?</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">basic</span><span class="params">(param: Int)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = param + <span class="number">20</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(add: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value + add</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> append</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = basic(param: <span class="number">10</span>)  <span class="comment">// (1)</span></span><br><span class="line">result(<span class="number">10</span>)  <span class="comment">// (2)</span></span><br><span class="line"><span class="comment">// 40</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>basic 함수는 정수를 인자값으로 받고 내부에 중첩된 함수 append를 반환하는 형식으로 정의되어 있습니다. 내부 함수 append는 외부 함수 basic이 받은 인자값에 20을 더한 값을 자신의 인자값과 더하여 반환합니다. 두 함수는 모두 상수 value를 참조하는데, 이는 basic 함수에 정의된 지역 상수입니다. (1)에서 구문이 실행되면 basic 함수가 실행되고, 그 결과로 내부 함수인 append가 반환됩니다. basic 함수는 실행이 모두 끝났으므로 종료되지만 반환된 내부 함수 append는 상수 result가 참조하고 있는 까닭에 소멸하지 않고 계속 남아있다가 (2)에서 실행됩니다.</p>
<p><br></p>
<p>이 과정에서 value 상수에 주목해봅시다. 일반적으로 함수 내에서 정의된 값들은 그 함수가 종료되기 직전까지만 존재하므로, value 상수는 (1)의 실행이 종료되기 직전까지만 존재해야 합니다. 즉, (1)의 실행이 완료될 때 함께 제거될 것이라는 뜻이죠. 따라서 (2) 구문이 실행되는 시점에서는 value 상수는 더는 존재하지 않으며, append 함수의 내부 블록에서는 결과적으로 존재하지 않는 상수를 참조하고 있는 모양이 됩니다. 오류가 발생할 것이라고 쉽게 예상할 수 있습니다. 하지만 실제로 실행해 보면 예상과 달리 이 코드는 문제없이 동작하며, (2)는 40이라는 결과를 반환합니다. 어떻게 된 일일까요?</p>
<p><br></p>
<p>이러한 현상에 대한 원인은 바로 클로저 때문입니다. 더 정확히는 append 함수가 클로저를 갖기 때문입니다. 클로저를 설명하자면 다음과 같습니다.</p>
<p><br></p>
<ol>
<li>클로저는 두 가지로 이루어진 객체입니다. 하나는 내부 함수이며, 또 다른 하나는 내부 함수가 만들어진 주변 환경입니다.</li>
<li>클로저는 외부 함수 내에서 내부 함수를 반환하고, 내부 함수가 외부 함수의 지역 변수나 상수를 참조할 때 만들어집니다.</li>
</ol>
<p><br></p>
<p>어렵죠? 클로저를 조금 더 간단하게 요약한다면 다음과 같습니다. 클로저란 내부 함수와 내부 함수에 영향을 미치는 주변 환경(Context)를 모두 포함한 객체입니다. 주변 환경이라는 것은 내부 함수에서 참조하는 모든 외부 변수나 상수의 값, 그리고 내부 함수에서 참조하고 있는 다른 객체까지를 말합니다. 이를 문맥(Context)이라고 합니다. 즉 클로저란 내부함수와 이 함수를 둘러싼 주변 객체들의 값을 함께 의미하는 것이라고 할 수 있습니다.</p>
<p><br></p>
<p>클로저란, ‘내부 함수 + 함수의 줒변 환경’입니다. 더 나아가서 클로저에서 저장하는 주변 환경은 변수나 객체 자체가 아니라 이들의 값입니다. 이를 위해 클로저가 만들어지려면 함수가 정의되는 것만으로는 충분치 않고, 실제로 basic 함수가 호출되어야 합니다. 즉, (1) 구문이 싫행되어야 클로저가 만들어질 수 있다는 거죠. 이 구문이 실행될 때 생성되는 클로저는 표시된 그림에서 보는 것처럼 두변 환경을 포함하지만, 포함하는 것은 어디까지나 주변 환경의 객체 자체가 아니라 값이라는 거죠. 따라서 상수 result에 저장되는 클로저는 다음과 같은 형태로 생성됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(add: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">30</span> + add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>내부 함수를 둘러싼 환경 객체가 값으로 바뀌어 저장됩니다. 이 때문에 기존에 value라는 객체 자체가 사용되던 append 함수의 코드가 basic(param: 10)의 실행으로 얻게 된 값인 30으로 바뀐 것이죠. 이 역시도 완전히 정확한 표현은 아닙니다만, 그ㅐㄹ도 어느 정도 클로저의 성격을 표현해준 것이라고 할 수 있습니다. 이러한 클로저의 특성 때문에 같은 정의를 갖는 함수가 서로 다른 환경을 저장하는 결과가 생겨납니다.</p>
<p><br></p>
<p>이처럼 외부 함수에서 정의된 객체가 만약 내부 함수에서도 참조되고 있고, 이 내부 함수가 반환되어 참조가 유지되고 있는 상태라면 클로저에 의해 내부 함수 주변의 지역 변수나 상수도 함께 저장됩니다. 정확히는 지역 변수의 값이 ‘저장’되는 것이라고 할 수 있죠. 이를 값이 캡처(Capture)되었다라고 표현합니다. 값의 캡처는 문맥에 포함된 변수나 상수의 타입이 기본 자료형이나 구조체 자료형일 때 발생하는데, 이러한 캡처 기능은 클로저의 고유 기능 중 하나입니다.</p>
<p><br><br></p>
<h4 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h4><p>조금 전까지 학습한 클로저는 많은 함수형 언어에서 공통적으로 가지는 소프트웨어 아키텍처적인 개념이었다면, 이제부터 학습해야 할 클로저는 유사하지만 조금 다른 의미의 객체입니다. 실제로 스위프트에서 클로저라고 객체를 지칭하는 대부분은 지금부터 학습할 개념의 클로저를 의미합니다.</p>
<p><br></p>
<p>스위프트에서 클로저는 일회용 함수를 작성할 수 있는 구문입니다. 일회용 함수란 한 번만 사용할 구문들의 집합이면서, 그 형식은 함수로 작성되어야 하는 제약조건이 있을 때 만들어 사용할 수 있는 함수를 이야기합니다. 전통적인 명령형 언어에서는 모든 함수에 이름이 부여되어야 하지만 일회용 함수는 한 번만 사용하면 되므로 굳이 함수의 이름을 짝성할 필요 없이 생략된다는 점에서 익명 함수라고 부르기도 합니다.</p>
<p><br></p>
<p>스위프트에서 제공하는 클로저는 앞 절에서 학습했던 클로저의 개념과 동떨어진 개념은 아닙니다. 앞에서 학습했던 클로저의 개념을 모두 포함합니다. 따라서 클로저는 자신이 정의되었던 문맥(Context)으로부터, 모든 상수나 변수의 값을 캡처하거나 레퍼런스를 저장하는 익명 함수라고 할 수 있습니다. 사실 스위프트에서 익명 함수를 클로저라고 부르게 된 것도, 이러한 함수형 언어에서의 클로저 개념을 사용하고 있기 때문이라고 할 수 있습니다. 스위프트에서 클로저라고 부르는 객체는 대부분 다음 세 가지 경우 중 하나에 해당합니다.</p>
<p><br></p>
<ol>
<li>전역 함수: 이름이 있으며, 주변 환경에서 캡처할 어떤 값도 없는 클로저</li>
<li>중첩 함수: 이름이 있으며, 자신을 둘러싼 함수로부터 값을 캡처할 수 있는 클로저3. 클로저 표현식: 이름이 없으며 주변 환경으로부터 값을 캡처할 수 있는 경량 문법으로 작성된 클로저</li>
</ol>
<p><br></p>
<p>이들 중 전역 함수와 중첩 함수는 앞에서 차례로 알아보았습니다. 이번 절에서 주로 다룰 개념은 클로저 표현식임을 알아두기 바랍니다.</p>
<p><br><br></p>
<h4 id="클로저-표현식"><a href="#클로저-표현식" class="headerlink" title="클로저 표현식"></a>클로저 표현식</h4><p>클로저 표현식은 함수와 달리 생략되는 부분이 많습니다. 우선, 함수를 선언하는 func 키워드를 생략하며, 함수의 이름 또한 생략합니다. 클로저 표현식은 일반 함수의 선언 형식에서 func 키워드와 함수명을 제외한 나머지 부분만 작성하는 경량 문법을 사용합니다. 클로저 표현식은 중괄호 형태의 블록으로 싲작되고, 닫는 블록으로 구문을 완료합니다. 클로저 표현식의 블록 내부에서 가장 먼저 작성하는 것은 함수의 인자 타입과 반환 타입에 대한 정의입니다. 이 부분은 함수 타입으로 표현할 수 있습니다.</p>
<p><br></p>
<p>이때 일반적인 함수 정의라면 반환 타입이 표현된 다음에 실행 블록의 시작을 나타내는 중괄호가 와야 하지만, 클로저 표현식에서는 시작 부분에서 이미 중괄호가 선언된 상태이므로 중괄호 대신 in 키워드를 사용하여 실행 블록의 시작을 표현합니다. in 키워드 다음부터 클로저 표현식의 실행 블록이 작성되는 것이죠.</p>
<p><br></p>
<p>작성된 클로저 표현식은 그 자체로 함수라고 할 수 있습니다. 클로저 표현식은 대부분 인자값으로 함수를 넘겨주어야 할 때 사용하지만, 직접 실행해볼 수도 있습니다. 이를 위한 두 가지 방법이 제공되는데, 첫 번째 방법은 일급 함수로서의 특성을 활용하여 상수나 변수에 클로저 표현식을 할당한 다음 실행하는 방법입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"클로저가 실행됩니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 구문은 실제로 함수의 인자값으로 전달된 클로저 표현식이 함수 내에서 실행되는 방식입니다. 상수 f에 클로저 표현식으로 작성된 함수 전체가 할당되고, 이 상수에 함수 호출 연산자를 추가함으로써 클로저 표현식이 실행됩니다. 이번에는 클로저를 직접 실행하는 두 번째 방법을 알아봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"클로저가 실행됩니다"</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>두 번째 방법은 클로저 표현식을 할당받을 상수 f마저 생략하고 싶을 때 작성하는 구문입니다. 클로저 표현식 전체를 소괄호로 감싸고, 여기에 함수 호출 연산자를 붙이면 클로저 표현식이 실행됩니다. 클로저 표현식 전체를 소괄호로 감싸지 않으면 컴파일러에서는 이 구문을 클로저 표현식의 정의가 아니라 그 실행값을 변수나 상수에 할당하려는 의도로 해석하여 오류를 발생시키므로 주의해야 합니다.</p>
<p><br></p>
<p>이번에는 매개변수가 있는 형태의 클로저 표현식을 알아봅시다. 매개변수가 있는 클로저 표현식도 그 자체는 크게 다르지 않습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> co = &#123; (s1: <span class="type">Int</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"s1: \(s1), s2: \(s2)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(<span class="number">1</span>, <span class="string">"closure"</span>)</span><br><span class="line"></span><br><span class="line">(&#123; (s1: <span class="type">Int</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"s1: \(s1), s2: \(s2)"</span>)</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="string">"closure"</span>)</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h4 id="클로저-표현식과-경량-문법"><a href="#클로저-표현식과-경량-문법" class="headerlink" title="클로저 표현식과 경량 문법"></a>클로저 표현식과 경량 문법</h4><p>클로저 표현식은 주로 인자값으로 사용되는 객체인 만큼, 간결성을 극대화하기 위해 생략할 수 있는 구문들로 이루어져 있습니다. 필요에 따라 여러 부분을 생략할 수 있죠. 배열의 정렬 메소드 예제를 통해 실제로 클로저 표현식에 적용되는 경량 문법에 대해 조금 더 알아봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = [<span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 배열은 정렬 함수인 sort(by:)를 이용하여 큰 순서나 작은 순서대로, 또는 임의의 순서대로 정렬할 수 있습니다. 정렬 기준을 잡기 위해서는 특정 형식을 따르는 함수를 정의하여 인자값으로 넣어주어야 합니다. 형식이라고 해도 두 개의 인자값을 입력받고 크기를 비교하여 Bool 타입으로 반환하는 것이 전부입니다. 기본적으로 정렬은 두 값의 비교를 반복하는 알고리즘입니다. 두 값을 비교하여 작은 값을 앞으로, 큰 값을 뒤로 배치하는 과정을 무수히 반복하죠. 수차례 실행한 결과, 순서를 바꿀 값들이 더 이상 나타나지 않을 때가 정렬이 완료되는 시점입니다. 즉, 정렬의 기준은 두 개의 값을 비교하고, 어느 것이 더 큰지만 판단할 수 있으면 충분합니다. 인자값으로 사용하는 정렬 기준 함수가 위의 형식을 따르는 것을 이 때문입니다.</p>
<p><br></p>
<p>정렬 기준 함수는 순서대로 인자값을 받아 첫 번째 인자값이 두 번째 인자값보다 앞쪽에 와야 한다고 판단되면 true를, 이 외에는 false를 반환함으로써 비교 결과를 전달합니다. 정렬 기준이 되는 함수를 작성하고, 이를 sort(by:) 메소드의 인자로 넣어 배열을 정렬해보겠습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = [<span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">order</span><span class="params">(s1: Int, s2: Int)</span></span> -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> s1 &gt; s2&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">value.<span class="built_in">sort</span>(by: order)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>작성된 함수 order는 입력된 두 인자값을 크기 비교하여 첫 번째 인자값이 크면 true를, 이외에는 false를 반환합니다. true가 반환되면 sort 메소드는 배열에서 두 인자값의 위치를 변경하지 않습니다. 반대로 결과값이 false라면 두 인자값의 위치를 변경합니다. 이 기준에 따라 정렬이 실행된 결과 가장 큰 9가 앞으로, 가장 작은 1이 뒤로 배치되는 내림차순 정렬이 완성되었습니다. 이제 함수 order를 클로저 표현식으로 바꾸어 작성해 보겠습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">value.<span class="built_in">sort</span>(by: &#123;</span><br><span class="line">    (s1: <span class="type">Int</span>, s2: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> s1 &gt; s2&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">이 클로저 표현식은 여러 형태로 간결화할 수 있습니다. </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">&#123;</span><br><span class="line">    (s1: <span class="type">Int</span>, s2: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    (s1: <span class="type">Int</span>, s2: <span class="type">Int</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125;</span><br><span class="line"></span><br><span class="line">&#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>앞에서부터 차근차근 구문을 생략해 나가지 않았다면 당황스러울 정도로 짧아진 클로저 표현식입니다. 하지만 생략해 나간 순서대로 해석해보면 그리 난해한 구문도 아닙니다. 사실 sort 메소드에서는 클로저 표현식보다 더 간결하게 표현할 수도 있는 방법도 있습니다. 이를 연산자 함수라고 부르는데, 연산자만을 사용하여 의미하는 바를 정확히 나타낼 수 있을 때 사용됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value.<span class="built_in">sort</span>(by: &gt;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="트레일링-클로저"><a href="#트레일링-클로저" class="headerlink" title="트레일링 클로저"></a>트레일링 클로저</h4><p>트레일링 클로저(Trailing Closure)는 함수의 마지막 인자값이 클로저일 때, 이를 인자값 형식으로 작성하는 대신 함수의 뒤에 꼬리처럼 붙일 수 있는 문법을 의미합니다. 이때 인자 레이블은 생략됩니다. 주의할 점은 이같은 문법은 함수의 마지막 인자값에만 적용된다는 겁니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value.<span class="built_in">sort</span>()&#123; (s1, s2) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>외견상 크게 달라진 점은 없어 보입니다. 하지만 자세히 살펴보면 안자값으로 사용되던 클로저가 통째로 바깥으로 빼내어진 다음, sort() 메소드의 뒤쪽에 달라붙은 것을 알 수 있습니다. 이처럼 트레일링 클로저를 사용하면 함수와 메소드의 괄호를 일단 닫은 다음에 별도의 블록으로 클로저를 붙여주면 되므로 사소한 실수가 줄어들 수 있습니다. 인자값이 하나일 경우, 트레일링 클로젖 문법은 조금 더 변화 가능한 여지가 있습니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value.<span class="built_in">sort</span>&#123; (s1, s2) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이번에는 sort 메소드 뒤의 괄호가 아예 사라졌습니다. 더 필요한 인자값도 없거니와, 트레일링 클로저 문법 덕분에 호출 구문이라는 점을 명확히 할 수 있으므로 굳이 괄호를 써야 할 필요성이 없거든요. 그래서 인자값이 하나일 때에는 마지막 인자값 뿐만 아니라 인자값을 넣어주기 위한 괄호 부분도 생략이 가능합니다. 만약 인자값이 여러개라면 무작정 괄호를 생략해서는 안됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(base: Int, success s: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">defer</span>&#123;</span><br><span class="line">        s() <span class="comment">// 성공 함수를 실행한다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> / base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divide(base: <span class="number">100</span>)&#123; () <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"연산이 성공했습니다"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/21/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%8F%84%EC%A0%84%EA%B8%B0-3/">
                [IOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (3)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="밑바닥부터-시작하는-iOS-앱-개발-3"><a href="#밑바닥부터-시작하는-iOS-앱-개발-3" class="headerlink" title="밑바닥부터 시작하는 iOS 앱 개발 (3)"></a>밑바닥부터 시작하는 iOS 앱 개발 (3)</h1><p><br></p>
<h5 id="본-포스팅은-“꼼꼼한-재은씨의-Swift-문법편”과-“Do-it-스위프트로-아이폰-앱-만들기-입문-”를-정리한-내용입니다"><a href="#본-포스팅은-“꼼꼼한-재은씨의-Swift-문법편”과-“Do-it-스위프트로-아이폰-앱-만들기-입문-”를-정리한-내용입니다" class="headerlink" title="본 포스팅은 “꼼꼼한 재은씨의 Swift: 문법편”과 “Do it! 스위프트로 아이폰 앱 만들기(입문)”를 정리한 내용입니다."></a>본 포스팅은 “꼼꼼한 재은씨의 Swift: 문법편”과 “Do it! 스위프트로 아이폰 앱 만들기(입문)”를 정리한 내용입니다.</h5><p><br></p>
<h4 id="꼼꼼한-재은씨의-Swift-문법편"><a href="#꼼꼼한-재은씨의-Swift-문법편" class="headerlink" title="꼼꼼한 재은씨의 Swift: 문법편"></a>꼼꼼한 재은씨의 Swift: 문법편</h4><p><br></p>
<h5 id="CHAPTER-06-옵셔널-스위프트가-잠재적-오류를-다루는-방법"><a href="#CHAPTER-06-옵셔널-스위프트가-잠재적-오류를-다루는-방법" class="headerlink" title="CHAPTER 06 옵셔널: 스위프트가 잠재적 오류를 다루는 방법"></a>CHAPTER 06 옵셔널: 스위프트가 잠재적 오류를 다루는 방법</h5><p>

<ul>
<li>6.1 옵셔널 타입 선언과 정의</li>
<li>6.2 옵셔널 값 처리</li>
</ul>
<p><br></p>
<p><hr><br><br></p>
<h4 id="옵셔널-스위프트가-잠재적-오류를-다루는-방법"><a href="#옵셔널-스위프트가-잠재적-오류를-다루는-방법" class="headerlink" title="옵셔널: 스위프트가 잠재적 오류를 다루는 방법"></a>옵셔널: 스위프트가 잠재적 오류를 다루는 방법</h4><p><br></p>
<p>옵셔널의 개념을 한 문장으로 정의하자면 nil을 사용할 수 있는 타입과 사용할 수 없는 타입을 구분하고, 사용할 수 있는 타입을 가리켜 옵셔널 타입이라고 부른다라고 할수 있습니다. 여기서 말하는 nil이란, 값이 없음을 의미하는 특수한 값입니다. 정수형의 0이나, 문자열의 “”과는 다른, 말 그대로 순수하게 아무 값도 없다는 것을 의미하죠. 이런 특수성 때문에 nil은 종종 실제 값으로는 처리할 수 없는, 무엇인가 문제가 발생했을 때 이를 의미하기 위해 사용됩니다. 즉, 스위프트는 오류를 발생시키지 않고 뭔가 문제가 있었다는 것도 알려주기 위해 nil이라는 값을 반환하게 됩니다.</p>
<p><br></p>
<p>여기에서 중요한 것은 “오류가 발생할 가능성”입니다. 경우에 따라서는 오류가 발생하지 않을 수도 있지만, 언젠가 오류가 발생할 수 있는 가능성이 조금이라도 있다면 모두 옵셔널 타입으로 정의해야 합니다. 이해를 돕기 위해 또다른 예를 살펴봅시다. 문자열 “123”을 숫자로 변환해야 한다고 가정해 봅시다.</p>
<p><br></p>
<p>일반적으로 사람의 인식에는 “그저 큰 따옴표만 떼면 되는데?”라고 생각할지도 모르겠지만, 프로그래밍에서 문자열 “123”을 숫자로 바꾸려면 다소 복잡한 변환 과정을 거쳐야 합니다. 스위프트에서는 Int 객체의 생성자 옵션에 숫자로 변환할 문자열을 넣어주면 정수로 변환됩니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(<span class="string">"123"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>상수 num은 문자열이 아니라 정수가 대입된 Int 타입의 상수로 정의됩니다. 만약 숫자로 바꿀 수 있는 문자열 대신, 문자열을 인자값으로 넣으면 어떻게 될까요? 일반 문자열은 숫자로 변환할 수 없기 때문에 컴파일러는 이럴 때 난감함을 표현해야 합니다. 대부분 프로그래밍 언어에서는 이런 상황을 오류로 처리하거나 혹은 예외상황으로 처리합니다. 스위프트는 언어의 안정성을 위해 가급적 오류를 발생시키지 않으려고 노력한다. 오류가 발생하면 프로그램의 실행 흐름이 중단되고 경우에 따라 앱의 동작이 멈추거나 아예 꺼져버릴 수도 있으므로, 언어의 안정성을 위해서는 될 수 있으면 피해야 하는 상황일수밖에 없습니다. 이런 맥락에서 스위프트는 문자열의 정수 변환이 실패하더라도 실행을 중지시키거나 오류를 발생시키지 않고 억지로 값을 반환하려고 노력합니다. 반환하는 값이 무엇이되는 간에 말입니다.</p>
<p><br></p>
<p>하지만 아무 값이나 반환할 수는 없습니다. 특히 0을 반환해서는 안 됩니다. 누군가 Int(“0”)을 호출했을 때 정상적인 처리 결과로 정수 0이 반환된 경우와 구분할 수 없기 때문입니다. 또한 공백을 사용해서도 안 됩니다. 공백은 일반적으로 문자열로 처리되는 경향이 있어, 반환 타입이 일치하지 않을 뿐만 아니라 공백 또한 실패를 의미하는 값은 아니기 때문입니다. 이런 상황에서 개발자들은 실패를 의미하면서도 오류를 던지는 것이 아닌 값이 필요했습니다. 이런 목적에서 정의된 값이 바로 “값이 없음”을 뜻하는 nil입니다.</p>
<p><br></p>
<p>앞에서 예로 든 문자열을 숫자로 변환하는 과정에서도 잘못된 인자값으로 인해 문자열이 정수 변환이 실패했을 때, ‘인자값이 잘못되었으므로 이 변환 처리는 실패입니다. 따라서 아무 값도 반환되지 않습니다’라는 의미를 표현하기 위해 nil을 반환합니다.</p>
<p><br></p>
<p>그런데 스위프트에서는 nil 사용에 제약을 걸어두었습니다. 바로 일반 자료형은 nil 값을 가질 수 없다는 것이죠. 문자열이나 정수 등은 일반 자료형이기 때문에 값이 없음을 뜻하는 nil 값을 저장할 수 없습니다. 함수에서 값을 반환할 때에도 때에도 마찬가지입니다. 함수는 반환 타입이 정해져 있기 때문에 항상 그 타입에 맞게 값을 반환해야 하는데, 처리 과정이 실패했을 경우에는 nil을 반환하게 됩니다. 하지만 일반 자료형에는 nil 값을 할당할 수 없다는 스위프트의 특성 때문에 nil을 반환하면 오류가 발생합니다. </p>
<p><br></p>
<p>사실 옵셔널 타입은 별도로 존재하는 자료형이 아닙니다. 스위프트에서 모든 기본 자료형들은 그에 대응하는 옵셔널 타입이 존재하죠. 다시 말해 정수형에 대응하는 옵셔널 타입과, 문자열에 대응하는 옵셔널 타입이 모두 있다는 뜻입니다. 또한, 클래스나 구조체를 이용하여 만든 객체도 옵셔널 타입으로 바꿀 수 있습니다. 함수를 통해서 반환 가능한 타입 역시 옵셔널 타입으로 변경할 수 있구요.</p>
<p><br></p>
<p>어떤 자료형을 사용하는지에 따라 대응하는 옵셔널 타입은 다릅니다. 정수 타입을 옵셔널 타입으로 변경하면 Optional Int 타입이 되고, 문자열 옵셔널 타입으로 바꾸면 Optional String이 됩니다. 그런데 스위프트에서 옵셔널 타입이 실제로 가질 수 있는 값의 종류는 오직 두 가지 뿐입니다. 하나는 nil이 아닌 값, 또다른 하나는 nil 값이죠. nil이 아닌 값은 실제 실행 결과에서 오류가 발생하지 않았을 때 반환되며, 실제 실행 과정에서 오류가 발생했을 때에는 nil이 반환됩니다.</p>
<p><br></p>
<p>헷갈릴지도 모르겠지만 여기에서 말하는 nil이 아닌 값은 ABC 또는 123 등의 구체적인 값이 아니라 정말 nil이 아닌 값 그 자체입니다. 이것은 반환하려는 실제 값이 옵셔널이라는 객체로 둘러 싸인 상태를 의미합니다. 다시 말해 처리 과정에 문제가 있었다면 nil이 반환되고, 문제가 없어 처리가 성공했다면 옵셔널 객체로 감싸진 결과값이 반환됩니다. 결국, 옵셔널 타입이란 반환하고자 하는 값을 옵셔널 객체로 다시 한 번 감싼 형태를 의미합니다. </p>
<p><br></p>
<p>문자열 “123”을 숫자로 변환한 값을 반환하고자 한다면 실제로 변환된 값 123을 직접 반환하는 것이 아니라 옵셔널 타입으로 값을 감싼 Optional(123)을 반환합니다. 만약 숫자로 변환하지 못할 문자열이 입력되어 정상적인 변환이 불가능한 상황이라면 nil 값을 반환합니다. 이때 Optional(123)과 nil은 모두 옵셔널 타입입니다.</p>
<p><br></p>
<p>처리가 성공적일 경우, 옵셔널 타입으로 반환된 값을 열어보면 실제 값이 옵셔널 타입으로 둘러싸여 있는 것을 볼 수 있습니다. 이를 옵셔널 래핑이라고 합니다. 이렇게 받은 값은 옵셔널 언래핑이라고 불리는 특수한 처리 과정을 통해 옵셔널 타입을 해제하고 실제 값을 추출하여 사용해야 합니다. 단, 처리 결과가 실패여서 옵셔널 타입의 값이 nil이라면 옵셔널 타입을 해제해서는 안 됩니다.</p>
<p><br></p>
<h4 id="옵셔널-타입-선언과-정의"><a href="#옵셔널-타입-선언과-정의" class="headerlink" title="옵셔널 타입 선언과 정의"></a>옵셔널 타입 선언과 정의</h4><p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 옵셔널 Int 타입</span></span><br><span class="line"><span class="keyword">var</span> optInt: <span class="type">Int?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 옵셔널 String 타입</span></span><br><span class="line"><span class="keyword">var</span> optStr: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 옵셔널 Double 타입</span></span><br><span class="line"><span class="keyword">var</span> optDouble: <span class="type">Double?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 옵셔널 Array 타입</span></span><br><span class="line"><span class="keyword">var</span> optArr: [<span class="type">String</span>]?</span><br><span class="line"></span><br><span class="line"><span class="comment">// 옵셔널 Dictionary 타입</span></span><br><span class="line"><span class="keyword">var</span> optDic: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;?</span><br><span class="line"><span class="keyword">var</span> optDic2: [<span class="type">String</span> : <span class="type">String</span>]?</span><br><span class="line"></span><br><span class="line"><span class="comment">// 옵셔널 Class 타입</span></span><br><span class="line"><span class="keyword">var</span> optClass: <span class="type">AnyObject?</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>일반 자료형을 선언만 하고 초기화하지 않으면 아무것도 할당되지 않지만, 옵셔널 타입으로 자료형을 선언하면 자동으로 nil로 초기화됩니다. 물론, 옵셔널 내부에 있는 자료형에 nil 값이 선언된다는 것은 아닙니다. 옵셔널 타입 자체에 nil이 부여된다는 뜻이죠. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">case</span> some&lt;<span class="type">T</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 옵셔널 타입의 변수와 상수에 값을 할당하는 방법</span></span><br><span class="line">optInt = <span class="number">3</span></span><br><span class="line">optStr = <span class="string">"Swift"</span></span><br><span class="line">optArr = [<span class="string">"C"</span>, <span class="string">"JAVA"</span>, <span class="string">"Objective-C"</span>, <span class="string">"SmallTalk"</span>]</span><br><span class="line"><span class="keyword">var</span> optDic: [<span class="type">String</span> : <span class="type">Int</span>]?</span><br><span class="line">optDic = [<span class="string">"국어"</span> : <span class="number">94</span>, <span class="string">"수학"</span> : <span class="number">88</span>, <span class="string">"영어"</span> : <span class="number">96</span>]</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="옵셔널-값-처리"><a href="#옵셔널-값-처리" class="headerlink" title="옵셔널 값 처리"></a>옵셔널 값 처리</h4><p>문자열을 숫자로 변환해주는 생성자 Int(문자열)이야기를 조금 더 해 봅시다. Int(문자열)은 그냥 정수가 아니라 옵셔널 타입의 정수값을 반환하도록 설계되어 있습니다. 만약 문자열이 입력되어 변환에 성공하면 Optional(123)이라는 옵셔널 값이 할당됩니다. 어쨌거나 두 경우 모두 옵셔널 타입으로 반환되는 것만은 분명합니다.</p>
<p><br></p>
<p>이렇게 전달받은 옵셔널 타입의 결과값은 그 자체로는 아무것도 할 수 없습니다. 옵셔널 타입은 애초에 연산을 지원하지 않는 타입입니다. 따라서 옵셔널 타입과 일반 타입은 서로 연산할 수 없으며 옵셔널 타입끼리의 연산이나 결합도 지원하지 않습니다. 이 옵셔널 값을 사용하는 방법을 알아봅시다. 우리가 결과값으로 전달받은 것은 Optional이라는 객체입니다. 그 내부에 우리가 원하는 값이 들어있겠죠. 이 값을 우리가 원하는 대로 사용하려면 실제 값을 둘러싼 옵셔널 객체를 해제해야 합니다. 이처럼 옵셔널 객체를 해제하고 내부에 있는 값을 추출하는 과정을 옵셔널 해제라고 합니다.</p>
<p><br></p>
<p>옵셔널 해제 방식은 명시적 해제와 묵시적 해제로 나누어집니다. 명시적 해제는 다시 강제적인 해제와 비강제적인 해제로 나눌 수 있고 묵시적 해제는 각각 컴파일러에 의한 자동 해제와 ! 연산자를 이용한 자동해제로 나눌 수 있습니다.</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/20/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%8F%84%EC%A0%84%EA%B8%B0-2/">
                [IOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (2)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-20</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="밑바닥부터-시작하는-iOS-앱-개발-2"><a href="#밑바닥부터-시작하는-iOS-앱-개발-2" class="headerlink" title="밑바닥부터 시작하는 iOS 앱 개발 (2)"></a>밑바닥부터 시작하는 iOS 앱 개발 (2)</h1><p><br></p>
<h5 id="본-포스팅은-“꼼꼼한-재은씨의-Swift-문법편”과-“Do-it-스위프트로-아이폰-앱"><a href="#본-포스팅은-“꼼꼼한-재은씨의-Swift-문법편”과-“Do-it-스위프트로-아이폰-앱" class="headerlink" title="본 포스팅은 “꼼꼼한 재은씨의 Swift: 문법편”과 “Do it! 스위프트로 아이폰 앱"></a>본 포스팅은 “꼼꼼한 재은씨의 Swift: 문법편”과 “Do it! 스위프트로 아이폰 앱</h5><p> 만들기(입문)”를 정리한 내용입니다.</p>
<p><br></p>
<h4 id="꼼꼼한-재은씨의-Swift-문법편"><a href="#꼼꼼한-재은씨의-Swift-문법편" class="headerlink" title="꼼꼼한 재은씨의 Swift: 문법편"></a>꼼꼼한 재은씨의 Swift: 문법편</h4><h5 id="CHAPTER-04-흐름-제어-구문-코드의-활용성을-높여주는-도구들"><a href="#CHAPTER-04-흐름-제어-구문-코드의-활용성을-높여주는-도구들" class="headerlink" title="CHAPTER 04 흐름 제어 구문: 코드의 활용성을 높여주는 도구들"></a>CHAPTER 04 흐름 제어 구문: 코드의 활용성을 높여주는 도구들</h5><p>

<ul>
<li>4.1 반복문</li>
<li>4.2 조건문</li>
<li>4.3 제어 전달문</li>
</ul>
<p><br></p>
<h5 id="CHAPTER-05-집단-자료형-연관된-데이터를-손쉽게-다루기"><a href="#CHAPTER-05-집단-자료형-연관된-데이터를-손쉽게-다루기" class="headerlink" title="CHAPTER 05 집단 자료형: 연관된 데이터를 손쉽게 다루기"></a>CHAPTER 05 집단 자료형: 연관된 데이터를 손쉽게 다루기</h5><p>

<ul>
<li>5.1 배열</li>
<li>5.2 집합</li>
<li>5.3 튜플</li>
<li>5.4 딕셔너리</li>
</ul>
<p><br></p>
<p><hr><br><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> <span class="number">1940</span> … <span class="number">2017</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(“\(year)년도”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이번에는 for ~ in 구문을 시용하여 문자열의 문자를 순회하는 방법을 알아봅시다. 이<br>들 개별 문자는 순서를 이룬 채 연결되어 하나의 문자열을 구성하므로 이 역시 순회<br>대상으로 사용할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">"swift"</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> lang&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"개별 문자는 \(char)입니다"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> padChar = <span class="string">"0"</span></span><br><span class="line"><span class="keyword">var</span> keyword = <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...size&#123;</span><br><span class="line">    keyword = padChar + keyword</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(keyword)"</span>) <span class="comment">// 000003</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">10</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">10</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(i) X \(j) = \(i*j)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>while 키워드 다음에는 조건식이 사용되는데, 조건식은 반드시 참이나 거짓을 결과값<br>으로 반환해야 합니다. 이 조건식의 값이 true인 동안은 실행 블록 내의 코드가 반복<br>해서 수행되지만, false를 반환하면 그 즉시 반복문의 실행은 종료되고 코드 블록을<br>빠져나가 바로 다음에 이어지는 구문을 실행하게 됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">1000</span>&#123;</span><br><span class="line">    n = n * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"n = \(n)"</span>)  <span class="comment">// 1024</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>대부분 무한 반복되는 코드는 치명적인 문제가 되곤 하지만, 언제나 그런 것은 아닙니다. 터치나 클릭 등 사용자의 액션과 이벤트에 의해 동작하는 모바일 앱은 특성상 사<br>용자의 액션을 기다리는 동안 입력 대기 상태를 유지하는데, 앱이 종료되지 않은 채로 대기 상태를 유지하기 위해 이벤트 루프라고 불리는 무한 루프를 만들어 실행합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span>&#123;</span><br><span class="line">    n = n * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"n = \(n)"</span>)  <span class="comment">// 2048</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="guard-구문"><a href="#guard-구문" class="headerlink" title="guard 구문"></a>guard 구문</h4><p>guard 구문은 if 구문과 마찬가지로 주어진 표현식의 결과가 참인지 거짓인지에 따라 구문의 실행 여부를 결정짓는 방식의 조건문입니다. if 구문과의 차이점은 guard 구문에는 else 블록이 필수이지만, 표현식의 결과가 참일 때 실행되는 블록이 없다는 점입니다. guard 구문은 주로 후속 코드들이 실행되기 전에 특정 조건을 만족하는지 확인<br>하는 용도로 사용합니다. 다시 말해 특정 조건을 만족하지 않은 채로 후속 코드를 실<br>행하면 심각한 오류가 발생할 경우에, 전체 구문을 조기 종료(Early Exit)하기 위한<br>목적으로 사용되는 것이 guard 구문입니다. 따라서 guard 구문의 else 블록에는 이후<br>의 코드 진행을 막아주는 구문이 반드시 포함되어야 합니다. return 또는 break 구문 등이 이에 해당하죠.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(base: Int)</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">100</span> / base</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위의 함수에서는 입력받은 값이 0이 아닐 때에만 함수 내에 코드를 실행하고, 그렇지 않을 경우에는 함수의 실행을 중지해야 합니다. 이런 경우를 제어하기 위해 guard 구<br>문을 사용합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(base: Int)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> base != <span class="number">0</span> <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"연산할 수 없습니다."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">100</span> / base</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>함수의 실행을 종료할 때는 return 구문을 사용합니다. 이후의 코드가 남아있더라도<br>더 이상 진행하지 않은 채로 함수가 종료됩니다. divide 함수는 입력받은 인자값이 0<br>이면 guard 구문의 조건을 만족하지 못합니다. 이 때에는 else 블록 내부에 작성된 return 구문이 실행되어 이후의 코드를 실행하지 않은 채로 종료됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(base: Int)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> base != <span class="number">0</span> <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"연산할 수 없습니다."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> base &gt; <span class="number">0</span> <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"base는 0보다 커야 합니다."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> base &lt; <span class="number">100</span> <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"base는 100보다 작아야 합니다."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">100</span> / base</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="switch-구문"><a href="#switch-구문" class="headerlink" title="switch 구문"></a>switch 구문</h4><p>switch 구문은 앞에서 다룬 if와 guard처럼 분기문의 일종이지만, 처리 방식은 앞에서와 다릅니다. switch 구문은 입력받은 값을 조건식 여부가 아니라 패턴으로 비교하고 그 결과를 바탕으로 실행 블록을 결정하는 조건문입니다. 모든 switch 구문은 case 키워드로 시작하는 여러 가능한 패턴을 나열하는 방식으로 구성됩니다. 비교 대상과 비<br>교 패턴이 일치할 경우 그에 해당하는 구문이 실행된 후 나머지 case에 대한 비교 없<br>이 switch 구문을 종료하고, switch 구문 다음에 나오는 실행 블록으로 진행합니다.<br>만약 비교 패턴 어느 것과도 일치하지 않았다면, 맨 마지막에 작성된 default 구문의 코드가 실행됩니다.</p>
<p><br></p>
<p>스위프트의 switch 구문은 일치하는 비교 패턴이 있을 경우 해당 블록의 실행 코드를 처리하고, 더 이상의 비교 없이 전체 분기문을 종료합니다. 설사 일치하는 패턴이 여<br>러 개 있더라도 맨 처음 일치하는 case 구문 하나만 실행하죠. 오직 하나의 case 구문만 처리하고 나면 더이상 비교를 진행하지 않습니다. 다른 언어에서 switch 구문의 각 case 키워드 블록마다 추가해야 하는 break 구문을 스위프트에서 생략할 수 있는 것<br>든 이 때문입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> val &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"일치한 값은 1입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"일치한 값은 2입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"일치한 값 2가 더 있습니다."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"어느 패턴과도 일치하지 않습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일치한 값은 2입니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>스위프트는 명시적으로 fallthrough 구문을 사용할 수 있습니다. fallthrough 구문이 사용된 case 블록은 비교 패턴이 일치할 경우 인접한 case 블록으로 실행흐름을 전달<br>합니다. fallthrough에 의해 실행 흐름을 전달받은 case 블록은 비교 패턴의 일치 여<br>부와 상관 없이 작성된 구문을 실행한 후 switch 구문을 종료합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleChar: <span class="type">Character</span> = <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> sampleChar&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"글자는 A입니다."</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"일치하는 글자가 없습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 글자는 A입니다.</span></span><br><span class="line"><span class="comment">// 일치하는 글자가 없습니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>스위프트에서 switch 구문에 사용된 비교 대상은 반드시 하나의 비교 패턴과 일치해야 합니다. 비교 대상이 비교 패턴 중 어느 것과도 일치하지 않아 분기문 내의 어떤 블<br>록도 실행되지 못하는 경우를 switch 구문이 실해(fail)했다고 부르는데, 스위프트는 이같이 실패한 switch 구문을 완전한 비교 패턴을 구성하지 못한 것으로 간주합니다. 이에 따라 모든 case 구문에서 일치된 패턴을 찾지 못했을 경우에 대비하여 switch 구문에는 반드시 default 구문을 추가해야 하며, 만약 default 구문을 생략하면 완전하<br>지 않은 구문으로 간주하여 오류가 발생합니다. 단, default 구문을 대신하여 모든 패턴을 매칭시킬 수 있는 구문이 존재하는 경우에 한하여 default 구문을 생략할 수 있<br>습니다.</p>
<p><br></p>
<p>case 비교 패턴을 작성할 때, 하나의 case 키워드 다음에 하나 이상의 비교 패턴을 연이어 작성할 수 있습니다. 두 가지 이상의 패턴에 대해 같은 구문을 실행해야 한다면, 하나의 case 키워드로 비교 패턴을 묶어 표현하면 됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> value&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"0 또는 1입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2 또는 3입니다."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"default입니다."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>case 구문에서 사용되는 비교 패턴으로 단순히 서로 다른 패턴들 외에 튜플이나 특정 타입으로 캐스팅된 객체도 사용할 수 있습니다. 튜플은 집단 자료형으로셔, 괄호로 묶인 이형 집단 데이터입니다.  switch 구문에서 튜플 내부의 아이템이 비교 대상과 부<br>분적으로 일치할 경우, 스위프트는 case 구문의 비교 패턴 전체가 일치하는 것으로 간주합니다. 이때 일치하지 않는 나머지 부분을 상수나 변수화하여 사용할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple = (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> tuple&#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"튜플의 두 번째 값이 3일 때 첫 번째 값은 \(x)입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">2</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"튜플의 첫 번째 값이 2일 때 두 번째 값은 \(y)입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"튜플의 값은 각각 \(x), \(y)입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 튜플의 두 번째 값이 3일 때 첫 번째 값은 2입니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 예제에서 첫 번째 비교 구문에 사용된 튜플은 비교 대상과 부분적으로 일치합니다. 따라서 일치하지 않는 첫 번째 아이템을 변수로 처리하면 switch 구문의 비교 조건을 만족시키게 됩니다. 이렇게 만들어진 변수 x는 우리가 필요로 하는 곳에 사용할 수<br>있습니다.</p>
<p><br></p>
<p>아래 코드는 글이 작성된 시각을 단순하게 YYYY-MM-DD hh:mm:ss 형식으로 보여주는 대신, 자연스러운 구문으로 전환하여 표현합니다. 경과 시간을 입력받아 1분 이내라면 “방금”, 한 시간 이내라면 “조금 전”, 하루 이내라면 “얼마 전”으로 표현해주는 분기문을 구성하는데, 이때 case 구문의 값 비교를 위해 switch 구문의 범위 연산자가 사용<br>됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> passtime = <span class="number">1957</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> passtime&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>..&lt;<span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"방금 작성된 글입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">60</span>..&lt;<span class="number">3600</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"조금 전 작성된 글입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3600</span>..&lt;<span class="number">86400</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"얼마 전 작성된 글입니다."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"예전에 작성된 글입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 조금 전 작성된 글입니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple = (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> tuple&#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">2</span>..&lt;<span class="number">5</span>, <span class="number">0</span>..&lt;<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"범위 A에 포함되었습니다."</span>)</span><br><span class="line"><span class="keyword">case</span>(<span class="number">0</span>..&lt;<span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"범위 B에 포함되었습니다."</span>)</span><br><span class="line"><span class="keyword">case</span>(<span class="number">2</span>..&lt;<span class="number">5</span>, <span class="number">3</span>..&lt;<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"범위 C에 포함되었습니다."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"범위 D에 포함되었습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 범위 C에 포함되었습니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = (<span class="number">3</span>, -<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> point &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(x)와 \(y)는 x==y 선 상에 있습니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == -y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(x)와 \(y)는 x==-y 선 상에 있습니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(x)와 \(y)는 일반 좌표상에 있습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3와 -3는 x==-y 선 상에 있습니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="number">0</span>...<span class="number">5</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> row &gt; <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(row) was executed!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 was executed!</span></span><br><span class="line"><span class="comment">// 1 was executed!</span></span><br><span class="line"><span class="comment">// 2 was executed!</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="number">0</span>...<span class="number">5</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> row &lt; <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"executed data is \(row)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// executed data is 2</span></span><br><span class="line"><span class="comment">// executed data is 3</span></span><br><span class="line"><span class="comment">// executed data is 4</span></span><br><span class="line"><span class="comment">// executed data is 5</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 continue 구문 예제는 루프 상수인 row의 값이 2보다 작을 때는 실행을 여기에서<br>멈추고 다시 루프를 시작할 것이라는 뜻입니다. continue 구문의 실행 방식을 이해했<br>나요? 이 구문의 특성을 이용하면 다음과 같이 특정 문자만 필터링하거나 다른 문자로 변경하는 코드를 작성할 수도 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> text&#123;</span><br><span class="line">    <span class="keyword">if</span> char == <span class="string">" "</span>&#123; <span class="comment">// 공백은 _로 변경한다.</span></span><br><span class="line">        <span class="comment">//result += "_"</span></span><br><span class="line">        result.append(<span class="type">Character</span>(<span class="string">"_"</span>))</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> char == <span class="string">"o"</span>&#123; <span class="comment">// 소문자 o는 대문자 O로 변경한다.</span></span><br><span class="line">        <span class="comment">//result += "O"</span></span><br><span class="line">        result.append(<span class="type">Character</span>(<span class="string">"O"</span>))</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.append(char)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">// This_is_a_swift_bOOk_fOr_Apple's_prOgramming_language</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1에서 5까지 반복</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span>&#123;</span><br><span class="line">    <span class="comment">// 1에서 9까지 반복</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">9</span>&#123;</span><br><span class="line">        <span class="comment">// j의 값이 3일 때 break 구문을 실행한다.</span></span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">3</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 구구단을 출력한다.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(i) X \(j) = \(i*j)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line"><span class="number">1</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">6</span></span><br><span class="line"><span class="number">4</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이같은 일련의 코드 흐름 결과를 통해 우리는 중첩된 반복문 내에 break 문이 있을 때는 이 구문을 둘러싼 인접 반복문에만 작용한다는 것을 알 수 있습니다. 이는 continue 역시 같습니다. 위의 예제에서 한 번의 break로 바깥쪽 루프까지 모두 종료하고 싶<br>으면 다음과 같이 코드를 수정해야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행 여부를 결정할 플래그</span></span><br><span class="line"><span class="keyword">var</span> loopFlag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span>&#123;</span><br><span class="line">    <span class="comment">// 1에서 9까지 반복</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">9</span>&#123;</span><br><span class="line">        <span class="comment">// j의 값이 3일 때 break 구문을 실행한다.</span></span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">3</span>&#123;</span><br><span class="line">            loopFlag = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 구구단을 출력한다.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(i) X \(j) = \(i*j)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(loopFlag == <span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line"><span class="number">1</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span>&#123;</span><br><span class="line">    inner: <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">9</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span> outer</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(i) X \(j) = \(i*j)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line"><span class="number">1</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><br></br></p>
<h4 id="집단-자료형-연관된-데이터를-손쉽게-다루기"><a href="#집단-자료형-연관된-데이터를-손쉽게-다루기" class="headerlink" title="집단 자료형: 연관된 데이터를 손쉽게 다루기"></a>집단 자료형: 연관된 데이터를 손쉽게 다루기</h4><ul>
<li>배열: 일련번호로 구분되는 순서에 따라 데이터가 정렬된 목록 형태의 자료형</li>
<li>집합: 중복되지 않은 유일 데이터들이 모인 집합 형태의 자료형</li>
<li>튜플: 종류에 상관없이 데이터들을 모은 자료형, 수정 및 삭제를 할 수 없음</li>
<li>딕셔너리: 배열과 유사하나 일련번호 대신 키를 사용하여 키-값으로 연관된 데이터<br>들이 순서 없이 모인 자료형</li>
</ul>
<p><br></p>
<h4 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h4><p>배열(Arrays)은 일련의 순서를 가지는 리스트 형식의 값을 저장하는 데에 사용되는 자료형이다. 배열에 입력되는 개별 아이템들은 모두 각각의 순서가 있는데, 이 순서를<br>일련번호, 즉 인덱스(Index)라고 합니다. 인덱스는 정수로 이루어지며, 0부터 시작하<br>여 아이템이 추가될 때마다 차례대로 증가하는 것이 특징입니다.</p>
<p><br></p>
<p>배열에서 인덱스는 순서대로 할당되며, 중간에 값을 생략하거나 건너뛰는 경우는 없습니다. 인덱스에 연결된 아이템이 삭제되더라도 인접한 다음 아이템들이 차례대로 앞으로 이동하면서 빈 인덱스를 채워 넣습니다. 배열 처음이나 중간에 있는 아이템이 삭제되어도 실제로 사라지는 인덱스는 가장 마지막 인덱스입니다.</p>
<p><br></p>
<p>이런 특성 때문에 인덱스는 배열의 아이템과 생사고락을 같이하는 고유 코드 역할을<br>할 수 없습니다. 그저 아이템의 순서를 나타내고, 아이템이 있는 위치를 가리키는 역<br>할만 할 뿐입니다. 스위프트에서 사용하는 배열 자료형은 몇 가지 특징이 있습니다.<br>정리해보면 다음과 같습니다.</p>
<p><br></p>
<ul>
<li>배열에 저장할 아이템의 타입에는 제약이 없지만, 하나의 배열에 저장하는 아이템<br>타입은 모두 같아야 함</li>
<li>선언 시 배열에 저장할 아이템 타입을 명확히 정의해야 함</li>
<li>배열의 크기는 동적으로 확장될 수 있음</li>
</ul>
<p><br></p>
<p>스위프트에서 배열을 정의하는 방법은 두 가지로, 정적인 방식과 동적인 방식으로 나<br>눌 수 있습니다. 정적인 방식은 처음부터 배열을 구성하는 아이템을 포함하여 정의하<br>는 방식입니다. 이 방식은 별도의 배열 선언이 필요 없다는 장점이 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cities = [<span class="string">"Seoul"</span>, <span class="string">"New York"</span>, <span class="string">"LA"</span>, <span class="string">"Santiago"</span>]</span><br><span class="line"></span><br><span class="line">type(of: cities)  <span class="comment">// Array&lt;String&gt;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 예제에서는 네 가지 문자열을 아이템으로 하는 배열을 생성하여 cities 변수에 대<br>입하고 있습니다. 이들 문자열을 배열의 아이템으로 만들기 위해 대괄호 []로 감싼 것을 눈여겨보기 바랍니다. 예에서 정의된 cities는 배열 타입으로 선언된 변수입니다. 타입 추론에 의해서 말이죠. 특히 배열을 이루는 아이템에 모두 문자열 리터럴이 직접 적용되었기 때문에 cities는 문자열 아이템을 가지는 배열이 됩니다. 배열 자료형을 이용하여 실제로 데이터를 저장할 수 있도록 정의한 것을 배열 객체라고 합니다.</p>
<p><br></p>
<h4 id="배열-순회-탐색"><a href="#배열-순회-탐색" class="headerlink" title="배열 순회 탐색"></a>배열 순회 탐색</h4><p>순서가 있는 데이터를 처음부터 마지막까지 차례대로 읽어 들이는 것을 순회 탐색이라고 합니다. 스위프트에서는 배열의 길이를 구할 때에는 배열 변수나 상수에 .count를 붙여주면 됩니다. .count와 같은 것들을 속성(properties)라고 부릅니다. count 속성<br>을 이용하여 배열의 크기를 얻었다면 이를 상수 length에 할당하고, 0에서 시작한 카<br>운터 변수가 이 크기만큼 커질 때까지 for~in 구문을 반복합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> length = cities.<span class="built_in">count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;length&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(i)번째 배열 원소는 \(cities[i])입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line"><span class="number">0</span>번째 배열 원소는 <span class="type">Seoul</span>입니다.</span><br><span class="line"><span class="number">1</span>번째 배열 원소는 <span class="type">New</span> <span class="type">York</span>입니다.</span><br><span class="line"><span class="number">2</span>번째 배열 원소는 <span class="type">LA</span>입니다.</span><br><span class="line"><span class="number">3</span>번째 배열 원소는 <span class="type">Santiago</span>입니다.</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>만약 배열 크기를 상수에 할당하지 않고 for~in 구문에 직접 cities.count를 사용하면 잠재적으로 문제가 될 소지를 가집니다. 왜냐하면 for~in 구문은 루프를 반복할 때마다 매번 조건식을 평가하는데, 이때 배열의 크기를 매번 다시 계산하거든요. 따라서<br>될 수 있으면 한 번만 읽어 별도의 변수나 상수에 크기를 저장해 놓고 사용하는 것이 좋습니다.</p>
<p><br></p>
<p>두 번째 방법은 이보다 더 간단합니다. 배열의 순회 특성, 즉 이터레이터(Iterator)를 이용하는 방식이죠. 앞에서 우리는 for~in 구문에 순번을 가진 범위 데이터를 넣으면 데이터의 크기만큼 반복 실행되는 특성을 학습했습니다. 이 특성은 배열에도 그대로 적용됩니다. for~in 구문이 읽어 들인 배열을 따라 순회하기 시작하면 배열의 아이템<br>들이 차례대로 추출되어 for와 in 사이에 정의된 루프 상수에 할당됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열값의 순회 특성을 사용하여 탐색</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cities&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"배열 원소는 \(row)입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line">배열 원소는 <span class="type">Seoul</span>입니다.</span><br><span class="line">배열 원소는 <span class="type">New</span> <span class="type">York</span>입니다.</span><br><span class="line">배열 원소는 <span class="type">LA</span>입니다.</span><br><span class="line">배열 원소는 <span class="type">Santiago</span>입니다.</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>순회 특성을 이용하여 배열을 탐색하면 루프 상수에 담기는 값은 현재의 인덱스 값이 아니라 배열 아이템 자체이므로, 몇 번째 아이템인지 인덱스를 바로 알기는 어렵습니<br>다. 이때는 index(of:)를 사용하면 아이템을 통해 인덱스 값을 역으로 찾을 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cities&#123;</span><br><span class="line">    <span class="keyword">let</span> index = cities.firstIndex(of: row)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(index!)번째 배열 원소는 \(row)입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line"><span class="number">0</span>번째 배열 원소는 <span class="type">Seoul</span>입니다.</span><br><span class="line"><span class="number">1</span>번째 배열 원소는 <span class="type">New</span> <span class="type">York</span>입니다.</span><br><span class="line"><span class="number">2</span>번째 배열 원소는 <span class="type">LA</span>입니다.</span><br><span class="line"><span class="number">3</span>번째 배열 원소는 <span class="type">Santiago</span>입니다.</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="배열의-동적-선언과-초기화"><a href="#배열의-동적-선언과-초기화" class="headerlink" title="배열의 동적 선언과 초기화"></a>배열의 동적 선언과 초기화</h4><p>배열을 정의할 때 선언과 초기화만 해 놓은 후 필요에 따라서 그때그때 동적으로 아이템을 추가하는 경우가 훨씬 많습니다. 값을 할당하지 않은 빈 배열을 선언하고 초기화할 때는 두 가지 형식을 사용할 수 있습니다. 스위프트에서 배열을 정의하는 객체는 Array입니다. 구조체로 정의된 이 객체는 실질적인 배열 데이터를 만드는 데 사용될 뿐만 아니라 배열에서 데이터를 효과적으로 다루기 위한 다양한 기능까지 제공해 줍니다. 스위프트에서 배열을 정의할 때에는 반드시 저장할 아이템의 타입도 함께 명시해 주어야 합니다. 컴파일러는 이때 입력받은 아이템 타입을 이용하여 다른 데이터 타입이 입력되었을 경우 잘못 입력되었음을 판단할 뿐만 아니라, 배열 내부의 아이템을 바로 아이템 타입 형태로 사용할 수 있도록 처리해주기도 합니다.</p>
<p><br></p>
<p>이처럼 사용 시점에서 &lt;&gt; 기호를 사용하여 배열 내부에서 사용할 아이템 타입을 지정<br>하는 문법을 제네릭이라고 합니다. 제네릭은 구조체나 클래스 외부에서 객체 내부에<br>사용될 타입을 지정할 수 있다는 점에서 동적 프로그래밍으로 간주되기도 하는데, 생<br>산성을 높여주는 문법입니다.</p>
<p><br></p>
<p>동적으로 배열을 정의할 때는 선언과 초기화 과정이 차례로 필요합니다. 객체지향 프<br>로그래밍에서는 배열 구조체는 선언만 되었을 때에는 메모리 공간을 차지하지 않다가 초기화가 진행되면 그때서야 메모리 공간을 할당받습니다. 비로소 데이터를 저장할 수 있는 공간이 생기는 겁니다. 다시 말해, 배열의 선언은 “시스템 OS에 이만이만한 공<br>간을 사용하고 싶습니다”라고 예약하는 과정이고, 초기화는 실제로 사용하기 위해 체<br>크인을 하는 과정인거죠. 실제로 스위프트에서 모든 변수와 상수는 알게 모르게 초기<br>화 과정을 거칩니다.</p>
<p><br></p>
<p>배열에서도 선언과 초기화를 동시에 처리할 수 있죠. 실제로 배열을 정의해 봅시다.<br>다음은 cities 배열을 선언하고 동시에 초기화하는 예입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 배열의 선언과 초기화</span></span><br><span class="line"><span class="keyword">var</span> cities = <span class="type">Array</span>&lt;<span class="type">String</span>&gt;()</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>문자열 형식의 배열 객체를 정의한 다음에, cities 변수에 대입하고 있습니다. 이렇게 정의한 배열은 문자열을 저장할 수 있는 빈 배열로 초기화되죠. 만약 이 배열을 단순히 선언만 하려면 타입 어노테이션을 사용하여 다음과 같이 작성하면 됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 배열을 선언</span></span><br><span class="line"><span class="keyword">var</span> cities: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이렇게 선언된 배열은 초기화되지 않았으므로 아직 메모리 공간을 할당받지 않은 상태입니다. 이 배열에는 아무것도 아직 저장할 수 없죠. 배열을 사용하기 위해서는 아래<br>와 같이 초기화 과정을 통해 메모리 공간을 할당받아야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열의 초기화</span></span><br><span class="line">cities = <span class="type">Array</span>()</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>그런데 이미 선언과 초기화가 이루어진 배열 변수를 또다시 초기화하면 어떻게 될까요? 이때는 새로운 배열 객체가 다시 만들어져 변수에 할당됩니다. 이 과정에서 기존 배열은 제거되죠. 다음으로 스위프트에서 배열을 정의하는 두 번째 형식을 알아봅시다. 이때에는 앞에서 사용했던 배열 구조체 Array나 아이템 타입을 표현하는 &lt;&gt; 기호가 사용되지 않으며 단순히 대괄호 사이에 아이템 타입을 기재하는 것만으로 배열을 정의할 수 있습니다. 물론 초기화할 때는 초기화 연산자인 ()를 붙여야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열 선언 &amp; 초기화</span></span><br><span class="line"><span class="keyword">var</span> cities = [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 선언</span></span><br><span class="line"><span class="keyword">var</span> cities: [<span class="type">String</span>]</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>선언된 배열을 초기화할 때에는 다음 두 가지 형식을 사용할 수 있는데, 이때 두 가지 형식이 의미하는 바는 전혀 다르므로 주의해야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열 초기화 - 첫 번째 방식</span></span><br><span class="line">cities = [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 초기화 - 두 번째 방식</span></span><br><span class="line">cities = []</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>첫 번째 형식은 선언된 배열 그대로를 초기화하지만, 두 번째 형식은 빈 배열 하나를 새로 만들어서 이것을 변수에 할당합니다. 엄밀하게 말해서 두 번째 방식은 초기화가 아닙니다. 따라서 초기화 연산자인 ()가 붙지 않을뿐더러 초기화 연산자 ()를 붙이면 오히려 오류가 발생합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list : [<span class="type">Int</span>] = []  <span class="comment">// 타입 어노테이션 + 빈 배열 하나를 새로 만들어서 초기화(초기화 연산자() 없음)</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> list.isEmpty&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"배열이 비어 있는 상태입니다."</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"배열에는 \(list.count)개의 아이템이 있습니다."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="배열-아이템-동적-추가"><a href="#배열-아이템-동적-추가" class="headerlink" title="배열 아이템 동적 추가"></a>배열 아이템 동적 추가</h4><p>필요에 따라 배열의 아이템을 동적으로 할당하는 방법을 알아봅시다.</p>
<p><br></p>
<p><img src="/image/ios7.jpeg" alt="ios7"></p>
<p><br></p>
<p>append(_:) 메소드는 입력된 값을 배열의 맨 뒤에 추가합니다. 일반적으로 배열에서<br>존재하지 않는 인덱스에 접근하면 오류가 발생하므로 이 메소드는 아이템 추가 전에<br>먼저 배열의 크기를 +1만큼 확장하여 인덱스 공간을 확보한 후, 인자값을 마지막 인덱스 위치에 추가합니다.</p>
<p><br></p>
<p><img src="/image/ios8.jpeg" alt="ios8"></p>
<p><br></p>
<p>반면 insert(_:at:) 메소드는 아이템을 배열의 맨 뒤가 아닌 원하는 위치에 직접 추가하고 싶을 때 사용합니다. at: 뒤에 입력되는 정수값은 배열에서 아이템이 추가될 인<br>덱스의 위치를 의미합니다. 이 인덱스에 새로운 값이 추가되면 이를 기준으로 하여 나머지 인덱스들은 하나씩 다음으로 밀려나는 결과를 가져옵니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cities = [<span class="type">String</span>]()  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">cities.append(<span class="string">"Seoul"</span>)  <span class="comment">// ["Seoul"]</span></span><br><span class="line">cities.append(<span class="string">"New York"</span>)  <span class="comment">// ["Seoul", "New York"]</span></span><br><span class="line">cities.insert(<span class="string">"Tokyo"</span>, at: <span class="number">1</span>)  <span class="comment">// ["Seoul", "Tokyo", "New York"]</span></span><br><span class="line">cities.append(contentsOf: [<span class="string">"Dubai"</span>, <span class="string">"Sydney"</span>])  <span class="comment">// ["Seoul", "Tokyo", "New York", "Dubai", "Sydney"]</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>입력된 배열값을 변경하고 싶을 때는 배열의 인덱스를 이용하여 변경할 값을 직접 대<br>입하면 됩니다. 이렇게 인덱스에 직접 할당된 값은 배열의 크기를 늘리지 않고 기존<br>인덱스에 연결된 아이템을 교체하는 방식으로 수정이 이루어집니다.</p>
<p><br></p>
<p><img src="/image/ios8.jpeg" alt="ios8"></p>
<p><br></p>
<p>반면 insert(_:at:) 메소드는 아이템을 배열의 맨 뒤가 아닌 원하는 위치에 직접 추가<br>하고 싶을 때 사용합니다. at: 뒤에 입력되는 정수값은 배열에서 아이템이 추가될 인<br>덱스의 위치를 의미합니다. 이 인덱스에 새로운 값이 추가되면 이를 기준으로 하여 나<br>머지 인덱스들은 하나씩 다음으로 밀려나는 결과를 가져옵니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cities = [<span class="type">String</span>]()  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">cities.append(<span class="string">"Seoul"</span>)  <span class="comment">// ["Seoul"]</span></span><br><span class="line">cities.append(<span class="string">"New York"</span>)  <span class="comment">// ["Seoul", "New York"]</span></span><br><span class="line">cities.insert(<span class="string">"Tokyo"</span>, at: <span class="number">1</span>)  <span class="comment">// ["Seoul", "Tokyo", "New York"]</span></span><br><span class="line">cities.append(contentsOf: [<span class="string">"Dubai"</span>, <span class="string">"Sydney"</span>])  <span class="comment">// ["Seoul", "Tokyo", "New York"</span></span><br><span class="line">, <span class="string">"Dubai"</span>, <span class="string">"Sydney"</span>]</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>입력된 배열값을 변경하고 싶을 때는 배열의 인덱스를 이용하여 변경할 값을 직접 대<br>입하면 됩니다. 이렇게 인덱스에 직접 할당된 값은 배열의 크기를 늘리지 않고 기존<br>인덱스에 연결된 아이템을 교체하는 방식으로 수정이 이루어집니다.</p>
<p><br></p>
<p>그런데 여기에서 궁금증이 생깁니다. 수정할 값을 직접 대입하는 방법으로 기존의 값<br>을 변경할 수 있다면, 처음부터 이렇게 값을 입력할 수는 없을까요? 결론을 이야기하<br>자면 틀렸습니다. 배열의 인덱스를 이용하여 직접 아이템에 접근하는 이 방식으로 기<br>존에 있는 값을 수정할 수는 있지만, 값을 추가할 수는 없습니다. 어떤 경우든지 배열의 인덱스를 직접 이용하여 아이템의 값을 할당하거나 수정하고, 읽어오는 것은 해당 배열에 그 인덱스가 이미 만들어져 있거나 그만큼의 인덱스가 확보된 경우로 제한됩니다.</p>
<p><br></p>
<p>지금까지 우리는 배열을 만들 때 배열에 들어갈 아이템의 개수, 즉 배열의 길이를 그<br>다지 고려하지 않았습니다. 처음에 시작할 때 크기를 0으로 지정한 후 입력 메소드를 사용하여 새로운 아이템을 추가할 때마다 동적으로 크기가 늘어나도록 배열을 사용했<br>죠. 배열의 길이가 늘어나면 그만큼 인덱스도 자동으로 늘어나는 것이 스위프트에서<br>배열의 특징입니다.</p>
<p><br></p>
<p>하지만 이렇게 하면 배열의 크기는 언제나 현재 입력된 값의 개수만큼만 생성됩니다. 새로운 아이템을 직접 할당하기 위해 참조해야 할 인덱스는 아직 생성되어 있지 않은 상태죠. 이 때문에 오류가 발생합니다. 이처럼 배열의 크기를 동적으로 변경하는 방식으로 생성한 배열은 새로운 아이템을 추가할 목적으로 인덱스에 직접 접근할 수 없습<br>니다. 다만 코코아 터치 프레임워크를 살펴보면 배열을 생성하는 여러 가지 방법 중에서 초기화할 때 배열의 크기를 지정할 수 있는 구문이 다음과 같이 정의되어 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">RangeReplaceableCollection</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(repeating repeatedValue: <span class="type">Element</span>, <span class="built_in">count</span>: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>아직 구조체와 클래스, 확장체에 대해 배우기 전이지만, 가벼운 마음으로 살펴봅시다. init는 객체를 생성할 때 사용하는 구문, 또는 형식이라는 의미로 사용됩니다. 이때 두 개의 인자값이 사용되는데, 하나는 배열의 크기만큼 생성된 인덱스 각각에 기본값<br>으로 넣어줄 repeatedValue이며 또 다른 하나는 배열의 크기를 정해주는 count입니다.<br><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cities = <span class="type">Array</span>(repeating: <span class="string">"None"</span>, <span class="built_in">count</span>: <span class="number">3</span>)  <span class="comment">// ["None", "None", "None"]</span></span><br><span class="line"><span class="keyword">var</span> cities = [<span class="type">String</span>](repeating: <span class="string">"None"</span>, <span class="built_in">count</span>: <span class="number">3</span>)  <span class="comment">// 위와 동일 표현</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이와 같이 배열을 생성하면 지금까지 초기화했던 배열과 달리 배열의 인덱스가 개수만큼 미리 정의되고, 여기에 기본값이 각각 추가된 상태로 배열이 만들어집니다. 이런<br>방식으로 생성된 배열은 입력된 크기만큼의 인덱스를 미리 확보하고 있으므로 필요한 때 배열의 원소에 직접 접근해서 값을 읽거나 할당하고 변경할 수 있습니다.</p>
<p><br><br></p>
<h4 id="딕셔너리"><a href="#딕셔너리" class="headerlink" title="딕셔너리"></a>딕셔너리</h4><p>배열은 각 데이터를 정의할 때 앞에서부터 차례대로 연속된 정수가 할당되어 인덱스를 구성해주므로 인덱스와 데이터 사이를 연결하는 과정이 필요 없었지만, 딕셔너리는<br>불특정 키가 사용되므로 데이터를 입력할 때 반드시 키와 함께 쌍으로 입력해야 합니다. 이외에 딕셔너리를 사용할 때 주의할 점은 다음과 같습니다.</p>
<p><br></p>
<ul>
<li>하나의 키는 하나의 데이터에만 연결되어야 합니다.</li>
<li>하나의 딕셔너리에서 키는 중복될 수 없습니다. 중복해서 선언하면 아이템 추가가<br>아니라 수정이 이루어져 기존 키에 연결된 데이터가 제거됩니다.</li>
<li>저장할 수 있는 데이터 타입에는 제한이 없지만, 하나의 딕셔너리에 저장하는 데이<br>터 타입은 모두 일치해야 합니다.</li>
<li>딕셔너리의 아이템에는 순서가 없지만 키에는 내부적으로 순서가 있으므로 for~in<br>구문을 이용한 순회탐색을 할 수 있습니다.</li>
<li>딕셔너리에 사용할 수 있는 키의 타입은 거의 제한이 없으나 해시 연산이 가능한 타입이어야 합니다.</li>
</ul>
<p><br></p>
<p>해시 연산이란 임의의 입력된 메시지를 고정 길의의 데이터 크기로 변환해주는 알고리즘입니다. 해시 알고리즘을 사용하면 아무리 긴 데이터나 아무리 짧은 길이의 데이터라 할지라도 고정 길의의 데이터로 변환할 수 있습니다. 가장 단순하고 이해하기 쉬운 알고리즘의 예로 나눗셈의 나머지 값을 구하는 % 연산을 들 수 있습니다. 아무리 큰 값의 수라 할지라도 10으로 나눈 나머지를 구하면 0~9까지 중에서 한자리 길의의 값으로 변환될 수 있죠.</p>
<p><br></p>
<p>딕셔너리에서 키로 사용할 수 있는 타입은 다양합니다. 문자열은 물론 단일 문자도 키로 사용할 수 있으며 정수나 실수도 키로 사용할 수 있습니다. 흔하지 않지만, 클래스의 인스턴스도 키로 사용할 수 있습니다. 다만, 키에는 제약이 있어서 키로 사용할 데이터 타입이 해시 연산을 지원해야 합니다. 즉 데이터 타입에 해시(Hash) 값을 추출할 수 있는 기능이 포함되어 있어야 한다는 뜻입니다. </p>
<p><br></p>
<p>딕셔너리가 아이템을 저장할 때는 입력된 키를 그대로 사용하는 것이 아니라 내부적으로 해시 연산을 거친 값으로 변환한 다음 이를 정렬하여 사용합니다. 이는 데이터의 빠른 검색을 위한 장치이지만, 이 때문에 딕셔너리에 사용할 수 있는 키 타입은 해시 연산을 할 수 있는 타입으로 제한됩니다. 스위프트에서 해시 연산을 위해서는 Hashable 프로토콜이 구현되어야 하는데, 문자열 타입은 Hashable 프로토콜이 이미 구현되어 있으므로 대부분의 딕셔너리는 문자열을 키로 사용합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 닥셔너리의 정적 선언과 값의 정의</span></span><br><span class="line"><span class="keyword">var</span> capital = [<span class="string">"KR"</span>:<span class="string">"Seoul"</span>, <span class="string">"EN"</span>:<span class="string">"London"</span>, <span class="string">"FR"</span>:<span class="string">"Paris"</span>]</span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line">[<span class="string">"FR"</span>: <span class="string">"Paris"</span>, <span class="string">"KR"</span>: <span class="string">"Seoul"</span>, <span class="string">"EN"</span>: <span class="string">"London"</span>]</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>해시 문자열 처리를 통해 정렬되기 때문에 입력된 순서와는 다릅니다. 하지만 딕셔너리 자체가 순서를 갖지 않는 값이니만큼 문제는 되지 않습니다. 배열과 마찬가지로, 대부분 빈 딕셔너리를 선언하고 초기화한 다음 필요한 시기에 아이템을 추가하는 방식으로 딕셔너리를 사용합니다. 딕셔너리를 선언할 때는 Dictionary 구조체가 사용됩니다. 이 객체를 사용하여 선언할 때는키와 값으로 사용할 타입을 제네릭을 사용하여 어떤 자료형이나 객체 타입을 사용할 것인지 외부에서 객체 내부에 알려주게 됩니다. 구문의 마지막 부분에는 초기화를 위한 연산자인 ()를 사용하여 선언된 딕셔너리가 메모리에 데이터를 저장할 공간을 할당받게 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 키와 범용 클래스 값으로 이루어진 딕셔너리</span></span><br><span class="line"><span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">AnyObject</span>&gt;()</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">딕셔너리의 선언과 초기화 구문을 간결한 형식으로 정리할 수 있습니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">[<span class="type">String</span> : <span class="type">AnyObject</span>]()</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 딕셔너리의 선언과 초기화</span></span><br><span class="line"><span class="comment">// 방법 1</span></span><br><span class="line"><span class="keyword">var</span> dict1 = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;()</span><br><span class="line"><span class="comment">// 방법 2</span></span><br><span class="line"><span class="keyword">var</span> dict2 = [<span class="type">String</span> : <span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입 어노테이션을 통한 딕셔너리의 선언</span></span><br><span class="line"><span class="keyword">var</span> dict3: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;</span><br><span class="line"><span class="comment">// 딕셔너리의 초기화</span></span><br><span class="line">dict3 = <span class="type">Dictionary</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입 어노테이션을 통한 딕셔너리의 선언</span></span><br><span class="line"><span class="keyword">var</span> dict4: [<span class="type">String</span> : <span class="type">String</span>]</span><br><span class="line"><span class="comment">// 딕셔너리의 초기화</span></span><br><span class="line">dict4 = [<span class="type">String</span> : <span class="type">String</span>]()</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> capital: [<span class="type">String</span> : <span class="type">String</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 딕셔너리 초기화</span></span><br><span class="line">capital = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;() <span class="comment">//1</span></span><br><span class="line">capital = <span class="type">Dictionary</span>() <span class="comment">//2</span></span><br><span class="line">capital = [<span class="type">String</span> : <span class="type">String</span>]() <span class="comment">//3</span></span><br><span class="line">capital = [:] <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 예제에서 주의해야 할 부분은 2번과 4번입니다. 2번과 4번의 초기화 구문은 딕셔너리의 타입 지정이 생략되어 있는데, 이는 사전에 타입 어노테이션을 통하여 딕셔너리의 타입이 명시적으로 선언되어 있기 때문입니다. 이외의 초기화 구문에서는 함부로 타입을 생략하면 안 됩니다.</p>
<p><br></p>
<h4 id="딕셔너리에-동적으로-아이템-추가하기"><a href="#딕셔너리에-동적으로-아이템-추가하기" class="headerlink" title="딕셔너리에 동적으로 아이템 추가하기"></a>딕셔너리에 동적으로 아이템 추가하기</h4><p>딕셔너리는 메소드를 이용해서 추가하는 방법뿐만 아니라 직접 새로운 키와 값을 대입하여 아이템을 추가할 수도 있습니다. 딕셔너리에서도 배열에서처럼 아이템의 개수가 딕셔너리의 크기를 결정합니다. 정확히는 딕셔너리에 저장된 튜플의 개수이죠. 튜플은 스위프트에서 제공하는 특별한 성격의 집단 자료형입니다. 튜플은 한 가지 타입의 아이템만 저장할 수 있는 배열이나 딕셔너리와는 달리 하나의 튜플에 여러 가지 타입의 아이템을 저장할 수 있지만, 일단 선언되고 나면 상수의 성격을 띠므로 더 이상 값을 추가하거나 삭제하는 등의 변경이 불가능합니다. 즉, 타입과 관계없이 다양하게 저장할 수 있지만 오직 최초에 선언된 상태의 아이템만 사용할 수 있고 수정이나 삭제, 추가 등 변경할 수 없는 것이 튜플의 특징이라고 할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newCapital = [<span class="type">String</span> : <span class="type">String</span>]()  <span class="comment">// [:]</span></span><br><span class="line">newCapital[<span class="string">"JP"</span>] = <span class="string">"Tokyo"</span>  <span class="comment">// "Tokyo"</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이번에는 메소드를 사용하여 동적으로 값을 할당해봅시다. 딕셔너리에 값을 할당하는 데 사용되는 메소드는 updateValue(_:forKey:)입니다. 이 메소드는 키가 있는지에 따라 수행하는 역할이 달라지는데, 기존에 저장된 키가 있으면 연결된 값을 수정하는 역할을 하지만 새로운 키가 입력되면 아이템을 추가하는 역할도 수행합니다. 재미있는 것은 이 메소드를 사용하여 딕셔너리에 저장된 값을 수정하면 수정하기 이전의 값이 결과값으로 반환된다는 점입니다. 따라서 새로운 키와 값을 이 메소드를 사용하여 추가하면 기존에 저장되어 있던 값이 없으므로 nil을 반환합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">newCapital.updateValue(<span class="string">"Seoul"</span>, forKey: <span class="string">"KR"</span>)</span><br><span class="line"><span class="comment">// "KR" : "Seoul" 데이터가 추가되고 nil을 리턴함</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">newCapital.updateValue(<span class="string">"Sapporo"</span>, forKey: <span class="string">"JP"</span>)</span><br><span class="line"><span class="comment">// "JP" : "Sapporo" 데이터로 수정되고 "Tokyo"을 리턴함</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">딕셔너리에 저장된 아이템을 제거할 때는 두 가지 방법을 사용할 수 있습니다. 하나는 키에 연결된 값에 직접 <span class="literal">nil</span>을 할당하는 방법이고, 또 다른 하나는 명시적으로 removeValue(forKey:) 메소드를 사용하는 것입니다. <span class="literal">nil</span>은 <span class="string">"값이 없음"</span>이라는 의미를 나타내는 특수 값입니다. 없는 값을 표현하기 위해 또 다른 값을 사용한다는 것이 좀 모순이긴 하지만, 그렇지 않고서는 값이 없다는 것을 명시적으로 표현할 방법이 없어서 <span class="literal">nil</span>이라는 특수 값을 사용합니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">newCapital[<span class="string">"JP"</span>] = <span class="literal">nil</span></span><br><span class="line">newCapital.removeValue(forKey: <span class="string">"KR"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// non-Optional 변수인 removedValue에 Optional 변수인 키 "CA"에 해당하는 아이템을 할당할 수 있다면</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedValue = newCapital.removeValue(forKey: <span class="string">"CA"</span>)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"삭제된 값은 \(removedValue)입니다."</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"아무 것도 삭제되지 않았습니다."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>물론 없는 키를 삭제하고자 할 때는 그 결과값도 당연히 없으므로 nil을 반환합니다. if 조건문을 사용하여 구분하고 있는 이유는 이 때문이죠. 그런데 여기서 한 가지 짚고 넘어가야 할 부분이 있습니다. 바로 배열의 인덱스와 딕셔너리 키의 대한 접근의 차이입니다. 배열은 인덱스를 직접 참조하기 위해 참조할 인덱스가 이미 만들어져 있어야만 한다는 제약조건이 있습니다. 그렇지 않으면 잘못된 인덱스 참조에 의한 오류가 발생하죠. 하지만 딕셔너리는 키 자체가 일련의 순서를 가지고 있지 않습니다(해시 연산에 의한 결과값 역시 연속되는 값은 아닙니다). 게다가 타입은 알 수 있을지언정 실제로 어떤 데이터가 키로 사용될지 미리 알 수 없으므로 기존에 사용된 적이 없던 새로운 키가 입력되면 이 키와 값을 저장하기 위한 튜플을 하나 만들어 저장하면 될 뿐입니다. 새로운 인덱스 공간을 확보하고 크기를 늘릴 필요는 없습니다. 단지 딕셔너리 변수가 초기화되어 있기만 하면 됩니다.</p>
<p><br></p>
<p>그런데 사용하기 편한 이런 특성으로 인해 배열에서는 걱정할 필요 없었던 문제가 딕셔너리에서 생깁니다. 바로 키와 값에 대한 보장이 없다는 점입니다. 배열이야 값을 저장할 때 만들어져 있지 않은 인덱스라면 오류를 발생해버리면 되니 배열에서 인덱스를 호출한다는 것은 곧, 그 안에 저장된 값을 꺼내오기만 하면 된다는 것과 같습니다. 설령 값이 아직 저장되지 않았더라도 초기화될 때 적용한 기본값이라도 저장되어 있을테니 값이 비어있을 염려는 없는 것이죠.</p>
<p><br></p>
<p>그러나 딕셔너리는 고유 키에 대한 제약이 덜하다 보니 프로그램이 딕셔너리로부터 키를 호출해서 저장된 값을 불러올 때 없는 키를 호출했을 가능성을 항상 염두에 두어야 합니다. 이 경우를 처리해 줄 수 있어야 안전한 프로그래밍 언어가 됩니다. 그래서 스위프트에서는 딕셔너리로부터 키를 호출해서 저장된 값을 불러올 때, 또는 업데이트 메소드를 실행한 결과를 반환할 때, 오류가 발생할 가능성을 염두에 둔 다음과 같은 특별한 형식으로 값을 반환합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Optional</span>(<span class="string">"Sappro"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이것이 바로 스위프트가 제공하는 독특하면서도 어려운 개념인 옵셔널입니다. 요약하자면 다양한 객체지향 프로그래밍에서 오류 처리를 위해 애용되는 에러 캐치를 대신할 목적으로 도입한 개념으로서, 아키텍처 차원의 안정성을 제공하기 위한 것입니다.</p>
<p><br></p>
<h4 id="딕셔너리의-순회-탐색"><a href="#딕셔너리의-순회-탐색" class="headerlink" title="딕셔너리의 순회 탐색"></a>딕셔너리의 순회 탐색</h4><p>딕셔너리에 저장된 아이템끼리는 순서가 없지만, 아이템을 튜플 형식으로 저장할 때 내부적으로 키를 바탕으로 한 해시 연산 값을 기준으로 정렬하기 때문에 이 특성을 사용하면 순회 탐색을 할 수 있습니다. 딕셔너리는 인덱스를 사용하지 않으므로 딕셔너리를 직접 사용하여 탐색하는 방식으로 for~in 구문을 구성하면 됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 딕셔너리의 순회 기능을 사용하여 순회 탐색을 실행한다.</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> newCapital&#123;</span><br><span class="line">    <span class="comment">// 딕셔너리에서 꺼낸 키-값 한 쌍이 담긴 row 상수를 튜플로 받는다.</span></span><br><span class="line">    <span class="keyword">let</span> (key, value) = row</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"현재 데이터는 \(key) : \(value)입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 중간 과정 생략 같은 결과</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> newCapital&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"현재 데이터는 \(key) : \(value)입니다."</span><span class="string">")</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>for~in 구문이 반복되면 딕셔너리에 저장된 아이템이 차례대로 row 상수에 대입됩니다. 딕셔너리는 키와 값으로 이루어진 아이템을 내부에 저장할 때 튜플 타입으로 저장하므로 순회 탐색을 실행하면 차례대로 튜플 타입으로 된 키-값이 row 상수에 할당됩니다. 할당된 row 상수로부터 데이터를 키와 값으로 분리해내기 위해 (key, value)의 개별 변수로 구성된 튜플로 값을 할당하는 구문이 다시 사용되고, 이 과정을 거쳐 키는 key 변수에, 값은 value 변수에 할당됩니다.</p>
<p><br></p>
<p><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/16/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%8F%84%EC%A0%84%EA%B8%B0-1/">
                [IOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-16</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="밑바닥부터-시작하는-iOS-앱-개발-1"><a href="#밑바닥부터-시작하는-iOS-앱-개발-1" class="headerlink" title="밑바닥부터 시작하는 iOS 앱 개발 (1)"></a>밑바닥부터 시작하는 iOS 앱 개발 (1)</h1><p><br></p>
<h5 id="본-포스팅은-“꼼꼼한-재은씨의-Swift-문법편”과-“Do-it-스위프트로-아이폰-앱-만들기-입문-”를-정리한-내용입니다"><a href="#본-포스팅은-“꼼꼼한-재은씨의-Swift-문법편”과-“Do-it-스위프트로-아이폰-앱-만들기-입문-”를-정리한-내용입니다" class="headerlink" title="본 포스팅은 “꼼꼼한 재은씨의 Swift: 문법편”과 “Do it! 스위프트로 아이폰 앱 만들기(입문)”를 정리한 내용입니다."></a>본 포스팅은 “꼼꼼한 재은씨의 Swift: 문법편”과 “Do it! 스위프트로 아이폰 앱 만들기(입문)”를 정리한 내용입니다.</h5><p><br></p>
<h4 id="꼼꼼한-재은씨의-Swift-문법편"><a href="#꼼꼼한-재은씨의-Swift-문법편" class="headerlink" title="꼼꼼한 재은씨의 Swift: 문법편"></a>꼼꼼한 재은씨의 Swift: 문법편</h4><p><br></p>
<h5 id="CHAPTER-01-애플의-새로운-언어-스위프트"><a href="#CHAPTER-01-애플의-새로운-언어-스위프트" class="headerlink" title="CHAPTER 01 애플의 새로운 언어, 스위프트"></a>CHAPTER 01 애플의 새로운 언어, 스위프트</h5><p>

<ul>
<li>1.1 스위프트 언어의 탄생과 배경</li>
<li>1.2 스위프트 언어의 특징</li>
<li>스위프트 언어에서 차용하고 있는 주요 기능들</li>
<li>구조적 특징</li>
<li>1.3 오브젝티브-C vs 스위프트</li>
</ul>
<p><br></p>
<p><hr><br><br></p>
<p>이번 장에서는 플랫폼으로서의 스위프트에 대하여 학습합니다. 문법을 학습하기에 앞서 스위프트의 언어적 특징은 어떠한지, 스위프트의 장점은 무엇이며 전반적인 이슈는 무엇인지 등을 살펴보면서 스위프트에 대한 전반적인 이해를 갖추어 보면 좋겠습니다<br><br></p>
<h4 id="스위프트-언어의-탄생과-배경"><a href="#스위프트-언어의-탄생과-배경" class="headerlink" title="스위프트 언어의 탄생과 배경"></a>스위프트 언어의 탄생과 배경</h4><p>스위프트는 그동안 앱을 개발하는 데에 사용되던 오브젝티브-C를 대체할 목적으로 발표된 언어입니다. 애플의 이전 주력 언어였던 오브젝티브-C는 C 언어를 기초로 하여 스몰토크(Smalltalk)의 메시지 전달 개념과 객체지향 개념을 반영한, 말 그대로 객체지향형 C 언어입니다. 이러한 특정 때문에 그3동한 iOS 앱을 개발하기 위해서는 C 언어의 저수준 프로그래밍과 스몰토크의 객체지향 개념을 동시에 구현해야 한다는 부담이 있었습니다. 게다가 C 언어의 장점이자 단점인 포인터 개념은 오브젝티브-C를 강력한 언어로 만들어주긴 했지만, 처음 접근하는 사람에게는 그만큼 높은 장벽으로 작용하기도 했습니다.</p>
<p><br></p>
<p>스위프트는 기존의 오브젝티브-C가 C 언어로부터 가져온 저수준 프로그래밍을 자동 관리 영역으로 대체했고, 생소한 문법이지만 객체지향을 위해 사용할 수밖에 없었던 스몰토크의 메시지 문법을 사람들에게 익숙한 자바, 파이썬, C#의 문법으로 바꾸었으며, 오브젝티브-C와 호환까지 가능하도록 설계되는 등 여러 가지 언어적 강점을 지녔습니다.</p>
<p><br></p>
<blockquote><footer><strong>iOS란?</strong><cite><a href="https://ko.wikipedia.org/wiki/IOS" target="_blank" rel="noopener">ko.wikipedia.org/wiki/IOS</a></cite></footer></blockquote>
<p><br></p>
<p>문득 여기까지 읽다가 iOS가 무엇인지, 어디에서 코드가 동작하게 되는지 몰라 답답함에 <iOS 앱의 구조와 코코아 터치 프레임워크> 부분을 펼쳤다. 자, 물론 글을 읽어도 거의 이해가 가지 않지만 우선 머리에 큰 그림을 그려보자. 시작!</p>
<p><br></p>
<h4 id="iOS-앱의-구조와-코코아-터치-프레임워크"><a href="#iOS-앱의-구조와-코코아-터치-프레임워크" class="headerlink" title="+ iOS 앱의 구조와 코코아 터치 프레임워크"></a>+ iOS 앱의 구조와 코코아 터치 프레임워크</h4><p>앱은 우리가 작성하는 커스텀 코드와 시스템 프레임워크 사이에서 매우 복잡한 상호작용을 합니다. (그래, 시스템 프레임워크는 또 무엇일까…이해가 가지 않으니 그림 먼저!)</p>
<p><br></p>
<p><img src="/image/ios1.jpeg" alt="ios1"></p>
<p><br></p>
<p>시스템 프레임워크는 iOS 기반의 앱이 실행되는 데에 필요한 기반 환경을 제공하고, 우리는 커스텀 코드를 제공하여 원하는 기능과 앱의 형태를 구현하죠. 이들은 서로 맞물려 정교하게 돌아가면서 iOS에서 우리가 원하는 기능을 제공합니다.</p>
<p><br></p>
<p><br></p>
<p>시스템 프레임워크는 iOS 기반의 앱이 실행되는 데에 필요한 기반 환경을 제공하고, 우리는 커스텀 코드를 제공하여 원하는 기능과 앱의 형태를 구현하죠. 이들은 서로 맞물려 정교하게 돌아가면서 iOS에서 우리가 원하는 기능을 제공합니다.</p>
<p><br></p>
<p>앱은 기본적으로 시스템 프레임워크에 정의된 원리에 따라 동작하지만, 이 영역을 제외한 나머지 범위에서는 커스텀 코드를 통해 원하는 기능과 유저 인터페이스를 구현할 수 있습니다. 이 말은 곧 앱 개발이 우리가 건드릴 수 있는 영역과 우리가 건드릴 수 없는 영역으로 분리된다는 것을 의미하며, 동시에 우리가 건드릴 수 없는 영역에 대해서는 신경 쓰지 않아도 된다는 것을 의미합니다. 효율적인 앱을 개발하기 위해서는 이같은 iOS 시스템의 기본 구조와 이것이 어떻게 동작하고 있는지를 잘 파악해야 합니다.</p>
<p><br></p>
<p>이번 장에서는 우리가 임의로 건드릴 수 없는 시스템 프레임워크 영역에 속한 앱의 기본 구조와 여기에 관련된 핵심 객체들에 대해 알아보겠습니다. 특히 이번 장에서 등장하는 앱 델리게이트, 뷰 컨트롤러, 뷰 등의 객체는 앱의 개발과 실행 전반을 관통하는 매우 중요한 객체이므로 이들의 역할과 특성을 잘 이해해야 합니다.</p>
<p><br></br></p>
<h4 id="앱의-기본-구조"><a href="#앱의-기본-구조" class="headerlink" title="앱의 기본 구조"></a>앱의 기본 구조</h4><p><br></p>
<h5 id="엔트리-포인트와-앱의-초기화-과정"><a href="#엔트리-포인트와-앱의-초기화-과정" class="headerlink" title="엔트리 포인트와 앱의 초기화 과정"></a>엔트리 포인트와 앱의 초기화 과정</h5><p>C 언어에 뿌리를 둔 모든 애플리케이션은 main() 함수로부터 시작됩니다. 이를 엔트리 포인트(Entry Point, 시작 진입점)라고 하죠. 운영체제가 해당 애플리케이션 내부에 정의된 main() 함수를 찾아 호출하면 여기에 작성된 코드들이 연쇄적으로 실행되면서 우리가 작성해 둔 커스텀 코드에까지 도달하게 되는 식입니다.</p>
<p><br></p>
<p>오브젝티브-C 역시 C 언어에 기반하고 있기 때문에, 이를 이용하여 만들어진 iOS 앱도 main() 함수로부터 시작됩니다. C 기반의 다른 애플리케이션과 차이가 있다면, iOS 앱에서는 main() 함수를 우리가 직접 작성하지 않는다는 것 정도입니다. 대신 Xcode 프로젝트를 생성하면 main() 함수가 자동으로 만들어지는데, 여기에는 iOS 앱이 실행될 때 처리해야 할 내용이 작성되어 있기 때문에 우리는 main() 함수를 전혀 건드릴 필요가 없습니다. 다음은 실제로 오브젝티브-C 기반의 Xcode 프로젝트를 생성했을 때 main.m 파일 안에 생성되는 main() 함수입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#<span class="keyword">import</span> "AppDelegate.h"</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])&#123;</span><br><span class="line">  @autoreleasepool&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="type">NSStringFromClass</span>([<span class="type">AppDelegate</span> <span class="class"><span class="keyword">class</span>]));</span></span><br><span class="line"><span class="class">  &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>main() 함수가 하는 일은 단순합니다. 실행 시 시스템으로부터 전달받은 두 개의 인자값과 AppDelegate 클래스를 이용하여 UIApplicationMain() 함수를 호출하고, 그 결과로 UIApplication 객체를 반환합니다. 생성된 UIApplication 객체는 UIKit 프레임워크에 속해있으므로 이후의 앱 제어권은 UIKit 프레임워크로 이관됩니다.</p>
<p><br></p>
<p>main() 함수가 C 기반 애플리케이션의 엔트리 포인트라면, UIApplicationMain() 함수는 그 중에서도 iOS 앱에 속하는 부분의 엔트리 포인트라고 할 수 있습니다. 이 함수는 앱의 핵심 객체를 생성하는 프로세스를 핸들링하고, 스토리보드 파일로부터 앱의 유저 인터페이스를 읽어들일뿐만 아니라 우리가 작성한 커스텀 코드를 호출해 줌으로써 앱 생성 초기에 필요한 설정을 구현할 수 있게 해 줍니다. 여기에 더해서 이벤트를 입력받기 위한 이벤트 루프를 실행시키기도 하죠. 이 과정에서 우리가 직접 구현해야 하는 것은 스토리보드 파일이나 초기화를 위한 커스텀 코드뿐입니다.</p>
<p><br></p>
<p>UIApplicationMain() 함수가 생성하는 UIApplication은 앱의 본체라고 할 수 있는 객체로, 사실상 앱 그 자체를 의미합니다. 우리가 작성한 커스텀 코드나 객체들, 그리고 우리가 앱의 기능이라고 생각하는 모든 것들은 다 UIApplication에 포함되어 있는 하위 객체입니다. 모바일 디바이스에 설치된 앱을 실행하면 초기 구동 과정을 거쳐 앱 프로세스가 메모리에 등록되는데, 이때의 앱 프로세스가 곧 UIApplication 객체라고 보아도 무방합니다.</p>
<p><br></p>
<p>UIApplication 객체의 역할은 매우 다양합니다. 이벤트 루프나 다른 높은 수준의 앱 동작을 관리할 뿐만 아니라 푸시 알림과 같은 특수한 이벤트를 우리가 정의한 커스텀 객체인 델리게이트에게 알려주기도 합니다. 우리는 이 클래스를 특별한 일이 있거나 중대한 목적이 있는 경우가 아니면 서브 클래싱 없이 그대로 사용합니다. 굳이 서브 클래싱할 필요도 없고, 하기도 어렵기 때문입니다.</p>
<p><br></p>
<p>그런데 달리 생각해보면 UIApplication 객체를 서브 클래싱하지 않고 그대로 사용하는 것에는 한계가 있습니다. 우리의 의도와 목적에 맞게 특별히 처리해야 할 것도 있을 수 있기 때문이죠. 그래서 UIApplication 객체는 AppDelegate라는 대리인, 아니 대리 객체를 내세우고 커스텀 코드를 처리할 수 있도록 약간의 권한을 부여합니다. AppDelegate는 UIApplication으로부터 위임받은 일부 권한을 이용하여 커스텀 코드와 상호작용하는 역할을 담당하고, 이를 통해 우리가 필요한 코드를 구현할 수 있도록 도와줍니다.</p>
<p><br></p>
<p>이 관계가 쉽게 이해되지 않는다면 기업의 회장과 비서실의 관계를 떠올려 보면 됩니다. 보통 회장은 회사의 아주 중요하고 핵심적인 일을 처리합니다. 즉 회사의 신사업 구상이나 방향성, 대외 업무 등을 담당하는 거죠. 하지만 사업을 구상하기 위해서는 자료 조사도 필요하고, 구상된 사업을 실제로 진척시키려면 현업에서 처리해야 할 일들이 많습니다. 이런 것들을 회장님이 직접 하지 않습니다. 대부분의 경우 최근 연구 동향을 조사해서 보고하게라든가 개발 사업을 진행할 사업부를 구성하게 하는 식으로 큰 방향성에 대한 오더를 비서진에 내리는 거죠. 이에 대한 권한을 위임받은 비서진은 이를 바탕으로 현업 부서에게 업무를 지시하고, 각 현업 부서는 이를 바탕으로 세부적인 업무를 짜서 진행하게 됩니다.</p>
<p><br></p>
<p>여기서 회장은 UIApplication 객체이고, 비서실은 AppDelegate 객체라고 생각하면 됩니다. 쉽게 말해 UIApplication 객체는 앱이 해야 할 아주 중요하고 핵심적인 일, 즉 앱의 생명 주기 관리나 이벤트 처리와 같은 것들을 담당하고, 앱 델리게이트는 커스텀 코드를 처리하는 비서의 성격을 띠는 것이죠.</p>
<p><br></p>
<p>AppDelegate 객체는 커스텀 코드와 연결되는 만큼, 대부분의 경우 커스터마이징하거나 혹은 서브클래싱하여 사용할 수 있도록 오픈되어 있습니다. 프로젝트를 생성하면 만들어지는 파일 중에서 AppDelegate.swift 파일을 보셨을 텐데요. 앞 장에서 그 안에 sleep(5) 구문을 넣어 시작 화면 노출 시간을 지연시켰던 것처럼 손쉽게 커스텀 코드를 작성할 수 있습니다.</p>
<p><br></p>
<p>AppDelegate 객체는 iOS 애플리케이션 내에서 오직 하나의 인스턴스만 생성되도록 시스템적으로 보장받습니다. 게다가 앱이 처음 만들어질 때 객체가 생성되고, 앱이 실행되는 동안 계속 유지되다가 앱이 종료도면 그때 함께 소멸하는 등 앱 전체의 생명 주기와 함께 합니다. 이런 특성 때문에 AppDelegate 객체에 데이터를 저장하면 앱이 종료될 때까지 계속 데이터를 유지할 수 있죠. 따라서 AppDelegate 객체는 종종 앱의 초기 데이터 구조를 설정하기 위해 사용되기도 합니다.</p>
<p><br></p>
<p>UIApplication 객체와 AppDelegate 객체가 연관되어 앱이 실행되는 전체 과정을 정리해 보면 다음과 같습니다.</p>
<p><br><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. main() 함수가 실행된다.</span><br><span class="line"><span class="number">2</span>. main() 함수는 다시 <span class="type">UIApplicationMain</span>() 함수를 호출한다.</span><br><span class="line"><span class="number">3</span>. <span class="type">UIApplicationMain</span>() 함수는 앱의 본체에 해당하는 <span class="type">UIApplication</span> 객체를 생성한다.</span><br><span class="line"><span class="number">4</span>. <span class="type">UIApplication</span> 객체는 info.plist 파일을 바탕으로 앱에 필요한 데이터와 객체를 로드한다.</span><br><span class="line"><span class="number">5</span>. <span class="type">AppDelegate</span> 객체를 생성하고 <span class="type">UIApplication</span> 객체와 연결한다.</span><br><span class="line"><span class="number">6</span>. 이벤트 루프를 만드는 등 실행에 필요한 준비를 진행한다.</span><br><span class="line"><span class="number">7</span>. 실행 완료 직전, 앱 델리게이트의 application(<span class="number">_</span>:didFinishLaunchingWithOptions:) 메소드를 호출한다.</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>반면, 스위프트는 C 기반의 언어가 아닙니다. 따라서 스위프트 기반 프로젝트에는 main.m 파일이 존재하지 않으며 엔트리 포인트 역시 존재하지 않습니다. 이 때문에 스위프트에서는 위의 1~5 과정을 다음과 같은 어노테이션 표기로 대체합니다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class="keyword">Any</span>]?]-&gt;Bool&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="literal">true</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>스위프트에서는 직접 UIApplicationMain()을 호출하여 델리게이트 클래스를 인자값으로 전달할 수 없으므로 대신 앱 델리게이트 역할을 할 클래스에 @UIApplicationMain 어노테이션을 걸어 표시하는 방식으로 시스템에 델리게이트 클래스 정보를 전달합니다. iOS 시스템은 앱을 실행할 때 이 어노테이션이 표시된 클래스를 찾아 델리게이트로 지정하게 되죠. 이후로 진행되는 나머지 과정은 모두 앞에서 설명한 것과 동일합니다. 아래 그림은 방금 설명한 일련의 과정을 요약하여 보여줍니다. 앱의 실행 과정을 설명하는 데에 많이 인용되는 유명한 그림입니다.</p>
<p><br></p>
<p><img src="/image/ios2.png" alt="ios2"></p>
<p><br></p>
<p>이 그림에 따라 앱이 실행되는 과정을 다시 한 번 정리해 봅시다. 왼쪽은 iOS 시스템 프레임워크이고, 오른쪽은 우리가 작성하는 커스텀 코드입니다. 시스템 프레임워크는 사용자가 앱 아이콘을 탭 했을 때 이를 인식하고 앱을 구동합니다. 최초에 main() 함수가 실행되고, 함수 내부에서 UIApplicationMain()을 호출하면 앱이 구동됩니다. 물론 스위프트에서는 main() 함수를 통해 UIApplicationMain()을 호출하는 대신 @UIApplicationMain 어노테이션을 찾아 해당하는 클래스를 실행하겠죠. 이때 우리의 커스텀 코드 쪽에서는 앱 델리게이트 클래스에 작성된 application(_:didFinishLaunchingWithOptions:) 메소드가 시스템에 의해 자동으로 호출됩니다. 즉, AppDelegate 클래스의 application(_:didFinishLaunchingWithOptions:) 메소드에 원하는 커스텀 코드를 작성해 두면 앱이 처음 시작될 때 해당 코드를 실행할 수 있다는 뜻입니다.</p>
<p><br></p>
<p>이어서 시스템 프레임워크의 이벤트 루프가 실행되면서 우리가 작성하는 이벤트 핸들에 의해 커스텀 코드로 연결됩니다. 시스템에서 발생할 수 있는 여러 이벤트 중에서 우리가 원하는 이벤트를 제어하도록 핸들을 만들어 커스텀 코드와 연결해 놓으면 이벤트 루프에서는 특정 이벤트가 발생했을 때 우리가 만든 핸들을 통하여 커스텀 코드를 실행할 수 있도록 처리합니다. 여기서 말하는 핸들은 앞에서 만들었던 @IBAction 메소드를 떠올리면 됩니다. 사용자가 어떤 객체를 클릭하거나 특정 액션을 취했을 때 실행되도록 구현해 놓는 것을 말하죠.</p>
<p><br></p>
<p>앱이 실행 목적을 모두 완료하고 더이상 사용되지 않으면 시스템은 앱을 메모리에서 제거하기 위한 준비를 합니다. 이 과정에서 앱 시스템은 델리게이트 클래스의 applicationWillTerminate(_:) 메소드를 호출합니다. ‘앱이 곧 종료될 테니 정리할 것이 있으면 얼른 하세요’하는 신호죠. 앱 종료 시에 처리해야 할 내용이 있다면 이 메소드 내부에 커스텀 코드로 작성해 두기만 하면 됩니다.</p>
<p><br></p>
<p>앱 델리게이트 프로토콜에는 위에서 설명한 두 개의 메소드뿐만 아니라 더 많은 메소드가 정의되어 있고, 각 메소드는 미리 약속된 시점에 맞추어 시스템에 의해 호출될 수 있도록 구성되어 있습니다. 이처럼 iOS 시스템에 의해 특정 시점마다 호출해주는 메소드가 이미 정의되어 있으므로 우리는 지정된 메소드에 커스텀 코드를 작성하기만 하면 앱의 생명 주기에 맞추어 원하는 내용을 실행시킬 수 있습니다.</p>
<p><br></p>
<p>(이만하고 우선 기본 문법으로 넘어가보자…!)</p>
<p><br></p>
<h4 id="스위프트-언어의-특징"><a href="#스위프트-언어의-특징" class="headerlink" title="스위프트 언어의 특징"></a>스위프트 언어의 특징</h4><p>스위프트는 파이썬이나 자바스크립트처럼 동적 바인딩(Dynamic Binding)을 채용하고 있는 언어는 아닙니다. C, C++, 오브젝티브-C, 자바처럼 정적 바인딩을 채용하고 있는 언어죠. 비록 데이터 타입 추론 기능에 의해 컴파일러가 알아서 변수와 상수의 타입을 결정하기 때문에 마치 동적 바인딩 언어인 것처럼 착각되기도 하지만, 기본적으로 스위프트는 정적 바인딩 언어입니다.</p>
<p><br></p>
<p>또한 스위프트는 데이터 타입에 대한 구분이 엄격합니다. 스위프트에서 선언된 변수와 상수는 컴파일 단계에서 데이터 타입이 미리 정의되어 있어야 하고, 일단 변수의 데이터 타입이 정의되면 다른 타입으로 변경할 수 없습니다. 이같은 엄격성을 바탕으로 컴파일러는 타입에 맞지 않는 데이터가 변수에 대입되는 것을 사전에 차단하여 안정성을 높일 수 있습니다.</p>
<p><br></p>
<p>스위프트는 네임스페이스를 사용하여 필요한 객체들을 참조하는데, 일반적으로 프로젝트 전체가 네임스페이스의 범위로 지정됩니다. 이는 같은 프로젝트 내에 작성된 객체일지라도 오브젝티브-C에서는 참조를 위해 일일이 헤더 파일을 반입해 주어야 했던 것과 다르게, 스위프트에서는 같은 프로젝트 내에 작성된 객체들은 반입 과정 없이 참조할 수 있다는 뜻입니다. 이 덕분에 스위프트에서 import 구문은 UIKit, Foundation 등의 프레임워크나 라이브러리 정도에만 사용하게 되어 개발 생산성을 향상할 수 있게 되었습니다.</p>
<p><br><br>자바스크립트 프로그래머들은 대괄호 구문을 이용하여 값을 배열로 만들거나 문자열을 입력받는데, 이것이 해시 테이블 역할을 합니다. 스위프트도 마찬가지입니다. 대괄호를 사용하여 해시 테이블을 만들 수 있죠. 애플에서는 이것을 딕셔너리라고 부르며, 초기화할 수 있는 구문을 제공합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports = [<span class="type">String</span>: <span class="type">String?</span>]()</span><br><span class="line">airports[<span class="string">"ICN"</span>] = <span class="string">"Inchon International Airport"</span></span><br><span class="line">airports[<span class="string">"ICN"</span>] = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="데이터-타입-추론-함수형-프로그래밍-언어"><a href="#데이터-타입-추론-함수형-프로그래밍-언어" class="headerlink" title="데이터 타입 추론 - 함수형 프로그래밍 언어"></a>데이터 타입 추론 - 함수형 프로그래밍 언어</h5><p>프로그래머 관점에서 변수를 특정 데이터 형식으로 강제하면 코드를 실행해 보기 전에 버그를 미리 잡을 수 있어 효율적입니다. 컴파일러가 데이터 형식을 확인하고 비호환성이 발견되면 오류를 검출해주기 때문입니다. 하지만 편리함을 추구하는 현대 프로그래밍에서 모든 변수마다 데이터 형식을 일일이 지정하는 고생을 감수할 사람은 그다지 많지 않습니다.</p>
<p><br></p>
<p>최근의 우수한 컴파일러들은 데이터로부터 스스로 형식을 추론할 수 있으므로 컴파일러가 알아서 변수에 데이터 형식을 지정할 수 있게 되었습니다. 데이터 타입은 강제하지만, 데이터 타입을 생략할 수 있는 스위프트 컴파일러의 발전 덕분에 iOS 개발자들도 이제 코드 입력에 드는 수고를 조금은 덜 수 있게 되었습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meaningOfLife = <span class="number">42</span></span><br><span class="line"><span class="comment">// meaningOfLife is inferred to be of type Int</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>(그러면 변수가 무엇인지 잠시 살펴보러 가자…)</p>
<p><br></p>
<h4 id="변수와-상수"><a href="#변수와-상수" class="headerlink" title="변수와 상수"></a>변수와 상수</h4><p>스위프트는 데이터가 저장되는 메모리 내 주소 공간을 개발자가 쉽게 인식하고 사용할 수 있도록 이름으로 연결한 변수와 상수를 제공합니다. 예를 들어 연도를 의미하는 1999라는 숫자 데이터가 메모리 주소 0x12345678~0x1234567B까지에 걸쳐 저장되어 있다고 해 봅시다. 숫자 데이터를 꺼내어 사용할 때마다 항상 이 주소값을 사용할 수 없습니다. 그러기엔 주소값이 너무 길고, 단순히 16진수 숫자들로 되어 있어 외우기도 어려기 때문입니다. 그래서 이 주소값을 “year”라는 이름으로 연결합니다.</p>
<p><br></p>
<p><img src="/image/ios3.png" alt="ios3"></p>
<p><br></p>
<p>우리가 “year”라는 단어를 특정 형식에 따라 사용하면 컴파일러는 내부에 저장된 메모리 주소록을 뒤져서 year라는 이름으로 연결된 0x12345678~0x1234567B까지의 주소를 확인하고, 각각의 주소에 저장된 값을 읽어와 하나로 합친 1999라는 데이터를 만들어 줍니다. 이름으로 메모리 주소를 등록해 두지 않았다면 저장된 값을 꺼내기 위해서는 주소 공간 하나하나를 직접 찾아 값을 합쳐서 사용해야 하지만, 이름을 저장해 놓는다면 year라는 인식하기 쉬운 단어만으로 저장된 값을 쉽게 불러올 수 있습니다.</p>
<p><br></p>
<p>이렇게 값을 저장한, 혹은 저장할 메모리 주소값을 이름으로 연결해 놓은 것을 변수와 상수라고 합니다. 우리는 변수와 상수를 이용하여 메모리 주소에 해당하는 공간에 손쉽게 값을 저장하거나 꺼낼 수 있습니다. 일반적으로 이같은 과정을 떠올리는 대신 변수와 상수에 값을 저장한다고 생각해도 무방합니다.</p>
<p><br></p>
<p>변수와 상수는 값을 저장할 수 있다는 공통점이 있지만, 상수는 한 번 저장된 값을 다른 값으로 변경할 수 없는 반면에 변수는 필요에 따라 저장된 값을 몇 번이라도 다른 값으로 변경할 수 있습니다. 그래서 변수에는 프로그램 실행에 따라 변하는 값을 저장하고, 상수에는 변하지 않을 값을 저장합니다.</p>
<p><br></p>
<p>하지만 변수라고 해서 아무 값이나 마음대로 저장할 수 있는 것은 아닙니다. 변수의 값을 변경할 때에는 처음 저장했던 값과 일치하는 타입이어야 합니다. 예를 들어, 변수에 처음 저장된 값이 정수였다면 이후로도 정수만 저장할 수 있습니다. 처음 저장한 값이 문자열이었다면 이후로 변경할 수 있는 값 역시 문자열뿐입니다. 즉 변수는 처음 입력한 값과 동일한 타입에 한해서만 값을 변경할 수 있습니다. 변경할 값이 처음 저장한 값과 일치하는 형태인지는 곧이어 자료형을 배우고 나면 알게 될 겁니다.</p>
<p><br></p>
<p>이쯤에서 상수가 왜 필요한지에 대해 궁금한 독자들이 있을지도 모르겠습니다. 변수에 값을 저장해 놓고 변경하지 않으면 그만이지, 왜 굳이 상수가 있어야 하냐 하고 말이죠. 하지만 성능이나 기타 다른 기술적 이점은 차치하고라도, 프로그래밍 소스 관리 목적상 변하지 않는 값은 상수에 저장하는 것이 훨씬 효율적입니다. 실수로 값이 변경되는 일도 막을 수 있고, 값의 성격이 명확히 분류되므로 관리하기에도 용이하기 때문입니다.</p>
<p><br></p>
<p>질문!! 억지로 다른 자료형의 값을 집어넣으면 어떻게 되죠? 오류가 발생합니다. 스위프트에서는 변수의 초기값이 지정되면 그 값에 의해 변수의 타입이 결정되고, 이후로는 타입의 변경이 불가능합니다. 따라서 억지로 다른 타입의 값을 집어넣으려고 한다면 이는 컴파일 오류로 이어지게 됩니다.</p>
<p><br></p>
<p>(무언가 공부에 효율이 안난다…Do it! 첫 앱 만들기)</p>
<p><br></p>
<ul>
<li>레이블 추가</li>
<li>버튼 추가</li>
<li>버튼 클릭시, 기존 레이블 변경</li>
</ul>
<ul>
<li>스토리보드에서 할일</li>
</ul>
<ul>
<li>레이블 추가하기</li>
<li>버튼 추가 하기</li>
<li>뷰 컨트롤러에 버튼 액션 연결하기</li>
</ul>
<ul>
<li>코드에서 할일</li>
</ul>
<ul>
<li>메소드 새로 추가하기</li>
</ul>
<p><br></p>
<p>이제 스토리보드를 사용하여 간단한 앱 화면을 꾸며 보겠습니다. 이 앱에서는 텍스트를 보여주는 레이블(Label) 객체와 사용자가 직접 글자를 입력할 수 있는 텍스트 필드(Text Field) 객체, 이름을 전송하는 버튼(Button) 객체를 사용합니다. 객체란 사용자 인터페이스를 위해 사용하는 레이블, 버튼 등의 오브젝트를 의미하며 라이브러리에서 가져와 사용할 수 있습니다. 스토리보드에 배치된 객체는 사용자로부터 입력을 받거나 사용자 인터페이스 역할을 합니다. 아래 그림은 완성된 스토리보드 화면입니다. 이 그림과 사용된 객체를 참고하여 배치해 보겠습니다.</p>
<p><br></p>
<p><img src="/image/ios4.jpeg" alt="ios4"></p>
<p><br></p>
<h5 id="1-레이블-추가하기"><a href="#1-레이블-추가하기" class="headerlink" title="1. 레이블 추가하기"></a>1. 레이블 추가하기</h5><p>먼저 ‘Welcome’이라는 메시지를 출력할 레이블을 추가해 보겠습니다.</p>
<p><br></p>
<h5 id="2-레이블-두-개-더-추가하기"><a href="#2-레이블-두-개-더-추가하기" class="headerlink" title="2. 레이블 두 개 더 추가하기"></a>2. 레이블 두 개 더 추가하기</h5><p>같은 방법으로 레이블을 두 개 더 추가합니다. 두 번째 레이블의 내용은 비워두고, 세 번째 레이블에는 ‘Name:’을 입력합니다.</p>
<p><br></p>
<h5 id="3-텍스트-필드-추가하기"><a href="#3-텍스트-필드-추가하기" class="headerlink" title="3. 텍스트 필드 추가하기"></a>3. 텍스트 필드 추가하기</h5><p>텍스트 필드는 사용자로부터 텍스트를 입력받을 때 사용하는 객체입니다. 여기서는 텍스트 필드를 사용하여 이름을 입력받고, 입력 완료의 의미로 버튼을 클릭하여 앱에 전달할 용도로 텍스트 필드와 버튼을 추가하여 배치해 보겠습니다.</p>
<p><br></p>
<h5 id="4-버튼-추가하기"><a href="#4-버튼-추가하기" class="headerlink" title="4. 버튼 추가하기"></a>4. 버튼 추가하기</h5><p><br></p>
<h5 id="5-레이블에-아웃렛-변수-추가하기"><a href="#5-레이블에-아웃렛-변수-추가하기" class="headerlink" title="5. 레이블에 아웃렛 변수 추가하기"></a>5. 레이블에 아웃렛 변수 추가하기</h5><p>스토리보드에 추가한 객체를 선택하고 내용을 변경하거나 특정 동작을 수행하도록 하기 위해서는 해당 객체에 접근할 수 있는 변수인 ‘아웃렛 변수’와 동작을 정의한 함수인 ‘액션 함수’가 필요합니다. 예를 들어 앞에서 만든 텍스트 필드에 사용자가 이름을 입력하면 입력한 텍스트를 받아 저장할 변수를 만들고, 만든 변수와 텍스트 필드를 연결시켜줘야 합니다. 이러한 변수를 아웃렛 변수라고 합니다. 그리고 [Send] 버튼을 클릭했을 때 입력한 이름을 읽어서 레이블에 출력하는 함수를 만들고 이 함수를 버튼과 연결시켜줘야 합니다. 이런 함수를 액션 함수라고 합니다.</p>
<p><br></p>
<h5 id="ViewController-swift"><a href="#ViewController-swift" class="headerlink" title="ViewController.swift"></a>ViewController.swift</h5><p><p><p></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> lblName: <span class="type">UILabel!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> txtName: <span class="type">UITextField!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>(위의 코드에서 !의 의미를 조금 더 파헤쳐 보자!)<br>(만약 !를 지우면 다음과 같은 오류가 나타난다…)</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> property has non-<span class="keyword">optional</span> type '<span class="type">UILabel'</span></span><br><span class="line"><span class="type">Add</span> '?' to form the <span class="keyword">optional</span> type '<span class="type">UILabel?</span>'</span><br><span class="line"><span class="type">Add</span> '!' to form an implicitly unwrapped <span class="keyword">optional</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위의 내용에 따라 ? 혹은 !을 붙여줘야 오류가 나지 않는다. 해당 라인에서는 변수를 선언할 때 콜론을 붙이고 그 타입을 명시적으로 선언해 줌으로써 어떤 타입의 값이 저장될 것인지를 컴파일러에게 직접 알려주고 있다. 그렇다면 UILabel 혹은 UITextField가 변수의 타입이라는 점을 유추해 볼 수 있는데, 기본 자료형이 아니라는 점에서 특정 클래스 정의에 따른 자료형, 즉 객체가 된다는 것일까?</p>
<p><br></p>
<p>아직 자신이 없으니 !을 좀 더 살펴보도록 하자. 이를 위해서는 옵셔널을 알아야 한다. 옵셔널 타입이란 반환하고자 하는 값을 옵셔널 객체로 다시 한 번 감싼 형태를 의미한다. 스위프트에서는 일단 오류가 발생할 가능성이 있기만 하면, 성공적으로 처리했더라도 일단 옵셔널 타입으로 감싸서 반환한다. 처리가 성공적일 경우, 옵셔널 타입으로 반환된 값을 열어보면 실제 값이 옵셔널 타입으로 둘러싸여 있는 것을 볼 수 있다. 이를 옵셔널 래핑(Optional Wrapping)이라고 한다. 이렇게 받은 값은 옵셔널 언래핑(Optional Unwrapping)이라고 불리는 특수한 처리 과정을 통해 옵셔널 타입을 해제하고 실제 값을 추출하여 사용해야 한다. 단, 처리 결과가 실패여서 옵셔널 타입의 값이 nil이라면 옵셔널 타입을 해체해서는 안 된다.</p>
<p><br></p>
<p>만약 위의 코드에서 var lblName: UILabel?로 선언한다면 옵셔널 타입으로 만들게 되는 것이다. 즉, Optional UILabel 타입을 의미하게 되며, 이로써 nil을 대입할 수 있다. 이렇게 전달받은 옵셔널 타입의 결과값은 그 자체로는 아무것도 할 수 없다. 옵셔널 타입은 애초에 연산을 지원하지 않는 타입이다. 따라서 옵셔널 타입과 일반 타입은 서로 연산할 수 없으며 옵셔널 타입끼리의 연산이나 결합도 지원하지 않는다.</p>
<p><br></p>
<p>이 옵셔널 값을 사용하는 방법에 대해 알아보면 위의 코드의 비밀이 서서히 풀린다. 우리가 결과값으로 전달받는 것이 Optional 객체인 것이다. 그 내부에 우리가 원하는 값이 들어있는 것이다. 이 값을 우리가 원하는 대로 사용하려면 실제 값을 둘러싼 옵셔널 객체를 해제해야 한다. 옵셔널 객체를 해제하면 일반 타입의 값이 되는데, 이 값이 비로소 우리가 직접 사용할 수 있는 값이다. 이처럼 옵셔널 객체를 해제하고 내부에 있는 값을 추출하는 과정을 옵셔널 해제, 혹은 옵셔널 언래핑이라고 하는 것이다.</p>
<p><br></p>
<p>옵셔널 해제 방식은 명시적 해제와 묵시적 해제로 나누어지는데, 위의 오류에서 알 수 있듯이 묵시적 해제는 각각 컴파일러에 의한 자동 해제와 연산자를 사용한 자동 해제로 나눌 수 있다. 위에서는 ! 연산자를 통한 자동 해제를 말하고 있다. 이렇게 처리해 주면 옵셔널 객체가 해제되고, 그 내부에 저장된 값을 꺼내 사용할 수 있게 된다. 자, 이제 다시 코드로 돌아가보자…</p>
<p><br></p>
<h5 id="6-버튼-클릭-시-동작할-함수-구현하기"><a href="#6-버튼-클릭-시-동작할-함수-구현하기" class="headerlink" title="6. 버튼 클릭 시 동작할 함수 구현하기"></a>6. 버튼 클릭 시 동작할 함수 구현하기</h5><p>[Send] 버튼을 클릭했을 때 동작할 btnSend 액션 함수를 다음과 같이 코딩합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">btnSend</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">    lblName.text = txtName.text!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="7-시뮬레이터로-결과-화면-확인하기"><a href="#7-시뮬레이터로-결과-화면-확인하기" class="headerlink" title="7. 시뮬레이터로 결과 화면 확인하기"></a>7. 시뮬레이터로 결과 화면 확인하기</h5><p><br></p>
<p><img src="/image/ios5.png" alt="ios5"></p>
<p><br><br></p>
<p>(자, 이제 답답함은 풀렸으니 다시금 문법편으로 돌아가자…)</p>
<p><br></p>
<h4 id="변수와-상수를-정의하는-방법"><a href="#변수와-상수를-정의하는-방법" class="headerlink" title="변수와 상수를 정의하는 방법"></a>변수와 상수를 정의하는 방법</h4><p>스위프트에서 변수와 상수는 반드시 먼저 선언한 다음에 사용해야 합니다. 이것은 ‘이러이러한 변수를 사용하겠다’ 또는 ‘이런 이름의 상수를 사용하겠다’라는 것을 컴파일러에게 알려주기 위함입니다. 마치 해외 여행 시 숙소를 정할 때 호텔에다 ‘이런이런 타입의 방을 XXX 이름으로 예약해주세요’라고 하는 것과 같다고 할까요? 변수와 상수를 정의하는 실제 구문을 살펴 보겠습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> year = <span class="number">1999</span> <span class="comment">// 정수형 변수</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello, World"</span> <span class="comment">// 문자열 변수</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>작성된 구문에서 두 개의 변수는 각각 정수 또는 문자열을 담을 목적으로 정의되었습니다. ‘=’ 연산자를 통해 대입된 값을 보면 알 수 있죠. year라는 이름을 가진 변수에는 1999라는 정수를 대입했으므로 정수형 타입의 변수가 되고, message라는 이름으로 정의된 변수에는 “Hello, World”라는 문자열을 대입했으므로 문자열 타입의 변수가 됩니다.</p>
<p><br></p>
<p>한번 정해진 타입은 바꿀 수 없어서, 정수형 타입의 변수에는 이후로도 정수만 대입할 수 있고, 문자열 타입의 변수에는 문자열만 대입할 수 있습니다. 스위프트에서 변수의 타입은 대부분 맨 처음 대입된 값에 따라 정해지고, 이후로는 타입을 변경할 수 없습니다. 마치 새끼 오리가 세상에 태어나 맨 처음 본 존재를 엄마로 삼는 것과 비슷하죠. var 키워드로 선언된 변수애 처음으로 값을 대입하는 과정을 초기화라고 합니다. 예제에서 본 것처럼, 대입 연산자를 이용하여 이루어지죠. 스위프트는 대부분 초기화 과정에서 변수의 타입이 결정되는데, 이때 활약하는 것이 바로 컴파일러입니다. 컴파일러는 변수에 대입될 값을 검토하여 가장 적절한 타입을 추론하고 그에 맞는 메모리 공간을 확보한 다음, 여기에 값을 저장합니다. 이때부터 우리는 해당 변수를 사용할 수 있게 됩니다.</p>
<p><br></p>
<p>타입에 따라 필요한 메모리 공간이 다르기 때문에, 변수의 타입을 결정하는 과정은 프로그래밍 언어의 성능과 효율성을 결정하는 중요한 요소가 되기도 햡니다. 4바이트만 있으면 충분함에도 확장성을 너무 고려한 나머지 8바이트나 그 이상의 공간을 잡아 놓는다면 그건 결국 메모리의 낭비로 이어질 테니까요. 이 때문에 스위프트는 ‘타입 추론기’라는 기능 모듈을 컴파일러에 별도로 내장하여, 항상 최적의 타입을 결정하고자 합니다.</p>
<p><br></p>
<p>(다 따라치면 오히려 효율이 떨어지네…그냥 코드만 남겨두자…!)</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello, playground"</span></span><br><span class="line"><span class="built_in">print</span>(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 선언과 초기화 분리</span></span><br><span class="line"><span class="keyword">var</span> year: <span class="type">Int</span>  <span class="comment">// 변수 선언</span></span><br><span class="line">year = <span class="number">1999</span>  <span class="comment">// 선언된 변수의 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수의 값 변경하기</span></span><br><span class="line"><span class="keyword">var</span> vValue = <span class="number">3</span></span><br><span class="line">vValue = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 상수의 값 변경하기</span></span><br><span class="line"><span class="keyword">let</span> cValue = <span class="number">3</span></span><br><span class="line"><span class="comment">// cValue = 7  오류: Cannot assign to value: 'cValue' is a 'let' constant</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수의 선언 및 초기화</span></span><br><span class="line"><span class="keyword">var</span> intValue = <span class="number">3</span>  <span class="comment">// Int 타입으로 초기화</span></span><br><span class="line"><span class="keyword">var</span> strValue = <span class="string">"Hello World"</span>  <span class="comment">// String 타입으로 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 새로운 값으로 변경</span></span><br><span class="line"><span class="comment">// intValue = "안녕하세요"  // Int 타입을 String 타입으로 변경 // 오류: Cannot assign value of type 'String' to type 'Int'</span></span><br><span class="line"><span class="comment">// strValue = 100  // String 타입을 Int 타입으로 변경 // 오류: Cannot assign value of type 'Int' to type 'String'</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="자료형"><a href="#자료형" class="headerlink" title="자료형"></a>자료형</h4><p>Int 자료형에 현미경을 들이대 봅시다. Int는 사실 SignedInteger를 구현한 구조체의 일종입니다. 지금은 Int 자료형이 ‘SignedInteger’라는 객체를 뼈대로 하여 만들어졌다는 정도만 이해하는 것으로 합시다.</p>
<p><br></p>
<p><img src="/image/ios6.png" alt="ios6"></p>
<p><br></p>
<p>소수점이 포함된 실수 값을 저장해야 하는 경우 사용할 수 있는 자료형이 Double 타입과 Float 타입입니다. 일반적으로 Float 타입이 소수점 아래 7~8자리까지의 값을 정확하게 저장할 수 있는 반면 Double 타입은 소수점 아래 15~16자리의 값에 대한 정확도를 보장하기 때문에 훨씬 더 세밀한 값을 저장하는 데 유리합니다. 당연히 메모리에서 차지하는 크기도 Double 타입이 더 크고 말이죠. 재미있는 것은 스위프트에서 Float 타입의 서브 자료형으로 사용되는 Float32와 Float64입니다. 이 둘은 실제로 존재하는 객체가 아니라 타입알리어스(typealias)에 의해 정의된 타입들입니다. 여기에서 타입알리어스란 타입을 가리키는 표현만 달리하는 것을 의미합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A 32-bit floating point type</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Float32</span> = <span class="type">Float</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// A 64-bit floating point type</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Float</span> <span class="number">64</span> = <span class="type">Double</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>문자열을 저장할 때 기존의 오브젝티브-C를 사용했던 분들이라면 NSString이라는 객체에 익숙할 텐데요. NSString 객체는 오브젝티브-C 언어용 String 타입이라고 생각하면 됩니다. 파운데이션 프레임워크에서 문자열을 쉽게 다루기 위해 제공하는 클래스이죠. 프레임워크 레벨에서 제공하는 객체이니만큼 import Foundation이라는 구문을 통해 프레임워크를 반입한 다음에야 사용할 수 있습니다. 하지만 String 타입은 스위프트 언어에서 제공되는 기본 자료형이므로 프레임워크 반입 없이도 사용할 수 있습니다. 스위프트의 String과 오브젝티브-C의 NSString은 서로 호환되기 때문에 NSString을 String으로, 또는 String을 NSString으로 변환할 수 있습니다. 따라서 오브젝티브-C에서 NSString으로 정의된 값을 스위프트에서 사용하려면 String 타입으로 변환하면 됩니다. 아, 물론 스위프트에서도 NSString을 사용할 수도 있습니다. import Foundationd이라는 구문을 사용하여 파운데이션 프레임워크만 반입하면 말이죠.</p>
<p><br></p>
<p>앞서 소개한 String은 여러 글자로 이루어진 문자열을 저장할 수 있는 일종이 집단 자료형이지만, Character는 한 개의 문자를 저장할 수 있는 단일 자료형입니다. String 타입에 저장된 문자열을 하나씩 분해하면 Character 타입이 됩니다.</p>
<p><br></p>
<h4 id="타입-추론과-타입-어노테이션"><a href="#타입-추론과-타입-어노테이션" class="headerlink" title="타입 추론과 타입 어노테이션"></a>타입 추론과 타입 어노테이션</h4><p>타입 어노테이션(Type annotation)이란, 변수나 상수를 선언할 때 그 타입을 명시적으로 선언해 줌으로써 어떤 타입의 값이 저장될 것인지를 컴파일러에게 직접 알려주는 문법입니다. 변수나 상수명 뒤에 콜론(:)을 붙이고, 이어서 저장될 값의 타입을 작성해주면 됩니다. 그런데 뭔가 이상하다고 느낀 것 없으세요? 지금까지는 변수나 상수를 선언할 때 타입을 명시해 준 적이 없었잖아요. 그냥 값만 넣어 초기화해줬을 뿐이죠. 어떻게 된 걸까요? 이 궁금증을 해소하기 위해 우리는 먼저 타입 추론에 대해 학습해 볼 필요가 있습니다. 타입 추론은 변수나 상수를 초기화할 때 입력된 값을 분석하여 변수에 적절한 타입을 컴파일러가 스스로 추론하는 기능입니다.</p>
<p><br></p>
<p>그렇다면 타입 어노테이션을 써야 할지 말아야 할지 고민이 될 때는 어떻게 해야 할까요? 결론부터 말하자면, 반드시 타입 어노테이션을 사용해야 하는 다음 두 가지 경우를 제외하면 타입을 명시적으로 선언하지 않아도 됩니다.</p>
<p>첫 번째] 선언과 초기화를 분리할 경우<br>타입 추론은 변수나 상수의 선언 시 입력된 초기값을 이용하여 가장 적절한 타입을 추론해 내는 과정입니다. 스위프트에서 변수와 상수는 선언하는 시점에서 타입이 결정되어야 하는데, 선언과 동시에 값을 초기화하면 자동으로 타입을 결정할 수 있어 타입 어노테이션이 필요 없습니다.</p>
<p><br></p>
<p>변수는 그렇다 치더라도, 상수는 선언과 초기화를 분리할 수 없으니 타입 어노테이션이 필요 없는 것 아니냐고 생각하는 분들을 위해 부연 설명드리자면 반드시 그런 것만은 아닙니다. 일반적으로 상수를 선언할 때 반드시 초기화를 함께 해주어야 하지만, 클래스나 구조체에서 멤버로 선언된 상수는 선언과 초기화가 동시에 이루어지지 않더라도 오류가 발생하지 않습니다. 단, 초기화 블록 내에서 상수의 값을 결정해 주어야 하지만요.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: <span class="type">String</span></span><br><span class="line">s = <span class="string">"Hello"</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"># error: cannot assign to value: 's' <span class="keyword">is</span> a '<span class="keyword">let</span>' constant</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>두 번째] 타입 추론으로 얻어지는 타입이 아닌, 다른 타입을 직접 지정할 필요가 있을 때</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Int 타입으로 정의 (타입 추론)</span></span><br><span class="line"><span class="keyword">var</span> temper1 = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(temper1)  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Float 타입으로 정의 (타입 어노테이션)</span></span><br><span class="line"><span class="keyword">var</span> temper2: <span class="type">Float</span> = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(temper2)  <span class="comment">// 3.0</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>스위프트에서는 문자열과 문자에 모두 큰따옴표를 사용합니다. 보통 이럴 때 컴파일러가 취할 수 있는 합리적인 판단은 더 넓은 범위의 타입으로 추론하는 것입니다. 따라서 타입 어노테이션 없이 변수나 상수에 한 글자 문자를 대입하면 컴파일러는 문자열로 추론하고, 해당 변수를 String 타입으로 정의합니다.</p>
<p><br></p>
<p>동일한 값이라도 마찬가지입니다. 타입 어노테이션을 작성한 것과 작성하지 않은 것은 엄연히 다른 결과를 나타냅니다. 아래 두 변수는 동일한 “C”라는 값으로 초기화되지만 타입 어노테이션이 명시된 변수는 Character 타입으로 선언되는 반면 타입 어노테이션이 생략된 변수는 String 타입으로 선언됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cValue: <span class="type">Character</span> = <span class="string">"C"</span>  <span class="comment">// Character</span></span><br><span class="line"><span class="keyword">var</span> sValue = <span class="string">"C"</span>  <span class="comment">// String</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="타입이-다른-변수끼리의-결합"><a href="#타입이-다른-변수끼리의-결합" class="headerlink" title="타입이 다른 변수끼리의 결합"></a>타입이 다른 변수끼리의 결합</h4><p>스위프트에서 서로 다른 타입의 변수나 상수끼리의 결합 연산은 허용되지 않습니다. 변수의 타입을 변경해서 결합해 보려고 해도, 한 번 타입이 정해지고 나면 다른 타입으로 변경할 수도 없죠. 타입이 서로 다른 변수, 예를 들어 문자열과 숫자를 결합하려면 어떻게 해야 할까요?</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stmt = <span class="string">"꼼꼼한 재은씨의 키는 "</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="number">185</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> heightStmt = stmt + <span class="type">String</span>(height)</span><br><span class="line"><span class="built_in">print</span>(heightStmt)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>앞의 예제에서 stmt와 height는 타입 추론에 따른 결과로 각각 String과 Int 타입입니다. 우리가 원하는 것은 이 두 개의 변수를 합하여 문자열을 만들어내는 것이지만, 서로 타입이 다르기 때문에 두 변수 간의 결합은 불가능합니다. stmt를 Int 타입으로 바꾸거나 height를 String 타입으로 바꿀 수도 없습니다. 일단 타입이 정해진 변수와 상수는 다른 타입으로 변경할 수 없으니까요.</p>
<p><br></p>
<p>변수의 값을 다른 타입으로 변경해야 할 필요가 있다면, 바꾸고자 하는 타입의 새로운 객체를 명시적으로 생성해야 합니다. 이떄의 객체는 보통 변수나 상수를 의미합니다. 다행히 스위프트의 기본 자료형 객체들은 다른 타입의 값을 자신의 타입에 맞게 변환하여 새로운 객체를 만드는 방법을 제공합니다. 정확하게 짚고 넘어갑시다. 정수값이나 기존의 변수를 문자열 타입으로 바꾸는 것이 아니라, 새로운 문자열 인스턴스를 만드는 것입니다. 기존의 변수에는 아무런 영향이 없이, 새로 생성하는 것이라는 점에 주의해야 합니다. </p>
<p><br></p>
<h4 id="문자열-템플릿"><a href="#문자열-템플릿" class="headerlink" title="문자열 템플릿"></a>문자열 템플릿</h4><p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 상수와 변수를 정의</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"꼼꼼한 재은씨"</span></span><br><span class="line"><span class="keyword">let</span> year = <span class="number">2014</span></span><br><span class="line"><span class="keyword">let</span> month = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> day = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 템플릿을 사용한 문자열 결합</span></span><br><span class="line"><span class="keyword">let</span> profile = <span class="string">"\(name)는 \(year)년 \(month)월 \(day)일에 출간되었습니다."</span></span><br><span class="line"><span class="built_in">print</span>(profile)</span><br><span class="line"><span class="comment">// 꼼꼼한 재은씨는 2014년 10월 1일에 출간되었습니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 상수 정의</span></span><br><span class="line"><span class="keyword">let</span> apple = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> banana = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> orange = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 출력할 구문을 문자열 템플릿으로 구성</span></span><br><span class="line"><span class="keyword">let</span> desc = <span class="string">"과일은 총 \(apple+banana+orange)개 입니다."</span></span><br><span class="line"><span class="built_in">print</span>(desc)</span><br><span class="line"><span class="comment">// 과일은 총 9개 입니다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="string">"1부터 5까지의 숫자의 합은 \(1+2+3+4+5)입니다."</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">// 1부터 5까지의 숫자의 합은 15입니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="범위-연산자"><a href="#범위-연산자" class="headerlink" title="범위 연산자"></a>범위 연산자</h4><p><br></p>
<p>닫힌 범위 연산자는 주어진 피연산자 a, b를 포함하는 범위를 나타내는 연산자입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> ... <span class="number">5</span> <span class="comment">// 1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>반 닫힌 범위 연산자는 반이란 반대가 아닌 절반을 이야기합니다. 해석하자면 절반만 닫힌 연산자를 뜻으로, 연산자의 양쪽 경계 중에서 왼쪽 경계는 포함하되 오른쪽 경계는 포함하지 않는 연산자입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> .. &lt; <span class="number">5</span> <span class="comment">// 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>닫힌 범위 연산자는 양쪽 값 모두 포함하는 특성 때문에 for~in 구문에서 일정 횟수만큼 반복할 때 사용되는 경우가 많습니다. 반면에, 반 닫힌 연산자는 마지막 값을 범위에 포함하지 않는 특성이 배열의 인덱스와 일치하기 때문에 배열을 순회할 때 많이 사용됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 닫힌 범위 연산자</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> a ... b&#123;</span><br><span class="line">    row</span><br><span class="line">&#125; <span class="comment">// 5 times</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 반 닫힌 범위 연산자</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> a ..&lt; b&#123;</span><br><span class="line">    row</span><br><span class="line">&#125; <span class="comment">// 4 times</span></span><br></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/25/fnlp-%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC-2/">
                [fnlp] 밑바닥부터 시작하는 자연어처리 (2)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-25</span>
            
            
            
                <span class="category">
                    <a href="/categories/natural-language-processing/">Natural Language Processing</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="밑바닥부터-시작하는-자연어처리-2"><a href="#밑바닥부터-시작하는-자연어처리-2" class="headerlink" title="밑바닥부터 시작하는 자연어처리 (2)"></a>밑바닥부터 시작하는 자연어처리 (2)</h1><h6 id="본-포스팅은-“한국어-임베딩-이기창-”을-바탕으로-“텍스트-마이닝-실전-및-분석-송민-”-강좌를-추가하여-정리한-내용입니다"><a href="#본-포스팅은-“한국어-임베딩-이기창-”을-바탕으로-“텍스트-마이닝-실전-및-분석-송민-”-강좌를-추가하여-정리한-내용입니다" class="headerlink" title="본 포스팅은 “한국어 임베딩(이기창)”을 바탕으로 “텍스트 마이닝 실전 및 분석(송민)” 강좌를 추가하여 정리한 내용입니다."></a>본 포스팅은 “한국어 임베딩(이기창)”을 바탕으로 “텍스트 마이닝 실전 및 분석(송민)” 강좌를 추가하여 정리한 내용입니다.</h6><p><br></br></p>
<h4 id="한국어-임베딩"><a href="#한국어-임베딩" class="headerlink" title="한국어 임베딩"></a>한국어 임베딩</h4><p></p>

<h5 id="02-벡터가-어떻게-의미를-가지게-되는가"><a href="#02-벡터가-어떻게-의미를-가지게-되는가" class="headerlink" title="02 벡터가 어떻게 의미를 가지게 되는가"></a>02 벡터가 어떻게 의미를 가지게 되는가</h5><p></p>

<p>2.1 자연어 계산과 이해<br>2.2 어떤 단어가 많이 쓰였는가</p>
<ul>
<li>백오브워즈 가정</li>
<li>TF-IDF</li>
<li>Deep Averaging Network<br>2.3 단어가 어떤 순서로 쓰였는가</li>
<li>통계 기반 언어 모델</li>
<li>뉴럴 네트워크 기반 언어 모델<br>2.4 어떤 단어가 같이 쓰였는가</li>
<li>분포 가정</li>
<li>분포의 의미(1): 형태소</li>
<li>분포의 의미(2): 품사</li>
<li>점별 상호 정보량</li>
<li>Word2Vec</li>
</ul>
<p><br></br></p>
<h5 id="제7강-벡터-공간-모델-1"><a href="#제7강-벡터-공간-모델-1" class="headerlink" title="제7강 벡터 공간 모델 1"></a>제7강 벡터 공간 모델 1</h5><p></p>

<ol>
<li>벡터 공간 모델</li>
<li>문헌-단어 매트릭스 생성</li>
<li>단어 가중치 기법</li>
</ol>
<p><br></br></p>
<p><hr><br><br></br></p>
<h4 id="자연어-계산과-이해"><a href="#자연어-계산과-이해" class="headerlink" title="자연어 계산과 이해"></a>자연어 계산과 이해</h4><p></p>

<p>컴퓨터는 자연어를 사람처럼 이해할 수 없다. 컴퓨터는 그저 계산기일 뿐이다. 그런데 임베딩을 활용하면 컴퓨터가 자연어를 계산하는 것이 가능해진다. 임베딩은 자연어를 컴퓨터가 처리할 수 잇는 숫자들의 나열인 벡터로 바꾼 결과이기 때문이다. 컴퓨터는 임베딩을 계산/처리해 사람이 알아들을 수 있는 형태의 자연어로 출력한다. 사람 말을 100% 이해하는 인공지능이 등장하더라도 그 이해의 본질은 계산이다.</p>
<p></p>

<p>그러면 임베딩에 자연어 의미를 어떻게 함축할 수 있을까. 그 비결은 자연어의 통계적 패턴 정보를 통째로 임베딩에 넣는 것이다. 자연어의 의미는 해당 언어 화자들이 실제 사용하는 일상 언어에서 드러나기 때문이다. 임베딩을 만들 때 쓰는 통계 정보는 크게 세 가지가 있다. 첫째는 문장에 어떤 단어가 (많이) 쓰였는지이고, 둘째는 단어가 어떤 순서로 등장하는지이며, 마지막으로는 문장에 어떤 단어가 같이 나타났는지와 관련한 정보다.</p>
<p><br></br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>구분</th>
<th style="text-align:center">백오브워즈 가정</th>
<th style="text-align:center">언어 모델</th>
<th style="text-align:right">분포 가정</th>
</tr>
</thead>
<tbody>
<tr>
<td>내용</td>
<td style="text-align:center">어떤 단어가 (많이) 쓰였는가</td>
<td style="text-align:center">단어가 어떤 순서로 쓰였는가</td>
<td style="text-align:right">어떤 단어가 같이 쓰였는가</td>
</tr>
<tr>
<td>대표 통계량</td>
<td style="text-align:center">TF-IDF</td>
<td style="text-align:center">-</td>
<td style="text-align:right">PMI</td>
</tr>
<tr>
<td>대표 모델</td>
<td style="text-align:center">Deep Averaging Network</td>
<td style="text-align:center">ELMo, GPT</td>
<td style="text-align:right">Word2Vec</td>
</tr>
</tbody>
</table>
</div>
<p><br></br></p>
<p>백오브워즈(bag of words) 가정에서는 어떤 단어가 (많이) 쓰였는지 정보를 중시한다. 저자의 의도는 단어 사용 여부나 그 빈도에서 드러난다고 보기 때문이다. 단어의 순서(order) 정보는 무시한다. 백오브워즈 가정에서 가장 많이 쓰이는 통계량은 Term Frequency-Inverse Document Frequency이며, 백오브워즈 가정의 딥러닝 버전은 Deep Averaging Network(lyyer et al. 2015)다.</p>
<p></p>

<p>단어의 등장 순서를 무시하는 백오브워즈 가정의 대척점에는 언어 모델(language model)이 있다. 언어 모델은 단어의 등장 순서를 학습해 주어진 단어 시퀀스가 얼마나 자연스러운지 확률을 부여한다. ELMo, GPT 등과 같은 뉴럴 네트워크 기반의 언어 모델이 여기에 해당한다.</p>
<p></p>

<p>분포 가정(distributional hypothesis)에서는 문장에서 어떤 단어가 같이 쓰였는지를 중요하게 따진다. 단어의 의미는 그 주변 문맥(context)을 통해 유추해볼 수 있다고 보는 것이다. 분포 가정의 대표 통계량은 점별 상호 정보량(PMI, Pointwise Mutual Information)이며 대표 모델은 Word2Vec을 꼽을 수 있다.</p>
<p></p>

<p>위의 세 철학은 서로 연관이 있다. 언어 모델에서는 단어의 등장 순서를, 분포 가정에서는 이웃 단어(문맥)을 우선시한다. 어떤 단어가 문장에서 주로 나타나는 순서는 해당 단어의 주변 문맥과 떼려야 뗼 수 없는 관계를 가진다. 한편 분포 가정에서는 어떤 단어 쌍이 얼마나 같이 자주 나타나는지와 관련한 정보를 수치화하기 위해 개별 단어 그리고 단어 쌍의 빈도 정보를 적극 활용한다. 예컨대 백오브워즈 가정, 언어 모델, 분포 가정은 말뭉치의 통계적 패턴을 서로 다른 각도에서 분석하는 것이며 상호 보완적이다.</p>
<p><br></br><br></p>
<h4 id="어떤-단어가-많이-쓰였는가"><a href="#어떤-단어가-많이-쓰였는가" class="headerlink" title="어떤 단어가 많이 쓰였는가"></a>어떤 단어가 많이 쓰였는가</h4><p><br></br></p>
<h5 id="백오브워즈-가정"><a href="#백오브워즈-가정" class="headerlink" title="백오브워즈 가정"></a>백오브워즈 가정</h5><p></p>

<p>수학에서 백(bag)이란 중복 원소를 허용한 집합(multiset)을 뜻한다. 원소의 순서는 고려하지 않는다. 자연어 처리 분야에엇 백오브워즈란 단어의 등장 순서에 관계없이 문서 내 단어의 등장 빈도를 임베딩으로 쓰는 기법을 말한다. 백오브워즈는 문장을 단어들로 나누고 이들을 중복집합에 넣어 임베딩으로 활용하는 것이라고 보면 된다. 아래 예시처럼 단어들의 빈도를 세어 놓은 것으로 이해하면 쉽다. 경우에 따라서는 빈도 역시 단순화해 등장 여부(등장 시 1, 아니면 0)만을 백오브워즈 임베딩으로 쓰기도 한다.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 텍스트 자료</span></span><br><span class="line">별 하나 에 추억 과</span><br><span class="line">별 하나 에 사랑 과</span><br><span class="line">별 하나 에 씁쓸함 과</span><br><span class="line">별 하나 에 동경 과</span><br><span class="line">별 하나 에 시 와</span><br><span class="line">별 하나 에 어머니, 어머니</span><br><span class="line"></span><br><span class="line"><span class="comment"># 백오브워즈 임베딩</span></span><br><span class="line"> 별 하나 에 추억 과 사랑 씁쓸 함 ... .</span><br><span class="line">[<span class="number">6</span>,  <span class="number">6</span>,  <span class="number">6</span>,  <span class="number">1</span>,  <span class="number">4</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>, ..., <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p></p>

<p>백오브워즈 임베딩에는 ‘저자가 생각한 주제가 문서에서의 단어 사용에 녹아 있다’는 가정이 깔려 있다. 다시 말해 주제가 비슷한 문서라면 단어 빈도 또는 단어 등장 여부 역시 비슷할 것이고, 백오브워즈 임베딩 역시 유사할 것이라고 보는 것이다. 빈도를 그대로 백오브워즈로 쓴다면 많이 쓰인 단어가 주제와 더 강한 관련을 맺고 있을 것이라는 전제 역시 깔려 있다. </p>
<p></p>

<p>백오브워즈 임베딩은 간단한 아이디어지만 정보 검색 분야에서 여전히 많이 쓰이고 있다. 사용자의 질의에 가장 적절한 문서를 보여줄 때 질의를 백오브워즈 임베딩으로 변환하고 질의와 검색 대상 문서 임베딩 간 코사인 유사도를 구해 유사도가 가장 높은 문서를 사용자에게 노출한다.</p>
<p><br></br><br></p>
<h4 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h4><p>단어 빈도 또는 등장 여부를 그대로 임베딩으로 쓰는 것에는 큰 단점이 있다. 어떤 문서에든 쓰여서 해당 단어가 (많이) 나타났다 하더라도 문서의 주제를 가늠하기 어려운 경우가 있기 때문이다. 예컨대 ‘을/를’, ‘이/가’ 같은 조사는 대부분의 한국어 문서에서 등장한다. 이에 우리는 ‘을/를’ 또는 ‘이/가’만으로는 해당 문서의 주제를 추측하기 어렵다.</p>
<p></p>

<p>이러한 단점을 보완하기 위해 제안된 기법이 Term Frequency-Inverse Document Frequency이다. 단어-문서 행렬에 아래 수식과 같이 가중치를 계산해 행렬 원소를 바꾼다. TF-IDF 역시 단어 등장 순서를 고려하지 않는다는 점에서 백오브워즈 임베딩이라고 이해할 수 있다.</p>
<p><br></br></p>
<script type="math/tex; mode=display">TF-IDF(w) = TF(w) \times log(\frac{N}{DF(w)})</script><p><br></br></p>
<p>수식에서 TF(Term Frequency)는 어떤 단어가 특정 문서에 얼마나 많이 쓰였는지 빈도를 나타낸다. 많이 쓰인 단어가 중요하다는 가정을 전제로 한 수치다. 예컨대 A라는 단어가 문서 1에서 10번, 문서 3에서 5번 쓰였다면 문서 1의 단어 A의 TF는 10, 문서 3의 단어 A의 TF는 5가 된다.</p>
<p></p>

<p>DF(Document Frequency)란 특정 단어가 나타난 문서의 수를 뜻한다. 만약 A라는 단어가 말뭉치 전체에서 문서 1, 문서 3에만 등장했다면 DF는 2가 된다. DF가 클수록 다수 문서에 쓰이는 범용적인 단어라고 볼 수 있겠다. TF는 같은 단어라도 문서마다 다른 값을 갖고, DF는 문서가 달라지더라도 단어가 같다면 동일한 값을 지닌다.</p>
<p></p>

<p>IDF(Inverse Document Frequency)는 전체 문서 수(N)를 해당 단어의 DF로 나눈 뒤 로그를 취한 값이다. 그 값이 클수록 특이한 단어라는 뜻이다. 이는 단어의 주제 예측 능력(해당 단어만 보고 문서의 주제를 가늠해볼 수 있는 정도)과 직결된다.</p>
<p></p>

<p>TF-IDF가 지향하는 원리는 이렇다. 어떤 단어의 주제 예측 능력이 강할 수록 가중치가 커지고 그 반대의 경우 작아진다. 한편 어떤 단어의 TF가 높으면 TF-IDF 값 역시 커진다. 단어 사용 빈도는 저자가 상정한 주제와 관련을 맺고 있을 것이라는 가정에 기초한 것이다.</p>
<p><br></br><br></p>
<h4 id="벡터-공간-모델"><a href="#벡터-공간-모델" class="headerlink" title="벡터 공간 모델"></a>벡터 공간 모델</h4><ul>
<li>텍스트 문서를 색인어와 같은 식별자(단어)들을 벡터로 나타내는 대수적인 모델</li>
<li>문서는 벡터로 표현되며, 각각의 차원은 개별 단어에 대응됨</li>
<li>만약 문서 내에 특정 단어가 포함되어 있다면, 벡터 내에서 해당 차원은 0이 아닌 값을 갖게 됨</li>
</ul>
<p><br></br></p>
<p>단순 벡터 공간 모델에 있어서는 단순 빈도, 즉 단어의 출현 빈도를 가지고 그 문헌을 표시하게 된다. 이를 통해 벡터 공간 모델을 만드는데, 이보다 더 의미 있는 분석을 하기 위해서는 단순 출현 빈도가 아닌 단어의 가중치를 이용하여 분할을 표현하게 되고, 벡터 공간 모델을 분석하게 된다. 가장 많이 쓰이는 단어 가중치 기법은 TF-IDF 값을 사용하는 것이다.</p>
<p></p>

<p>단어는 하나의 단어이거나 키워드 혹은 더 긴 구가 될 수 있다. 만약 단어가 단일어로 선택된다면, 벡터의 차원 수(Dimensionality)는 단어집(Vocabulary) 내의 단어들의 숫자(언어 자료 내에 들어 있는 개별 단어들의 숫자)가 된다. 즉 각각의 단어는 자질이 되고, 차원이 되어 이것들의 합은 단어집이 된다. 그리고 이 단어들의 숫자는 전체 문헌 집단에서 나타난 유일한(Unique) 단어의 집단의 합으로 단어집의 크기가 된다. </p>
<p></p>

<p>이러한 벡터 공간 모델을 만들기 위해서는 문서를 벡터화 해야 한다. 이때 문서를 벡터화 하는 작업이 굉장히 중요하다. 만약 정보 검색이라고 하면 정보 검색에 있어서는 질의어가 들어오면 질의어도 벡터화 한다. 이를 질의어 벡터라고 부를 수 있다. 그 다음에 색인된 문헌들, 즉 각각의 문헌들은 문헌 벡터가 된다. 그래서 질의어 벡터와 문헌 벡터 사이의 유사도를 구하여 각 유사도의 값이 높은 순서대로 정렬해서 이용자에게 그 검색 결과를 보여주는 것이 바로 벡터 공간 모델을 이용한 검색엔진이 된다.</p>
<p><br></br></p>
<ul>
<li>검색의 대상이 되는 문서 : $D_1, D_2, …, D_n$</li>
<li>문서 집합 전체에 걸친 총 m개의 색인어 : $w_1, w_2, …, w_m$</li>
<li>색인어 $w_i$의 문서 $d_j$에서의 가중치 :</li>
</ul>
<p></p>

<script type="math/tex; mode=display">d_j = \pmatrix{
d_{1j} \cr
d_{2j} \cr
\vdots \cr
d_{mj} \cr
}</script><p></p>

<ul>
<li>문서 집합 전체를 문헌*단어 행렬로 표현</li>
</ul>
<p></p>

<script type="math/tex; mode=display">D = \pmatrix{d_1 & d_2 & \ldots & d_n} = \pmatrix{
d_{11} & d_{12} & \ldots & d_{1n} \cr
d_{21} & d_{22} & \ldots & d_{2n} \cr
\vdots & \vdots & \ddots & \vdots \cr
d_{m1} & d_{m2} & \ldots & d_{mn} \cr
}</script><p></p>

<p>벡터 공간 모델에서 긴 문서들은 유사도 값이 작기 때문에 제대로 표현되지 않는다. 비슷한 의미를 갖고 있는 문서들일지라도 사용된 단어가 다르면 연관성을 갖지 못한다. 즉, 문헌 공간 모델을 만드는 데 있어서 각각의 단어는 독립된 단어라고 보기 때문에 비슷한 의미를 가진 단어라 하더라도 그것이 다른 독립된 단어로 잡히고 이럴 때 분석의 퀄리티가 떨어지게 된다. 또한 벡터 공간 표현에서는 단어들이 나타나는 순서가 무시되기 때문에 문맥 정보를 파악할 수 없다.</p>
<p></p>

<p><br></br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/15/edwith-%EC%9B%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B8%B0%EC%B4%88/">
                [edwith] 웹 프로그래밍 기초
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-15</span>
            
            
            
                <span class="category">
                    <a href="/categories/edwith/">edwith</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="edwith-웹-프로그래밍"><a href="#edwith-웹-프로그래밍" class="headerlink" title="[edwith] 웹 프로그래밍"></a>[edwith] 웹 프로그래밍</h1><p></p>

<h3 id="웹-프로그래밍-기초"><a href="#웹-프로그래밍-기초" class="headerlink" title="웹 프로그래밍 기초"></a>웹 프로그래밍 기초</h3><ol>
<li>웹에 대한 기본이해를 한다.</li>
<li>웹클라이언트와 웹백엔드의 역할을 안다.</li>
<li>HTML 구조화 설계를 할 수 있다.</li>
<li>CSS 기본 스타일을 꾸밀 수 있다.</li>
<li>JAVA 기반의 엡 백엔드 환경을 구성할 수 있다.</li>
<li>서블릿을 이해하고 기본 구성을 할 수 있다.</li>
</ol>
<p><br></br></p>
<p><hr><br><br></br></p>
<h4 id="1-웹-프로그래밍을-위한-프로그램-언어들"><a href="#1-웹-프로그래밍을-위한-프로그램-언어들" class="headerlink" title="1) 웹 프로그래밍을 위한 프로그램 언어들"></a>1) 웹 프로그래밍을 위한 프로그램 언어들</h4><p><br></br></p>
<h5 id="학습목표"><a href="#학습목표" class="headerlink" title="학습목표"></a>학습목표</h5><ol>
<li>다양한 프로그래밍 언어의 종류에 대하여 알아봅시다.</li>
<li>웹 프로그래밍에 좀 더 최적화된 프로그래밍 언어의 장단점에 대하여 알아봅니다.</li>
</ol>
<p></p>

<h5 id="핵심개념"><a href="#핵심개념" class="headerlink" title="핵심개념"></a>핵심개념</h5><ul>
<li>저급언어</li>
<li>고급언어</li>
<li>컴파일러</li>
</ul>
<p><br></br></p>
<h5 id="저급언어"><a href="#저급언어" class="headerlink" title="저급언어"></a>저급언어</h5><p>저급언어는 기계 중심의 언어라고 말할 수 있습니다. 기계가 직접 알아들을 수 있는 말로 프로그램 코드를 작성한다고 말할 수 있습니다. 컴퓨터는 전기로 동작합니다. 즉, 전기신호인 켜졌다(on)와 꺼졌다(off) 2가지 상태 값으로 동작한다고 말할 수 있습니다. 보통 숫자로 표현하면 켜졌다는 1, 꺼졌다는 0을 의미합니다. 0과 1로 표현되는 숫자를 우리는 2진수라고 말합니다. 2진수로 이뤄진 값으로 작성하는 프로그래밍 언어를 기계어(Machine Language)라고 말합니다. 숫자로만 되어 있기 때문에 유지보수도 굉장히 어렵습니다. 숫자로만 된 프로그래밍 언어는 사용이 굉장히 어려웠습니다. 그래서, 이 숫자로 된 문장과 1:1로 대응하는 기호를 만들고, 그 기호로 프로그래밍을 하게 되었습니다. 단 기호로 작성된 프로그램은 기계가 바로 알아들을 수 없기 때문에 기호로 작성된 문장들을 원래의 숫자로 바꿔야 하는 과정이 더 필요하게 되었습니다. 이러한 과정에서 사용되는 도구를 컴파일러(Compiler)라고 말하며, 이러한 기호로 작성된 언어를 어셈블리어(Assembly Language)라고 말합니다. 현재는 아주 특수한 경우를 제외하고는 기계어와 어셈블리어로 프로그램을 개발하는 경우는 거의 없습니다. 그만큼 프로그래밍이 어렵고 유지보수가 어렵기 때문입니다.</p>
<p><br></br></p>
<h5 id="고급언어"><a href="#고급언어" class="headerlink" title="고급언어"></a>고급언어</h5><p>고급언어는 사람 중심의 언어라고 말할 수 있습니다. 사람이 좀 더 이해하기 쉬운 문법으로 프로그래밍을 할 수 있습니다. 이런 일이 가능하기 위해선 작성된 소스코드를 번역하는 과정이 필요합니다. 이를 컴파일한다고 말하며, 이러한 일을 수행하는 것을 컴파일러라고 말합니다. 앞에서 어셈블리어도 기계어로 컴파일이 된다고 말했었죠? 컴퓨터 성능이 좋아지고, 컴파일러와 관련된 기술이 발전하면서 사람 중심의 언어로 프로그래밍할 수 있다고 생각하면 됩니다. 이러한 고급 언어로는 다음과 같은 언어들이 있습니다.</p>
<p></p>

<ul>
<li><p>FORTRAN : 최고의 고급언어 중의 하나라고 말할 수 있으며, 과학 계산용으로 주로 사용됩니다. 현재 공대에서도 많이 사용되고 있습니다.</p>
</li>
<li><p>COBOL : FORTRAN과 더불어 역사가 오래된 언어입니다. 일반 업무에서 사용할 목적으로 만들어졌으며, 현재도 은행 등에서 사용되고 있습니다.</p>
</li>
<li><p>PROLOG : 논리형 프로그래밍 언어로써, 논리식을 토대로 오브젝트와 오브젝트 간의 관계에 관한 문제를 해결하기 위해 사용됩니다.</p>
</li>
<li><p>C : 1972년 미국 벨 연구소의 데니스 리치에 의해 개발된 고급 언어로써 시스템 프로그래밍에 가장 적합한 평가를 받는 언어입니다.</p>
</li>
<li><p>Erlang : 스웨덴의 에릭슨에서 개발한 함수형 병행성 프로그래밍 언어이며 통신 인프라를 위한 언어입니다.</p>
</li>
<li><p>Lisp : LISt Processor의 약자로써 대표적인 함수형 언어입니다. 프로그래밍 언어의 역사를 말할 때, 현대의 컴퓨터를 위해 등장한 고급 언어 중 가장 오래된 것이 포트란이고, 두 번째로 오래된 것이 바로 이 리스프입니다. </p>
</li>
<li><p>Swift : 2014년 WWDC(Apple WorldWide Developers Conference)에서 공개한 프로그래밍 언어입니다. 최근에 만들어진 언어로 현대 프로그래밍 언어의 발전을 대다수 계승한 모던 프로그래밍 언어라고 말할 수 있습니다.</p>
</li>
<li><p>Kotlin : IntelliJ IDEA의 개발사 JetBrains에서 2011년에 개발한 프로그래밍 언어입니다. JVM기반의 언어이며 Java와의 상호 운영이 100% 지원됩니다. Swift와 마찬가지로 현대 프로그래밍 언어의 발전을 대다수 계승한 모던 프로그래밍 언어라 말할 수 있습니다.</p>
</li>
<li><p>Clojure : 클로저는 리치 히키가 만든 리스프 프로그래밍 언어의 방언으로서, 범용 함수형 언어입니다.</p>
</li>
<li><p>Python : 프로그래밍 입문자가 읽기 쉽고 적은 코드를 사용하여 프로그램을 개발할 수 있습니다. 많은 사람에게 추천되는 언어이며, 데이터 과학에서도 자주 사용되며 웹사이트 개발에서도 많이 사용되고 있습니다. 최근 python은 ML(Machine Learning)에서도 많이 사용됩니다.</p>
</li>
<li><p>JAVA : 1995년 썬 마이크로 시스템즈에서 개발한 객체지향 프로그래밍 언어입니다. 거의 매년 세계에서 가장 많이 사용되는 인기 1등을 차지하고 있습니다.</p>
</li>
</ul>
<p><br></br><br></p>
<h4 id="2-웹의-동작-HTTP-프로토콜-이해"><a href="#2-웹의-동작-HTTP-프로토콜-이해" class="headerlink" title="2) 웹의 동작 (HTTP 프로토콜 이해)"></a>2) 웹의 동작 (HTTP 프로토콜 이해)</h4><p><br></br></p>
<h5 id="학습목표-1"><a href="#학습목표-1" class="headerlink" title="학습목표"></a>학습목표</h5><ol>
<li>HTTP 프로토콜의 작동방식에 대하여 알아봅시다.</li>
<li>HTTP 프로토콜의 요청/응답 데이터 포맷에 대하여 알아봅시다.</li>
</ol>
<p><br></br></p>
<h5 id="HTTP-작동방식"><a href="#HTTP-작동방식" class="headerlink" title="HTTP 작동방식"></a>HTTP 작동방식</h5><ul>
<li>HTTP는 서버/클라이언트 모델을 따릅니다.</li>
<li><p>장점</p>
<ul>
<li>불특정 다수를 대상으로 하는 서비스에는 적합하다.</li>
<li>클라이언트와 서버가 계속 연결된 형태가 아니기 때문에 클라이언트와 서버 간의 최대 연결 수보다 훨씬 많은 요청과 응답을 처리할 수 있다.</li>
</ul>
</li>
<li><p>단점</p>
<ul>
<li>연결을 끊어버리기 때문에, 클라이언트의 이전 상황을 알 수가 없다.</li>
<li>이러한 특징을 무상태(stateless)라고 말한다.</li>
<li>이러한 특징 때문에 정보를 유지하기 위해서 cookie와 같은 기술이 등장하게 되었다.</li>
</ul>
</li>
</ul>
<p><br></br></p>
<h5 id="URI-Uniform-Resource-Locator"><a href="#URI-Uniform-Resource-Locator" class="headerlink" title="URI(Uniform Resource Locator)"></a>URI(Uniform Resource Locator)</h5><ul>
<li>인터넷 상의 자원의 위치</li>
<li>특정 웹 서버의 특정 파일에 접근하기 위한 경로 혹은 주소</li>
</ul>
<p><br></br></p>
<h5 id="HTTP-Hypertext-Transfer-Protocol"><a href="#HTTP-Hypertext-Transfer-Protocol" class="headerlink" title="HTTP(Hypertext Transfer Protocol)"></a>HTTP(Hypertext Transfer Protocol)</h5><ul>
<li>요청 메서드: GET, PUT, POST, PUSH, OPTIONS 등의 요청 방식이 온다.</li>
<li>요청 URI : 요청하는 자원의 위치를 명시한다.</li>
<li>HTTP 프로토콜 버전 : 웹 브라우저가 사용하는 프로토콜 버전이다.</li>
</ul>
<p></p>

<ul>
<li>GET : 정보를 요청하기 위해서 사용한다. (SELECT)</li>
<li>POST : 정보를 밀어넣기 위해서 사용한다. (INSERT)</li>
<li>PUT : 정보를 업데이트하기 위해서 사용한다. (UPDATE)</li>
<li>DELETE : 정보를 삭제하기 위해서 사용한다. (DELETE)</li>
<li>HEAD : (HTTP)헤더 정보만 요청한다. 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인하기 위해서 사용한다.</li>
<li>OPTIONS : 웹서버가 지원하는 메서드의 종류를 요청한다.</li>
<li>TRACE : 클라이언트의 요청을 그대로 반환한다. 예컨대 echo 서비스로 서버 상태를 확인하기 위한 목적으로 주로 사용한다.</li>
</ul>
<p><br></br><br></p>
<h4 id="3-웹-Front-End와-웹-Back-End"><a href="#3-웹-Front-End와-웹-Back-End" class="headerlink" title="3) 웹 Front-End와 웹 Back-End"></a>3) 웹 Front-End와 웹 Back-End</h4><p><br></br></p>
<h5 id="학습목표-2"><a href="#학습목표-2" class="headerlink" title="학습목표"></a>학습목표</h5><ol>
<li>웹프론트엔드에 대한 역할과 기술적 구성</li>
<li>웹백엔드에 대한 역할과 기술적 구성</li>
</ol>
<p><br></br><br></p>
<h4 id="4-브라우저의-동작"><a href="#4-브라우저의-동작" class="headerlink" title="4) 브라우저의 동작"></a>4) 브라우저의 동작</h4><p>웹을 통해서 전달되는 데이터는 어딘가에서 해석돼야 합니다. 서버에서 전송한 HTML과 같은 데이터가 클라이언트에 도착해야 할 곳은 브라우저입니다. 브라우저에는 데이터를 해석해주는 파서와 데이터를 화면에 표현해주는 렌더링엔진이 포함되어 있습니다. 이런 작업의 대부분은 브라우저 내부에서 이뤄지기 때문에 반드시 알아야 하는 것은 아닙니다. 하지만 브라우저의 내부를 이해하면 웹 개발을 하면서 맞닥뜨리는 난해한 문제를 해결할 수 있고, 보다 최적화된 웹개발을 할 수 있습니다.</p>
<p><br></br></p>
<h5 id="학습목표-3"><a href="#학습목표-3" class="headerlink" title="학습목표"></a>학습목표</h5><ol>
<li>HTML 파일이 올 때 브라우저가 어떻게 렌더링과정을 거쳐서 화면에 보이게 되는지 간단히 이해한다.</li>
</ol>
<p><br></br></p>
<p>브라우저는 월드와이드웹(WWW)에서 정보를 검색, 표현하고 탐색하기 위한 소프트웨어입니다. 인터넷에서 특정 정보로 이동할 수 있는 주소 입력창이 있고 서버와 HTTP로 정보를 주고 받을 수 있는 네트워크 모듈도 포함하고 있습니다. 그리고 서버에서 받은 문서(HTML, CSS, Javascript)를 해석하고 실행하여 화면에 표현하기 위한 해석기(Parser)들을 가지고 있습니다. 브라우저마다 서로 다른 엔진을 포함하고 있습니다.</p>
<p></p>

<p>HTML을 해석하기 위해서 DOM Tree를 만들고, CSS를 해석해서 역시 CSS Tree(CSS Object Model)을 만듭니다. 이 과정에서 Parsing 과정이 필요하며 토큰 단위로 해석되는 방식은 일반적인 소스코드의 컴파일 과정이라고 보시면 됩니다. DOM Tree와 CSS Tree, 이 두 개는 연관되어 있으므로 Render Tree로 다시 조합됩니다. 이렇게 조합된 결과는 화면에 어떻게 배치할지 크기와 위치 정보를 담고 있습니다. 이후에 이렇게 구성된 Render Tree 정보를 통해서 화면에 어떤 부분에 어떻게 색칠을 할지 Painting 과정을 거치게 됩니다.</p>
<p><br></br><br></p>
<h4 id="5-브라우저에서의-웹-개발"><a href="#5-브라우저에서의-웹-개발" class="headerlink" title="5) 브라우저에서의 웹 개발"></a>5) 브라우저에서의 웹 개발</h4><p>웹 클라이언트 코드는 브라우저 안에서 동작합니다.</p>
<p><br></br></p>
<h5 id="학습목표-4"><a href="#학습목표-4" class="headerlink" title="학습목표"></a>학습목표</h5><ol>
<li>HTML 요청 이후 브라우저에서 해석되는 웹페이지 안의 내용구성과 소스코드를 어떻게 위치시키면될지 이해한다.</li>
</ol>
<p><br></br></p>
<h5 id="알게-된-몇-가지-특징"><a href="#알게-된-몇-가지-특징" class="headerlink" title="알게 된 몇 가지 특징"></a>알게 된 몇 가지 특징</h5><ul>
<li>HTML문서는 html이라는 태그로 시작해서 html태그로 끝난다.</li>
<li>head는 무엇을 하는걸까?</li>
<li>body는?</li>
<li>HTML은 계층적이다!</li>
<li>HTML은 tag를 사용해서 표현한다.</li>
<li>JavaScript와 CSS가 html 안에 여기저기 존재한다.</li>
</ul>
<p><br></br></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width-device=width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Boostcourse<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      div&#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">      alert(1)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    alert(2)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p></p>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width-device=width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Boostcourse<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>웹프론트엔드<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p></p>

<h6 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"main.js 코드입니다."</span>)</span><br></pre></td></tr></table></figure>
<p></p>

<p>HTML 문서 안에 HTML 태그뿐 아니라 CSS, JavaScript 코드가 존재합니다.<br>JavaScript 코드는 body 태그가 닫히기 전에 위치하는 것이 랜더링을 방해하지 않아 좋고, CSS 코드는 head 안에 위치해서 렌더링 처리 시에 브라우저가 더 빨리 참고할 수 있게 하는 것이 좋습니다.</p>
<p><br></br><br></p>
<h4 id="6-웹-서버"><a href="#6-웹-서버" class="headerlink" title="6) 웹 서버"></a>6) 웹 서버</h4><p>웹 브라우저를 실행한 후 주소 입력창에 URL 주소를 입력하면, 그 URL 주소에 해당하는 결과물이 화면에 보입니다. 우리가 현실에서 주소를 보고 집을 찾아가는 것처럼, 웹브라우저는 URL 주소에 해당하는 웹서버에 연결하고, 해당 주소에서 볼 수 있는 내용을 읽어 들여 보여주게 됩니다. 웹 브라우저의 요청을 받아 HTML 문서나 오브젝트를 반환하는 웹 서버에 대하여 알아보도록 하겠습니다.</p>
<p><br></br></p>
<h5 id="웹-서버란"><a href="#웹-서버란" class="headerlink" title="웹 서버란?"></a>웹 서버란?</h5><ul>
<li>웹 서버는 소프트웨어를 보통 말하지만, 웹 서버 소프트웨어가 동작하는 컴퓨터를 말한다.</li>
<li>웹 서버의 가장 중요한 기능은 클라이언트가 요청하는 HTML문서나 각종 리소스를 전달하는 것입니다.</li>
<li>웹 브라우저나 웹 크롤러가 요청하는 리소스는 컴퓨터에 저장되어 있는 정적(static)인 데이터이거나 동적인 결과가 될 수 있다.</li>
</ul>
<p><br></br></p>
<p>웹 브라우저는 웹 서버로부터 전송받은 HTML 문서를 읽어들인 후에 해석을 합니다. HTML 문서를 알맞게 보여주기 위해서 필요한 이미지, CSS, JavaScript와 같은 리소들에 대해서 URL을 추출합니다. 웹 서버에게 동시에 여러 개의 리소스를 요청하게 됩니다. 웹 서버는 동시에 요청한 여러 개의 요청을 받아들여 그 결과를 브라우저에게 전송합니다. 웹 브라우저는 아까 해석했던 HTML 문서와 읽어들인 여러 개의 응답을 하나로 합쳐 그 결과를 화면에 보이게 하는 겁니다.</p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/4/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo" target="_blank" rel="noopener">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/05/17/hackerrank-intro-to-conditional-statements/">[HackerRank] Intro to Con</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/05/17/hackerrank-operator/">[HackerRank] Operators</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/05/13/hackerrank-data-types/">[HackerRank] Data Types</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/05/05/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%8F%84%EC%A0%84%EA%B8%B0-8/">[iOS] 앱 개발 도전기 (8)</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/algorithm/selection-sort/">selection sort</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/vuejs/">vuejs</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/algorithm/graph/">graph</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/computational-modeling/">Computational Modeling</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

</body>

</html>