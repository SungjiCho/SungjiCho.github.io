<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="밑바닥부터 시작하는 iOS 앱 개발 (2)
본 포스팅은 “꼼꼼한 재은씨의 Swift: 문법편”과 “Do it! 스위프트로 아이폰 앱 만들기(입문)”를 정리한 내용입니다.

꼼꼼한 재은씨의 Swift: 문법편CHAPTER 04 흐름 제어 구문: 코드의 활용성을 높여주는 ">
    

    <!--Author-->
    
        <meta name="author" content="Sunny Cho">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="[IOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (2)"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="QuantPsy"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>[IOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (2) - QuantPsy</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2020/02/20/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%8F%84%EC%A0%84%EA%B8%B0-2/">
                [IOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (2)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-20</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h1 id="밑바닥부터-시작하는-iOS-앱-개발-2"><a href="#밑바닥부터-시작하는-iOS-앱-개발-2" class="headerlink" title="밑바닥부터 시작하는 iOS 앱 개발 (2)"></a>밑바닥부터 시작하는 iOS 앱 개발 (2)</h1><p><br></p>
<h5 id="본-포스팅은-“꼼꼼한-재은씨의-Swift-문법편”과-“Do-it-스위프트로-아이폰-앱"><a href="#본-포스팅은-“꼼꼼한-재은씨의-Swift-문법편”과-“Do-it-스위프트로-아이폰-앱" class="headerlink" title="본 포스팅은 “꼼꼼한 재은씨의 Swift: 문법편”과 “Do it! 스위프트로 아이폰 앱"></a>본 포스팅은 “꼼꼼한 재은씨의 Swift: 문법편”과 “Do it! 스위프트로 아이폰 앱</h5><p> 만들기(입문)”를 정리한 내용입니다.</p>
<p><br></p>
<h4 id="꼼꼼한-재은씨의-Swift-문법편"><a href="#꼼꼼한-재은씨의-Swift-문법편" class="headerlink" title="꼼꼼한 재은씨의 Swift: 문법편"></a>꼼꼼한 재은씨의 Swift: 문법편</h4><h5 id="CHAPTER-04-흐름-제어-구문-코드의-활용성을-높여주는-도구들"><a href="#CHAPTER-04-흐름-제어-구문-코드의-활용성을-높여주는-도구들" class="headerlink" title="CHAPTER 04 흐름 제어 구문: 코드의 활용성을 높여주는 도구들"></a>CHAPTER 04 흐름 제어 구문: 코드의 활용성을 높여주는 도구들</h5><p>

<ul>
<li>4.1 반복문</li>
<li>4.2 조건문</li>
<li>4.3 제어 전달문</li>
</ul>
<p><br></p>
<h5 id="CHAPTER-05-집단-자료형-연관된-데이터를-손쉽게-다루기"><a href="#CHAPTER-05-집단-자료형-연관된-데이터를-손쉽게-다루기" class="headerlink" title="CHAPTER 05 집단 자료형: 연관된 데이터를 손쉽게 다루기"></a>CHAPTER 05 집단 자료형: 연관된 데이터를 손쉽게 다루기</h5><p>

<ul>
<li>5.1 배열</li>
<li>5.2 집합</li>
<li>5.3 튜플</li>
<li>5.4 딕셔너리</li>
</ul>
<p><br></p>
<p><hr><br><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> <span class="number">1940</span> … <span class="number">2017</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(“\(year)년도”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이번에는 for ~ in 구문을 시용하여 문자열의 문자를 순회하는 방법을 알아봅시다. 이<br>들 개별 문자는 순서를 이룬 채 연결되어 하나의 문자열을 구성하므로 이 역시 순회<br>대상으로 사용할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">"swift"</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> lang&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"개별 문자는 \(char)입니다"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> padChar = <span class="string">"0"</span></span><br><span class="line"><span class="keyword">var</span> keyword = <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...size&#123;</span><br><span class="line">    keyword = padChar + keyword</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(keyword)"</span>) <span class="comment">// 000003</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">10</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">10</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(i) X \(j) = \(i*j)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>while 키워드 다음에는 조건식이 사용되는데, 조건식은 반드시 참이나 거짓을 결과값<br>으로 반환해야 합니다. 이 조건식의 값이 true인 동안은 실행 블록 내의 코드가 반복<br>해서 수행되지만, false를 반환하면 그 즉시 반복문의 실행은 종료되고 코드 블록을<br>빠져나가 바로 다음에 이어지는 구문을 실행하게 됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">1000</span>&#123;</span><br><span class="line">    n = n * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"n = \(n)"</span>)  <span class="comment">// 1024</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>대부분 무한 반복되는 코드는 치명적인 문제가 되곤 하지만, 언제나 그런 것은 아닙니다. 터치나 클릭 등 사용자의 액션과 이벤트에 의해 동작하는 모바일 앱은 특성상 사<br>용자의 액션을 기다리는 동안 입력 대기 상태를 유지하는데, 앱이 종료되지 않은 채로 대기 상태를 유지하기 위해 이벤트 루프라고 불리는 무한 루프를 만들어 실행합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span>&#123;</span><br><span class="line">    n = n * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"n = \(n)"</span>)  <span class="comment">// 2048</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="guard-구문"><a href="#guard-구문" class="headerlink" title="guard 구문"></a>guard 구문</h4><p>guard 구문은 if 구문과 마찬가지로 주어진 표현식의 결과가 참인지 거짓인지에 따라 구문의 실행 여부를 결정짓는 방식의 조건문입니다. if 구문과의 차이점은 guard 구문에는 else 블록이 필수이지만, 표현식의 결과가 참일 때 실행되는 블록이 없다는 점입니다. guard 구문은 주로 후속 코드들이 실행되기 전에 특정 조건을 만족하는지 확인<br>하는 용도로 사용합니다. 다시 말해 특정 조건을 만족하지 않은 채로 후속 코드를 실<br>행하면 심각한 오류가 발생할 경우에, 전체 구문을 조기 종료(Early Exit)하기 위한<br>목적으로 사용되는 것이 guard 구문입니다. 따라서 guard 구문의 else 블록에는 이후<br>의 코드 진행을 막아주는 구문이 반드시 포함되어야 합니다. return 또는 break 구문 등이 이에 해당하죠.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(base: Int)</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">100</span> / base</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위의 함수에서는 입력받은 값이 0이 아닐 때에만 함수 내에 코드를 실행하고, 그렇지 않을 경우에는 함수의 실행을 중지해야 합니다. 이런 경우를 제어하기 위해 guard 구<br>문을 사용합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(base: Int)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> base != <span class="number">0</span> <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"연산할 수 없습니다."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">100</span> / base</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>함수의 실행을 종료할 때는 return 구문을 사용합니다. 이후의 코드가 남아있더라도<br>더 이상 진행하지 않은 채로 함수가 종료됩니다. divide 함수는 입력받은 인자값이 0<br>이면 guard 구문의 조건을 만족하지 못합니다. 이 때에는 else 블록 내부에 작성된 return 구문이 실행되어 이후의 코드를 실행하지 않은 채로 종료됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(base: Int)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> base != <span class="number">0</span> <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"연산할 수 없습니다."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> base &gt; <span class="number">0</span> <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"base는 0보다 커야 합니다."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> base &lt; <span class="number">100</span> <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"base는 100보다 작아야 합니다."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">100</span> / base</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="switch-구문"><a href="#switch-구문" class="headerlink" title="switch 구문"></a>switch 구문</h4><p>switch 구문은 앞에서 다룬 if와 guard처럼 분기문의 일종이지만, 처리 방식은 앞에서와 다릅니다. switch 구문은 입력받은 값을 조건식 여부가 아니라 패턴으로 비교하고 그 결과를 바탕으로 실행 블록을 결정하는 조건문입니다. 모든 switch 구문은 case 키워드로 시작하는 여러 가능한 패턴을 나열하는 방식으로 구성됩니다. 비교 대상과 비<br>교 패턴이 일치할 경우 그에 해당하는 구문이 실행된 후 나머지 case에 대한 비교 없<br>이 switch 구문을 종료하고, switch 구문 다음에 나오는 실행 블록으로 진행합니다.<br>만약 비교 패턴 어느 것과도 일치하지 않았다면, 맨 마지막에 작성된 default 구문의 코드가 실행됩니다.</p>
<p><br></p>
<p>스위프트의 switch 구문은 일치하는 비교 패턴이 있을 경우 해당 블록의 실행 코드를 처리하고, 더 이상의 비교 없이 전체 분기문을 종료합니다. 설사 일치하는 패턴이 여<br>러 개 있더라도 맨 처음 일치하는 case 구문 하나만 실행하죠. 오직 하나의 case 구문만 처리하고 나면 더이상 비교를 진행하지 않습니다. 다른 언어에서 switch 구문의 각 case 키워드 블록마다 추가해야 하는 break 구문을 스위프트에서 생략할 수 있는 것<br>든 이 때문입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> val &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"일치한 값은 1입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"일치한 값은 2입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"일치한 값 2가 더 있습니다."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"어느 패턴과도 일치하지 않습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일치한 값은 2입니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>스위프트는 명시적으로 fallthrough 구문을 사용할 수 있습니다. fallthrough 구문이 사용된 case 블록은 비교 패턴이 일치할 경우 인접한 case 블록으로 실행흐름을 전달<br>합니다. fallthrough에 의해 실행 흐름을 전달받은 case 블록은 비교 패턴의 일치 여<br>부와 상관 없이 작성된 구문을 실행한 후 switch 구문을 종료합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleChar: <span class="type">Character</span> = <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> sampleChar&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"글자는 A입니다."</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"일치하는 글자가 없습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 글자는 A입니다.</span></span><br><span class="line"><span class="comment">// 일치하는 글자가 없습니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>스위프트에서 switch 구문에 사용된 비교 대상은 반드시 하나의 비교 패턴과 일치해야 합니다. 비교 대상이 비교 패턴 중 어느 것과도 일치하지 않아 분기문 내의 어떤 블<br>록도 실행되지 못하는 경우를 switch 구문이 실해(fail)했다고 부르는데, 스위프트는 이같이 실패한 switch 구문을 완전한 비교 패턴을 구성하지 못한 것으로 간주합니다. 이에 따라 모든 case 구문에서 일치된 패턴을 찾지 못했을 경우에 대비하여 switch 구문에는 반드시 default 구문을 추가해야 하며, 만약 default 구문을 생략하면 완전하<br>지 않은 구문으로 간주하여 오류가 발생합니다. 단, default 구문을 대신하여 모든 패턴을 매칭시킬 수 있는 구문이 존재하는 경우에 한하여 default 구문을 생략할 수 있<br>습니다.</p>
<p><br></p>
<p>case 비교 패턴을 작성할 때, 하나의 case 키워드 다음에 하나 이상의 비교 패턴을 연이어 작성할 수 있습니다. 두 가지 이상의 패턴에 대해 같은 구문을 실행해야 한다면, 하나의 case 키워드로 비교 패턴을 묶어 표현하면 됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> value&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"0 또는 1입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2 또는 3입니다."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"default입니다."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>case 구문에서 사용되는 비교 패턴으로 단순히 서로 다른 패턴들 외에 튜플이나 특정 타입으로 캐스팅된 객체도 사용할 수 있습니다. 튜플은 집단 자료형으로셔, 괄호로 묶인 이형 집단 데이터입니다.  switch 구문에서 튜플 내부의 아이템이 비교 대상과 부<br>분적으로 일치할 경우, 스위프트는 case 구문의 비교 패턴 전체가 일치하는 것으로 간주합니다. 이때 일치하지 않는 나머지 부분을 상수나 변수화하여 사용할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple = (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> tuple&#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"튜플의 두 번째 값이 3일 때 첫 번째 값은 \(x)입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">2</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"튜플의 첫 번째 값이 2일 때 두 번째 값은 \(y)입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"튜플의 값은 각각 \(x), \(y)입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 튜플의 두 번째 값이 3일 때 첫 번째 값은 2입니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 예제에서 첫 번째 비교 구문에 사용된 튜플은 비교 대상과 부분적으로 일치합니다. 따라서 일치하지 않는 첫 번째 아이템을 변수로 처리하면 switch 구문의 비교 조건을 만족시키게 됩니다. 이렇게 만들어진 변수 x는 우리가 필요로 하는 곳에 사용할 수<br>있습니다.</p>
<p><br></p>
<p>아래 코드는 글이 작성된 시각을 단순하게 YYYY-MM-DD hh:mm:ss 형식으로 보여주는 대신, 자연스러운 구문으로 전환하여 표현합니다. 경과 시간을 입력받아 1분 이내라면 “방금”, 한 시간 이내라면 “조금 전”, 하루 이내라면 “얼마 전”으로 표현해주는 분기문을 구성하는데, 이때 case 구문의 값 비교를 위해 switch 구문의 범위 연산자가 사용<br>됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> passtime = <span class="number">1957</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> passtime&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>..&lt;<span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"방금 작성된 글입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">60</span>..&lt;<span class="number">3600</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"조금 전 작성된 글입니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3600</span>..&lt;<span class="number">86400</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"얼마 전 작성된 글입니다."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"예전에 작성된 글입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 조금 전 작성된 글입니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple = (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> tuple&#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">2</span>..&lt;<span class="number">5</span>, <span class="number">0</span>..&lt;<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"범위 A에 포함되었습니다."</span>)</span><br><span class="line"><span class="keyword">case</span>(<span class="number">0</span>..&lt;<span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"범위 B에 포함되었습니다."</span>)</span><br><span class="line"><span class="keyword">case</span>(<span class="number">2</span>..&lt;<span class="number">5</span>, <span class="number">3</span>..&lt;<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"범위 C에 포함되었습니다."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"범위 D에 포함되었습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 범위 C에 포함되었습니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = (<span class="number">3</span>, -<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> point &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(x)와 \(y)는 x==y 선 상에 있습니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == -y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(x)와 \(y)는 x==-y 선 상에 있습니다."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(x)와 \(y)는 일반 좌표상에 있습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3와 -3는 x==-y 선 상에 있습니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="number">0</span>...<span class="number">5</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> row &gt; <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(row) was executed!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 was executed!</span></span><br><span class="line"><span class="comment">// 1 was executed!</span></span><br><span class="line"><span class="comment">// 2 was executed!</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="number">0</span>...<span class="number">5</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> row &lt; <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"executed data is \(row)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// executed data is 2</span></span><br><span class="line"><span class="comment">// executed data is 3</span></span><br><span class="line"><span class="comment">// executed data is 4</span></span><br><span class="line"><span class="comment">// executed data is 5</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 continue 구문 예제는 루프 상수인 row의 값이 2보다 작을 때는 실행을 여기에서<br>멈추고 다시 루프를 시작할 것이라는 뜻입니다. continue 구문의 실행 방식을 이해했<br>나요? 이 구문의 특성을 이용하면 다음과 같이 특정 문자만 필터링하거나 다른 문자로 변경하는 코드를 작성할 수도 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> text&#123;</span><br><span class="line">    <span class="keyword">if</span> char == <span class="string">" "</span>&#123; <span class="comment">// 공백은 _로 변경한다.</span></span><br><span class="line">        <span class="comment">//result += "_"</span></span><br><span class="line">        result.append(<span class="type">Character</span>(<span class="string">"_"</span>))</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> char == <span class="string">"o"</span>&#123; <span class="comment">// 소문자 o는 대문자 O로 변경한다.</span></span><br><span class="line">        <span class="comment">//result += "O"</span></span><br><span class="line">        result.append(<span class="type">Character</span>(<span class="string">"O"</span>))</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.append(char)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">// This_is_a_swift_bOOk_fOr_Apple's_prOgramming_language</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1에서 5까지 반복</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span>&#123;</span><br><span class="line">    <span class="comment">// 1에서 9까지 반복</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">9</span>&#123;</span><br><span class="line">        <span class="comment">// j의 값이 3일 때 break 구문을 실행한다.</span></span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">3</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 구구단을 출력한다.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(i) X \(j) = \(i*j)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line"><span class="number">1</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">6</span></span><br><span class="line"><span class="number">4</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이같은 일련의 코드 흐름 결과를 통해 우리는 중첩된 반복문 내에 break 문이 있을 때는 이 구문을 둘러싼 인접 반복문에만 작용한다는 것을 알 수 있습니다. 이는 continue 역시 같습니다. 위의 예제에서 한 번의 break로 바깥쪽 루프까지 모두 종료하고 싶<br>으면 다음과 같이 코드를 수정해야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행 여부를 결정할 플래그</span></span><br><span class="line"><span class="keyword">var</span> loopFlag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span>&#123;</span><br><span class="line">    <span class="comment">// 1에서 9까지 반복</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">9</span>&#123;</span><br><span class="line">        <span class="comment">// j의 값이 3일 때 break 구문을 실행한다.</span></span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">3</span>&#123;</span><br><span class="line">            loopFlag = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 구구단을 출력한다.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(i) X \(j) = \(i*j)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(loopFlag == <span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line"><span class="number">1</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span>&#123;</span><br><span class="line">    inner: <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">9</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span> outer</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(i) X \(j) = \(i*j)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line"><span class="number">1</span> <span class="type">X</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="type">X</span> <span class="number">2</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><br></br></p>
<h4 id="집단-자료형-연관된-데이터를-손쉽게-다루기"><a href="#집단-자료형-연관된-데이터를-손쉽게-다루기" class="headerlink" title="집단 자료형: 연관된 데이터를 손쉽게 다루기"></a>집단 자료형: 연관된 데이터를 손쉽게 다루기</h4><ul>
<li>배열: 일련번호로 구분되는 순서에 따라 데이터가 정렬된 목록 형태의 자료형</li>
<li>집합: 중복되지 않은 유일 데이터들이 모인 집합 형태의 자료형</li>
<li>튜플: 종류에 상관없이 데이터들을 모은 자료형, 수정 및 삭제를 할 수 없음</li>
<li>딕셔너리: 배열과 유사하나 일련번호 대신 키를 사용하여 키-값으로 연관된 데이터<br>들이 순서 없이 모인 자료형</li>
</ul>
<p><br></p>
<h4 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h4><p>배열(Arrays)은 일련의 순서를 가지는 리스트 형식의 값을 저장하는 데에 사용되는 자료형이다. 배열에 입력되는 개별 아이템들은 모두 각각의 순서가 있는데, 이 순서를<br>일련번호, 즉 인덱스(Index)라고 합니다. 인덱스는 정수로 이루어지며, 0부터 시작하<br>여 아이템이 추가될 때마다 차례대로 증가하는 것이 특징입니다.</p>
<p><br></p>
<p>배열에서 인덱스는 순서대로 할당되며, 중간에 값을 생략하거나 건너뛰는 경우는 없습니다. 인덱스에 연결된 아이템이 삭제되더라도 인접한 다음 아이템들이 차례대로 앞으로 이동하면서 빈 인덱스를 채워 넣습니다. 배열 처음이나 중간에 있는 아이템이 삭제되어도 실제로 사라지는 인덱스는 가장 마지막 인덱스입니다.</p>
<p><br></p>
<p>이런 특성 때문에 인덱스는 배열의 아이템과 생사고락을 같이하는 고유 코드 역할을<br>할 수 없습니다. 그저 아이템의 순서를 나타내고, 아이템이 있는 위치를 가리키는 역<br>할만 할 뿐입니다. 스위프트에서 사용하는 배열 자료형은 몇 가지 특징이 있습니다.<br>정리해보면 다음과 같습니다.</p>
<p><br></p>
<ul>
<li>배열에 저장할 아이템의 타입에는 제약이 없지만, 하나의 배열에 저장하는 아이템<br>타입은 모두 같아야 함</li>
<li>선언 시 배열에 저장할 아이템 타입을 명확히 정의해야 함</li>
<li>배열의 크기는 동적으로 확장될 수 있음</li>
</ul>
<p><br></p>
<p>스위프트에서 배열을 정의하는 방법은 두 가지로, 정적인 방식과 동적인 방식으로 나<br>눌 수 있습니다. 정적인 방식은 처음부터 배열을 구성하는 아이템을 포함하여 정의하<br>는 방식입니다. 이 방식은 별도의 배열 선언이 필요 없다는 장점이 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cities = [<span class="string">"Seoul"</span>, <span class="string">"New York"</span>, <span class="string">"LA"</span>, <span class="string">"Santiago"</span>]</span><br><span class="line"></span><br><span class="line">type(of: cities)  <span class="comment">// Array&lt;String&gt;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 예제에서는 네 가지 문자열을 아이템으로 하는 배열을 생성하여 cities 변수에 대<br>입하고 있습니다. 이들 문자열을 배열의 아이템으로 만들기 위해 대괄호 []로 감싼 것을 눈여겨보기 바랍니다. 예에서 정의된 cities는 배열 타입으로 선언된 변수입니다. 타입 추론에 의해서 말이죠. 특히 배열을 이루는 아이템에 모두 문자열 리터럴이 직접 적용되었기 때문에 cities는 문자열 아이템을 가지는 배열이 됩니다. 배열 자료형을 이용하여 실제로 데이터를 저장할 수 있도록 정의한 것을 배열 객체라고 합니다.</p>
<p><br></p>
<h4 id="배열-순회-탐색"><a href="#배열-순회-탐색" class="headerlink" title="배열 순회 탐색"></a>배열 순회 탐색</h4><p>순서가 있는 데이터를 처음부터 마지막까지 차례대로 읽어 들이는 것을 순회 탐색이라고 합니다. 스위프트에서는 배열의 길이를 구할 때에는 배열 변수나 상수에 .count를 붙여주면 됩니다. .count와 같은 것들을 속성(properties)라고 부릅니다. count 속성<br>을 이용하여 배열의 크기를 얻었다면 이를 상수 length에 할당하고, 0에서 시작한 카<br>운터 변수가 이 크기만큼 커질 때까지 for~in 구문을 반복합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> length = cities.<span class="built_in">count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;length&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(i)번째 배열 원소는 \(cities[i])입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line"><span class="number">0</span>번째 배열 원소는 <span class="type">Seoul</span>입니다.</span><br><span class="line"><span class="number">1</span>번째 배열 원소는 <span class="type">New</span> <span class="type">York</span>입니다.</span><br><span class="line"><span class="number">2</span>번째 배열 원소는 <span class="type">LA</span>입니다.</span><br><span class="line"><span class="number">3</span>번째 배열 원소는 <span class="type">Santiago</span>입니다.</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>만약 배열 크기를 상수에 할당하지 않고 for~in 구문에 직접 cities.count를 사용하면 잠재적으로 문제가 될 소지를 가집니다. 왜냐하면 for~in 구문은 루프를 반복할 때마다 매번 조건식을 평가하는데, 이때 배열의 크기를 매번 다시 계산하거든요. 따라서<br>될 수 있으면 한 번만 읽어 별도의 변수나 상수에 크기를 저장해 놓고 사용하는 것이 좋습니다.</p>
<p><br></p>
<p>두 번째 방법은 이보다 더 간단합니다. 배열의 순회 특성, 즉 이터레이터(Iterator)를 이용하는 방식이죠. 앞에서 우리는 for~in 구문에 순번을 가진 범위 데이터를 넣으면 데이터의 크기만큼 반복 실행되는 특성을 학습했습니다. 이 특성은 배열에도 그대로 적용됩니다. for~in 구문이 읽어 들인 배열을 따라 순회하기 시작하면 배열의 아이템<br>들이 차례대로 추출되어 for와 in 사이에 정의된 루프 상수에 할당됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열값의 순회 특성을 사용하여 탐색</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cities&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"배열 원소는 \(row)입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line">배열 원소는 <span class="type">Seoul</span>입니다.</span><br><span class="line">배열 원소는 <span class="type">New</span> <span class="type">York</span>입니다.</span><br><span class="line">배열 원소는 <span class="type">LA</span>입니다.</span><br><span class="line">배열 원소는 <span class="type">Santiago</span>입니다.</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>순회 특성을 이용하여 배열을 탐색하면 루프 상수에 담기는 값은 현재의 인덱스 값이 아니라 배열 아이템 자체이므로, 몇 번째 아이템인지 인덱스를 바로 알기는 어렵습니<br>다. 이때는 index(of:)를 사용하면 아이템을 통해 인덱스 값을 역으로 찾을 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cities&#123;</span><br><span class="line">    <span class="keyword">let</span> index = cities.firstIndex(of: row)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(index!)번째 배열 원소는 \(row)입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line"><span class="number">0</span>번째 배열 원소는 <span class="type">Seoul</span>입니다.</span><br><span class="line"><span class="number">1</span>번째 배열 원소는 <span class="type">New</span> <span class="type">York</span>입니다.</span><br><span class="line"><span class="number">2</span>번째 배열 원소는 <span class="type">LA</span>입니다.</span><br><span class="line"><span class="number">3</span>번째 배열 원소는 <span class="type">Santiago</span>입니다.</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="배열의-동적-선언과-초기화"><a href="#배열의-동적-선언과-초기화" class="headerlink" title="배열의 동적 선언과 초기화"></a>배열의 동적 선언과 초기화</h4><p>배열을 정의할 때 선언과 초기화만 해 놓은 후 필요에 따라서 그때그때 동적으로 아이템을 추가하는 경우가 훨씬 많습니다. 값을 할당하지 않은 빈 배열을 선언하고 초기화할 때는 두 가지 형식을 사용할 수 있습니다. 스위프트에서 배열을 정의하는 객체는 Array입니다. 구조체로 정의된 이 객체는 실질적인 배열 데이터를 만드는 데 사용될 뿐만 아니라 배열에서 데이터를 효과적으로 다루기 위한 다양한 기능까지 제공해 줍니다. 스위프트에서 배열을 정의할 때에는 반드시 저장할 아이템의 타입도 함께 명시해 주어야 합니다. 컴파일러는 이때 입력받은 아이템 타입을 이용하여 다른 데이터 타입이 입력되었을 경우 잘못 입력되었음을 판단할 뿐만 아니라, 배열 내부의 아이템을 바로 아이템 타입 형태로 사용할 수 있도록 처리해주기도 합니다.</p>
<p><br></p>
<p>이처럼 사용 시점에서 &lt;&gt; 기호를 사용하여 배열 내부에서 사용할 아이템 타입을 지정<br>하는 문법을 제네릭이라고 합니다. 제네릭은 구조체나 클래스 외부에서 객체 내부에<br>사용될 타입을 지정할 수 있다는 점에서 동적 프로그래밍으로 간주되기도 하는데, 생<br>산성을 높여주는 문법입니다.</p>
<p><br></p>
<p>동적으로 배열을 정의할 때는 선언과 초기화 과정이 차례로 필요합니다. 객체지향 프<br>로그래밍에서는 배열 구조체는 선언만 되었을 때에는 메모리 공간을 차지하지 않다가 초기화가 진행되면 그때서야 메모리 공간을 할당받습니다. 비로소 데이터를 저장할 수 있는 공간이 생기는 겁니다. 다시 말해, 배열의 선언은 “시스템 OS에 이만이만한 공<br>간을 사용하고 싶습니다”라고 예약하는 과정이고, 초기화는 실제로 사용하기 위해 체<br>크인을 하는 과정인거죠. 실제로 스위프트에서 모든 변수와 상수는 알게 모르게 초기<br>화 과정을 거칩니다.</p>
<p><br></p>
<p>배열에서도 선언과 초기화를 동시에 처리할 수 있죠. 실제로 배열을 정의해 봅시다.<br>다음은 cities 배열을 선언하고 동시에 초기화하는 예입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 배열의 선언과 초기화</span></span><br><span class="line"><span class="keyword">var</span> cities = <span class="type">Array</span>&lt;<span class="type">String</span>&gt;()</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>문자열 형식의 배열 객체를 정의한 다음에, cities 변수에 대입하고 있습니다. 이렇게 정의한 배열은 문자열을 저장할 수 있는 빈 배열로 초기화되죠. 만약 이 배열을 단순히 선언만 하려면 타입 어노테이션을 사용하여 다음과 같이 작성하면 됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 배열을 선언</span></span><br><span class="line"><span class="keyword">var</span> cities: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이렇게 선언된 배열은 초기화되지 않았으므로 아직 메모리 공간을 할당받지 않은 상태입니다. 이 배열에는 아무것도 아직 저장할 수 없죠. 배열을 사용하기 위해서는 아래<br>와 같이 초기화 과정을 통해 메모리 공간을 할당받아야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열의 초기화</span></span><br><span class="line">cities = <span class="type">Array</span>()</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>그런데 이미 선언과 초기화가 이루어진 배열 변수를 또다시 초기화하면 어떻게 될까요? 이때는 새로운 배열 객체가 다시 만들어져 변수에 할당됩니다. 이 과정에서 기존 배열은 제거되죠. 다음으로 스위프트에서 배열을 정의하는 두 번째 형식을 알아봅시다. 이때에는 앞에서 사용했던 배열 구조체 Array나 아이템 타입을 표현하는 &lt;&gt; 기호가 사용되지 않으며 단순히 대괄호 사이에 아이템 타입을 기재하는 것만으로 배열을 정의할 수 있습니다. 물론 초기화할 때는 초기화 연산자인 ()를 붙여야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열 선언 &amp; 초기화</span></span><br><span class="line"><span class="keyword">var</span> cities = [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 선언</span></span><br><span class="line"><span class="keyword">var</span> cities: [<span class="type">String</span>]</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>선언된 배열을 초기화할 때에는 다음 두 가지 형식을 사용할 수 있는데, 이때 두 가지 형식이 의미하는 바는 전혀 다르므로 주의해야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열 초기화 - 첫 번째 방식</span></span><br><span class="line">cities = [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 초기화 - 두 번째 방식</span></span><br><span class="line">cities = []</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>첫 번째 형식은 선언된 배열 그대로를 초기화하지만, 두 번째 형식은 빈 배열 하나를 새로 만들어서 이것을 변수에 할당합니다. 엄밀하게 말해서 두 번째 방식은 초기화가 아닙니다. 따라서 초기화 연산자인 ()가 붙지 않을뿐더러 초기화 연산자 ()를 붙이면 오히려 오류가 발생합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list : [<span class="type">Int</span>] = []  <span class="comment">// 타입 어노테이션 + 빈 배열 하나를 새로 만들어서 초기화(초기화 연산자() 없음)</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> list.isEmpty&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"배열이 비어 있는 상태입니다."</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"배열에는 \(list.count)개의 아이템이 있습니다."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="배열-아이템-동적-추가"><a href="#배열-아이템-동적-추가" class="headerlink" title="배열 아이템 동적 추가"></a>배열 아이템 동적 추가</h4><p>필요에 따라 배열의 아이템을 동적으로 할당하는 방법을 알아봅시다.</p>
<p><br></p>
<p><img src="/image/ios7.jpeg" alt="ios7"></p>
<p><br></p>
<p>append(_:) 메소드는 입력된 값을 배열의 맨 뒤에 추가합니다. 일반적으로 배열에서<br>존재하지 않는 인덱스에 접근하면 오류가 발생하므로 이 메소드는 아이템 추가 전에<br>먼저 배열의 크기를 +1만큼 확장하여 인덱스 공간을 확보한 후, 인자값을 마지막 인덱스 위치에 추가합니다.</p>
<p><br></p>
<p><img src="/image/ios8.jpeg" alt="ios8"></p>
<p><br></p>
<p>반면 insert(_:at:) 메소드는 아이템을 배열의 맨 뒤가 아닌 원하는 위치에 직접 추가하고 싶을 때 사용합니다. at: 뒤에 입력되는 정수값은 배열에서 아이템이 추가될 인<br>덱스의 위치를 의미합니다. 이 인덱스에 새로운 값이 추가되면 이를 기준으로 하여 나머지 인덱스들은 하나씩 다음으로 밀려나는 결과를 가져옵니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cities = [<span class="type">String</span>]()  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">cities.append(<span class="string">"Seoul"</span>)  <span class="comment">// ["Seoul"]</span></span><br><span class="line">cities.append(<span class="string">"New York"</span>)  <span class="comment">// ["Seoul", "New York"]</span></span><br><span class="line">cities.insert(<span class="string">"Tokyo"</span>, at: <span class="number">1</span>)  <span class="comment">// ["Seoul", "Tokyo", "New York"]</span></span><br><span class="line">cities.append(contentsOf: [<span class="string">"Dubai"</span>, <span class="string">"Sydney"</span>])  <span class="comment">// ["Seoul", "Tokyo", "New York", "Dubai", "Sydney"]</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>입력된 배열값을 변경하고 싶을 때는 배열의 인덱스를 이용하여 변경할 값을 직접 대<br>입하면 됩니다. 이렇게 인덱스에 직접 할당된 값은 배열의 크기를 늘리지 않고 기존<br>인덱스에 연결된 아이템을 교체하는 방식으로 수정이 이루어집니다.</p>
<p><br></p>
<p><img src="/image/ios8.jpeg" alt="ios8"></p>
<p><br></p>
<p>반면 insert(_:at:) 메소드는 아이템을 배열의 맨 뒤가 아닌 원하는 위치에 직접 추가<br>하고 싶을 때 사용합니다. at: 뒤에 입력되는 정수값은 배열에서 아이템이 추가될 인<br>덱스의 위치를 의미합니다. 이 인덱스에 새로운 값이 추가되면 이를 기준으로 하여 나<br>머지 인덱스들은 하나씩 다음으로 밀려나는 결과를 가져옵니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cities = [<span class="type">String</span>]()  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">cities.append(<span class="string">"Seoul"</span>)  <span class="comment">// ["Seoul"]</span></span><br><span class="line">cities.append(<span class="string">"New York"</span>)  <span class="comment">// ["Seoul", "New York"]</span></span><br><span class="line">cities.insert(<span class="string">"Tokyo"</span>, at: <span class="number">1</span>)  <span class="comment">// ["Seoul", "Tokyo", "New York"]</span></span><br><span class="line">cities.append(contentsOf: [<span class="string">"Dubai"</span>, <span class="string">"Sydney"</span>])  <span class="comment">// ["Seoul", "Tokyo", "New York"</span></span><br><span class="line">, <span class="string">"Dubai"</span>, <span class="string">"Sydney"</span>]</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>입력된 배열값을 변경하고 싶을 때는 배열의 인덱스를 이용하여 변경할 값을 직접 대<br>입하면 됩니다. 이렇게 인덱스에 직접 할당된 값은 배열의 크기를 늘리지 않고 기존<br>인덱스에 연결된 아이템을 교체하는 방식으로 수정이 이루어집니다.</p>
<p><br></p>
<p>그런데 여기에서 궁금증이 생깁니다. 수정할 값을 직접 대입하는 방법으로 기존의 값<br>을 변경할 수 있다면, 처음부터 이렇게 값을 입력할 수는 없을까요? 결론을 이야기하<br>자면 틀렸습니다. 배열의 인덱스를 이용하여 직접 아이템에 접근하는 이 방식으로 기<br>존에 있는 값을 수정할 수는 있지만, 값을 추가할 수는 없습니다. 어떤 경우든지 배열의 인덱스를 직접 이용하여 아이템의 값을 할당하거나 수정하고, 읽어오는 것은 해당 배열에 그 인덱스가 이미 만들어져 있거나 그만큼의 인덱스가 확보된 경우로 제한됩니다.</p>
<p><br></p>
<p>지금까지 우리는 배열을 만들 때 배열에 들어갈 아이템의 개수, 즉 배열의 길이를 그<br>다지 고려하지 않았습니다. 처음에 시작할 때 크기를 0으로 지정한 후 입력 메소드를 사용하여 새로운 아이템을 추가할 때마다 동적으로 크기가 늘어나도록 배열을 사용했<br>죠. 배열의 길이가 늘어나면 그만큼 인덱스도 자동으로 늘어나는 것이 스위프트에서<br>배열의 특징입니다.</p>
<p><br></p>
<p>하지만 이렇게 하면 배열의 크기는 언제나 현재 입력된 값의 개수만큼만 생성됩니다. 새로운 아이템을 직접 할당하기 위해 참조해야 할 인덱스는 아직 생성되어 있지 않은 상태죠. 이 때문에 오류가 발생합니다. 이처럼 배열의 크기를 동적으로 변경하는 방식으로 생성한 배열은 새로운 아이템을 추가할 목적으로 인덱스에 직접 접근할 수 없습<br>니다. 다만 코코아 터치 프레임워크를 살펴보면 배열을 생성하는 여러 가지 방법 중에서 초기화할 때 배열의 크기를 지정할 수 있는 구문이 다음과 같이 정의되어 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">RangeReplaceableCollection</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(repeating repeatedValue: <span class="type">Element</span>, <span class="built_in">count</span>: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>아직 구조체와 클래스, 확장체에 대해 배우기 전이지만, 가벼운 마음으로 살펴봅시다. init는 객체를 생성할 때 사용하는 구문, 또는 형식이라는 의미로 사용됩니다. 이때 두 개의 인자값이 사용되는데, 하나는 배열의 크기만큼 생성된 인덱스 각각에 기본값<br>으로 넣어줄 repeatedValue이며 또 다른 하나는 배열의 크기를 정해주는 count입니다.<br><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cities = <span class="type">Array</span>(repeating: <span class="string">"None"</span>, <span class="built_in">count</span>: <span class="number">3</span>)  <span class="comment">// ["None", "None", "None"]</span></span><br><span class="line"><span class="keyword">var</span> cities = [<span class="type">String</span>](repeating: <span class="string">"None"</span>, <span class="built_in">count</span>: <span class="number">3</span>)  <span class="comment">// 위와 동일 표현</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이와 같이 배열을 생성하면 지금까지 초기화했던 배열과 달리 배열의 인덱스가 개수만큼 미리 정의되고, 여기에 기본값이 각각 추가된 상태로 배열이 만들어집니다. 이런<br>방식으로 생성된 배열은 입력된 크기만큼의 인덱스를 미리 확보하고 있으므로 필요한 때 배열의 원소에 직접 접근해서 값을 읽거나 할당하고 변경할 수 있습니다.</p>
<p><br><br></p>
<h4 id="딕셔너리"><a href="#딕셔너리" class="headerlink" title="딕셔너리"></a>딕셔너리</h4><p>배열은 각 데이터를 정의할 때 앞에서부터 차례대로 연속된 정수가 할당되어 인덱스를 구성해주므로 인덱스와 데이터 사이를 연결하는 과정이 필요 없었지만, 딕셔너리는<br>불특정 키가 사용되므로 데이터를 입력할 때 반드시 키와 함께 쌍으로 입력해야 합니다. 이외에 딕셔너리를 사용할 때 주의할 점은 다음과 같습니다.</p>
<p><br></p>
<ul>
<li>하나의 키는 하나의 데이터에만 연결되어야 합니다.</li>
<li>하나의 딕셔너리에서 키는 중복될 수 없습니다. 중복해서 선언하면 아이템 추가가<br>아니라 수정이 이루어져 기존 키에 연결된 데이터가 제거됩니다.</li>
<li>저장할 수 있는 데이터 타입에는 제한이 없지만, 하나의 딕셔너리에 저장하는 데이<br>터 타입은 모두 일치해야 합니다.</li>
<li>딕셔너리의 아이템에는 순서가 없지만 키에는 내부적으로 순서가 있으므로 for~in<br>구문을 이용한 순회탐색을 할 수 있습니다.</li>
<li>딕셔너리에 사용할 수 있는 키의 타입은 거의 제한이 없으나 해시 연산이 가능한 타입이어야 합니다.</li>
</ul>
<p><br></p>
<p>해시 연산이란 임의의 입력된 메시지를 고정 길의의 데이터 크기로 변환해주는 알고리즘입니다. 해시 알고리즘을 사용하면 아무리 긴 데이터나 아무리 짧은 길이의 데이터라 할지라도 고정 길의의 데이터로 변환할 수 있습니다. 가장 단순하고 이해하기 쉬운 알고리즘의 예로 나눗셈의 나머지 값을 구하는 % 연산을 들 수 있습니다. 아무리 큰 값의 수라 할지라도 10으로 나눈 나머지를 구하면 0~9까지 중에서 한자리 길의의 값으로 변환될 수 있죠.</p>
<p><br></p>
<p>딕셔너리에서 키로 사용할 수 있는 타입은 다양합니다. 문자열은 물론 단일 문자도 키로 사용할 수 있으며 정수나 실수도 키로 사용할 수 있습니다. 흔하지 않지만, 클래스의 인스턴스도 키로 사용할 수 있습니다. 다만, 키에는 제약이 있어서 키로 사용할 데이터 타입이 해시 연산을 지원해야 합니다. 즉 데이터 타입에 해시(Hash) 값을 추출할 수 있는 기능이 포함되어 있어야 한다는 뜻입니다. </p>
<p><br></p>
<p>딕셔너리가 아이템을 저장할 때는 입력된 키를 그대로 사용하는 것이 아니라 내부적으로 해시 연산을 거친 값으로 변환한 다음 이를 정렬하여 사용합니다. 이는 데이터의 빠른 검색을 위한 장치이지만, 이 때문에 딕셔너리에 사용할 수 있는 키 타입은 해시 연산을 할 수 있는 타입으로 제한됩니다. 스위프트에서 해시 연산을 위해서는 Hashable 프로토콜이 구현되어야 하는데, 문자열 타입은 Hashable 프로토콜이 이미 구현되어 있으므로 대부분의 딕셔너리는 문자열을 키로 사용합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 닥셔너리의 정적 선언과 값의 정의</span></span><br><span class="line"><span class="keyword">var</span> capital = [<span class="string">"KR"</span>:<span class="string">"Seoul"</span>, <span class="string">"EN"</span>:<span class="string">"London"</span>, <span class="string">"FR"</span>:<span class="string">"Paris"</span>]</span><br><span class="line"><span class="comment">// 실행결과</span></span><br><span class="line">[<span class="string">"FR"</span>: <span class="string">"Paris"</span>, <span class="string">"KR"</span>: <span class="string">"Seoul"</span>, <span class="string">"EN"</span>: <span class="string">"London"</span>]</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>해시 문자열 처리를 통해 정렬되기 때문에 입력된 순서와는 다릅니다. 하지만 딕셔너리 자체가 순서를 갖지 않는 값이니만큼 문제는 되지 않습니다. 배열과 마찬가지로, 대부분 빈 딕셔너리를 선언하고 초기화한 다음 필요한 시기에 아이템을 추가하는 방식으로 딕셔너리를 사용합니다. 딕셔너리를 선언할 때는 Dictionary 구조체가 사용됩니다. 이 객체를 사용하여 선언할 때는키와 값으로 사용할 타입을 제네릭을 사용하여 어떤 자료형이나 객체 타입을 사용할 것인지 외부에서 객체 내부에 알려주게 됩니다. 구문의 마지막 부분에는 초기화를 위한 연산자인 ()를 사용하여 선언된 딕셔너리가 메모리에 데이터를 저장할 공간을 할당받게 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 키와 범용 클래스 값으로 이루어진 딕셔너리</span></span><br><span class="line"><span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">AnyObject</span>&gt;()</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">딕셔너리의 선언과 초기화 구문을 간결한 형식으로 정리할 수 있습니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">[<span class="type">String</span> : <span class="type">AnyObject</span>]()</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 딕셔너리의 선언과 초기화</span></span><br><span class="line"><span class="comment">// 방법 1</span></span><br><span class="line"><span class="keyword">var</span> dict1 = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;()</span><br><span class="line"><span class="comment">// 방법 2</span></span><br><span class="line"><span class="keyword">var</span> dict2 = [<span class="type">String</span> : <span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입 어노테이션을 통한 딕셔너리의 선언</span></span><br><span class="line"><span class="keyword">var</span> dict3: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;</span><br><span class="line"><span class="comment">// 딕셔너리의 초기화</span></span><br><span class="line">dict3 = <span class="type">Dictionary</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입 어노테이션을 통한 딕셔너리의 선언</span></span><br><span class="line"><span class="keyword">var</span> dict4: [<span class="type">String</span> : <span class="type">String</span>]</span><br><span class="line"><span class="comment">// 딕셔너리의 초기화</span></span><br><span class="line">dict4 = [<span class="type">String</span> : <span class="type">String</span>]()</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> capital: [<span class="type">String</span> : <span class="type">String</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 딕셔너리 초기화</span></span><br><span class="line">capital = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;() <span class="comment">//1</span></span><br><span class="line">capital = <span class="type">Dictionary</span>() <span class="comment">//2</span></span><br><span class="line">capital = [<span class="type">String</span> : <span class="type">String</span>]() <span class="comment">//3</span></span><br><span class="line">capital = [:] <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 예제에서 주의해야 할 부분은 2번과 4번입니다. 2번과 4번의 초기화 구문은 딕셔너리의 타입 지정이 생략되어 있는데, 이는 사전에 타입 어노테이션을 통하여 딕셔너리의 타입이 명시적으로 선언되어 있기 때문입니다. 이외의 초기화 구문에서는 함부로 타입을 생략하면 안 됩니다.</p>
<p><br></p>
<h4 id="딕셔너리에-동적으로-아이템-추가하기"><a href="#딕셔너리에-동적으로-아이템-추가하기" class="headerlink" title="딕셔너리에 동적으로 아이템 추가하기"></a>딕셔너리에 동적으로 아이템 추가하기</h4><p>딕셔너리는 메소드를 이용해서 추가하는 방법뿐만 아니라 직접 새로운 키와 값을 대입하여 아이템을 추가할 수도 있습니다. 딕셔너리에서도 배열에서처럼 아이템의 개수가 딕셔너리의 크기를 결정합니다. 정확히는 딕셔너리에 저장된 튜플의 개수이죠. 튜플은 스위프트에서 제공하는 특별한 성격의 집단 자료형입니다. 튜플은 한 가지 타입의 아이템만 저장할 수 있는 배열이나 딕셔너리와는 달리 하나의 튜플에 여러 가지 타입의 아이템을 저장할 수 있지만, 일단 선언되고 나면 상수의 성격을 띠므로 더 이상 값을 추가하거나 삭제하는 등의 변경이 불가능합니다. 즉, 타입과 관계없이 다양하게 저장할 수 있지만 오직 최초에 선언된 상태의 아이템만 사용할 수 있고 수정이나 삭제, 추가 등 변경할 수 없는 것이 튜플의 특징이라고 할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newCapital = [<span class="type">String</span> : <span class="type">String</span>]()  <span class="comment">// [:]</span></span><br><span class="line">newCapital[<span class="string">"JP"</span>] = <span class="string">"Tokyo"</span>  <span class="comment">// "Tokyo"</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이번에는 메소드를 사용하여 동적으로 값을 할당해봅시다. 딕셔너리에 값을 할당하는 데 사용되는 메소드는 updateValue(_:forKey:)입니다. 이 메소드는 키가 있는지에 따라 수행하는 역할이 달라지는데, 기존에 저장된 키가 있으면 연결된 값을 수정하는 역할을 하지만 새로운 키가 입력되면 아이템을 추가하는 역할도 수행합니다. 재미있는 것은 이 메소드를 사용하여 딕셔너리에 저장된 값을 수정하면 수정하기 이전의 값이 결과값으로 반환된다는 점입니다. 따라서 새로운 키와 값을 이 메소드를 사용하여 추가하면 기존에 저장되어 있던 값이 없으므로 nil을 반환합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">newCapital.updateValue(<span class="string">"Seoul"</span>, forKey: <span class="string">"KR"</span>)</span><br><span class="line"><span class="comment">// "KR" : "Seoul" 데이터가 추가되고 nil을 리턴함</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">newCapital.updateValue(<span class="string">"Sapporo"</span>, forKey: <span class="string">"JP"</span>)</span><br><span class="line"><span class="comment">// "JP" : "Sapporo" 데이터로 수정되고 "Tokyo"을 리턴함</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">딕셔너리에 저장된 아이템을 제거할 때는 두 가지 방법을 사용할 수 있습니다. 하나는 키에 연결된 값에 직접 <span class="literal">nil</span>을 할당하는 방법이고, 또 다른 하나는 명시적으로 removeValue(forKey:) 메소드를 사용하는 것입니다. <span class="literal">nil</span>은 <span class="string">"값이 없음"</span>이라는 의미를 나타내는 특수 값입니다. 없는 값을 표현하기 위해 또 다른 값을 사용한다는 것이 좀 모순이긴 하지만, 그렇지 않고서는 값이 없다는 것을 명시적으로 표현할 방법이 없어서 <span class="literal">nil</span>이라는 특수 값을 사용합니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">newCapital[<span class="string">"JP"</span>] = <span class="literal">nil</span></span><br><span class="line">newCapital.removeValue(forKey: <span class="string">"KR"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// non-Optional 변수인 removedValue에 Optional 변수인 키 "CA"에 해당하는 아이템을 할당할 수 있다면</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedValue = newCapital.removeValue(forKey: <span class="string">"CA"</span>)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"삭제된 값은 \(removedValue)입니다."</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"아무 것도 삭제되지 않았습니다."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>물론 없는 키를 삭제하고자 할 때는 그 결과값도 당연히 없으므로 nil을 반환합니다. if 조건문을 사용하여 구분하고 있는 이유는 이 때문이죠. 그런데 여기서 한 가지 짚고 넘어가야 할 부분이 있습니다. 바로 배열의 인덱스와 딕셔너리 키의 대한 접근의 차이입니다. 배열은 인덱스를 직접 참조하기 위해 참조할 인덱스가 이미 만들어져 있어야만 한다는 제약조건이 있습니다. 그렇지 않으면 잘못된 인덱스 참조에 의한 오류가 발생하죠. 하지만 딕셔너리는 키 자체가 일련의 순서를 가지고 있지 않습니다(해시 연산에 의한 결과값 역시 연속되는 값은 아닙니다). 게다가 타입은 알 수 있을지언정 실제로 어떤 데이터가 키로 사용될지 미리 알 수 없으므로 기존에 사용된 적이 없던 새로운 키가 입력되면 이 키와 값을 저장하기 위한 튜플을 하나 만들어 저장하면 될 뿐입니다. 새로운 인덱스 공간을 확보하고 크기를 늘릴 필요는 없습니다. 단지 딕셔너리 변수가 초기화되어 있기만 하면 됩니다.</p>
<p><br></p>
<p>그런데 사용하기 편한 이런 특성으로 인해 배열에서는 걱정할 필요 없었던 문제가 딕셔너리에서 생깁니다. 바로 키와 값에 대한 보장이 없다는 점입니다. 배열이야 값을 저장할 때 만들어져 있지 않은 인덱스라면 오류를 발생해버리면 되니 배열에서 인덱스를 호출한다는 것은 곧, 그 안에 저장된 값을 꺼내오기만 하면 된다는 것과 같습니다. 설령 값이 아직 저장되지 않았더라도 초기화될 때 적용한 기본값이라도 저장되어 있을테니 값이 비어있을 염려는 없는 것이죠.</p>
<p><br></p>
<p>그러나 딕셔너리는 고유 키에 대한 제약이 덜하다 보니 프로그램이 딕셔너리로부터 키를 호출해서 저장된 값을 불러올 때 없는 키를 호출했을 가능성을 항상 염두에 두어야 합니다. 이 경우를 처리해 줄 수 있어야 안전한 프로그래밍 언어가 됩니다. 그래서 스위프트에서는 딕셔너리로부터 키를 호출해서 저장된 값을 불러올 때, 또는 업데이트 메소드를 실행한 결과를 반환할 때, 오류가 발생할 가능성을 염두에 둔 다음과 같은 특별한 형식으로 값을 반환합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Optional</span>(<span class="string">"Sappro"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이것이 바로 스위프트가 제공하는 독특하면서도 어려운 개념인 옵셔널입니다. 요약하자면 다양한 객체지향 프로그래밍에서 오류 처리를 위해 애용되는 에러 캐치를 대신할 목적으로 도입한 개념으로서, 아키텍처 차원의 안정성을 제공하기 위한 것입니다.</p>
<p><br></p>
<h4 id="딕셔너리의-순회-탐색"><a href="#딕셔너리의-순회-탐색" class="headerlink" title="딕셔너리의 순회 탐색"></a>딕셔너리의 순회 탐색</h4><p>딕셔너리에 저장된 아이템끼리는 순서가 없지만, 아이템을 튜플 형식으로 저장할 때 내부적으로 키를 바탕으로 한 해시 연산 값을 기준으로 정렬하기 때문에 이 특성을 사용하면 순회 탐색을 할 수 있습니다. 딕셔너리는 인덱스를 사용하지 않으므로 딕셔너리를 직접 사용하여 탐색하는 방식으로 for~in 구문을 구성하면 됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 딕셔너리의 순회 기능을 사용하여 순회 탐색을 실행한다.</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> newCapital&#123;</span><br><span class="line">    <span class="comment">// 딕셔너리에서 꺼낸 키-값 한 쌍이 담긴 row 상수를 튜플로 받는다.</span></span><br><span class="line">    <span class="keyword">let</span> (key, value) = row</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"현재 데이터는 \(key) : \(value)입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 중간 과정 생략 같은 결과</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> newCapital&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"현재 데이터는 \(key) : \(value)입니다."</span><span class="string">")</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>for~in 구문이 반복되면 딕셔너리에 저장된 아이템이 차례대로 row 상수에 대입됩니다. 딕셔너리는 키와 값으로 이루어진 아이템을 내부에 저장할 때 튜플 타입으로 저장하므로 순회 탐색을 실행하면 차례대로 튜플 타입으로 된 키-값이 row 상수에 할당됩니다. 할당된 row 상수로부터 데이터를 키와 값으로 분리해내기 위해 (key, value)의 개별 변수로 구성된 튜플로 값을 할당하는 구문이 다시 사용되고, 이 과정을 거쳐 키는 key 변수에, 값은 value 변수에 할당됩니다.</p>
<p><br></p>
<p><br></p>

    </div>

    

    
        <div class="post-tags">
            <i class="fa fa-tags" aria-hidden="true"></i>
            <a href="/tags/swift/">#swift</a> <a href="/tags/ios/">#iOS</a>
        </div>
    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo" target="_blank" rel="noopener">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/05/22/hackerrank-lets-review/">[HackerRank] Lets Review</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/05/20/hackerrank-loops/">[HackerRank] Loops</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/05/20/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%8F%84%EC%A0%84%EA%B8%B0-9/">[iOS] 앱 개발 도전기 (9)</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/05/19/hackerrank-class-vs-instance/">[HackerRank] Class vs. In</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/hci/">HCI</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/nlp/">NLP</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/algorithm/selection-sort/">selection sort</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/algorithm/graph/">graph</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

</body>

</html>