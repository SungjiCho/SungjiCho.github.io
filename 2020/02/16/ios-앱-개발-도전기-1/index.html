<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="밑바닥부터 시작하는 iOS 앱 개발 (1)
본 포스팅은 “꼼꼼한 재은씨의 Swift: 문법편”과 “Do it! 스위프트로 아이폰 앱 만들기(입문)”를 정리한 내용입니다.
꼼꼼한 재은씨의 Swift: 문법편
CHAPTER 01 애플의 새로운 언어, 스위프트


1.1 스">
    

    <!--Author-->
    
        <meta name="author" content="Sunny Cho">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="[IOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (1)"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="QuantPsy"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>[IOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (1) - QuantPsy</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2020/02/16/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%8F%84%EC%A0%84%EA%B8%B0-1/">
                [IOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-16</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h1 id="밑바닥부터-시작하는-iOS-앱-개발-1"><a href="#밑바닥부터-시작하는-iOS-앱-개발-1" class="headerlink" title="밑바닥부터 시작하는 iOS 앱 개발 (1)"></a>밑바닥부터 시작하는 iOS 앱 개발 (1)</h1><p><br></p>
<h5 id="본-포스팅은-“꼼꼼한-재은씨의-Swift-문법편”과-“Do-it-스위프트로-아이폰-앱-만들기-입문-”를-정리한-내용입니다"><a href="#본-포스팅은-“꼼꼼한-재은씨의-Swift-문법편”과-“Do-it-스위프트로-아이폰-앱-만들기-입문-”를-정리한-내용입니다" class="headerlink" title="본 포스팅은 “꼼꼼한 재은씨의 Swift: 문법편”과 “Do it! 스위프트로 아이폰 앱 만들기(입문)”를 정리한 내용입니다."></a>본 포스팅은 “꼼꼼한 재은씨의 Swift: 문법편”과 “Do it! 스위프트로 아이폰 앱 만들기(입문)”를 정리한 내용입니다.</h5><p><br></p>
<h4 id="꼼꼼한-재은씨의-Swift-문법편"><a href="#꼼꼼한-재은씨의-Swift-문법편" class="headerlink" title="꼼꼼한 재은씨의 Swift: 문법편"></a>꼼꼼한 재은씨의 Swift: 문법편</h4><p><br></p>
<h5 id="CHAPTER-01-애플의-새로운-언어-스위프트"><a href="#CHAPTER-01-애플의-새로운-언어-스위프트" class="headerlink" title="CHAPTER 01 애플의 새로운 언어, 스위프트"></a>CHAPTER 01 애플의 새로운 언어, 스위프트</h5><p>

<ul>
<li>1.1 스위프트 언어의 탄생과 배경</li>
<li>1.2 스위프트 언어의 특징</li>
<li>스위프트 언어에서 차용하고 있는 주요 기능들</li>
<li>구조적 특징</li>
<li>1.3 오브젝티브-C vs 스위프트</li>
</ul>
<p><br></p>
<p><hr><br><br></p>
<p>이번 장에서는 플랫폼으로서의 스위프트에 대하여 학습합니다. 문법을 학습하기에 앞서 스위프트의 언어적 특징은 어떠한지, 스위프트의 장점은 무엇이며 전반적인 이슈는 무엇인지 등을 살펴보면서 스위프트에 대한 전반적인 이해를 갖추어 보면 좋겠습니다<br><br></p>
<h4 id="스위프트-언어의-탄생과-배경"><a href="#스위프트-언어의-탄생과-배경" class="headerlink" title="스위프트 언어의 탄생과 배경"></a>스위프트 언어의 탄생과 배경</h4><p>스위프트는 그동안 앱을 개발하는 데에 사용되던 오브젝티브-C를 대체할 목적으로 발표된 언어입니다. 애플의 이전 주력 언어였던 오브젝티브-C는 C 언어를 기초로 하여 스몰토크(Smalltalk)의 메시지 전달 개념과 객체지향 개념을 반영한, 말 그대로 객체지향형 C 언어입니다. 이러한 특정 때문에 그3동한 iOS 앱을 개발하기 위해서는 C 언어의 저수준 프로그래밍과 스몰토크의 객체지향 개념을 동시에 구현해야 한다는 부담이 있었습니다. 게다가 C 언어의 장점이자 단점인 포인터 개념은 오브젝티브-C를 강력한 언어로 만들어주긴 했지만, 처음 접근하는 사람에게는 그만큼 높은 장벽으로 작용하기도 했습니다.</p>
<p><br></p>
<p>스위프트는 기존의 오브젝티브-C가 C 언어로부터 가져온 저수준 프로그래밍을 자동 관리 영역으로 대체했고, 생소한 문법이지만 객체지향을 위해 사용할 수밖에 없었던 스몰토크의 메시지 문법을 사람들에게 익숙한 자바, 파이썬, C#의 문법으로 바꾸었으며, 오브젝티브-C와 호환까지 가능하도록 설계되는 등 여러 가지 언어적 강점을 지녔습니다.</p>
<p><br></p>
<blockquote><footer><strong>iOS란?</strong><cite><a href="https://ko.wikipedia.org/wiki/IOS" target="_blank" rel="noopener">ko.wikipedia.org/wiki/IOS</a></cite></footer></blockquote>
<p><br></p>
<p>문득 여기까지 읽다가 iOS가 무엇인지, 어디에서 코드가 동작하게 되는지 몰라 답답함에 <iOS 앱의 구조와 코코아 터치 프레임워크> 부분을 펼쳤다. 자, 물론 글을 읽어도 거의 이해가 가지 않지만 우선 머리에 큰 그림을 그려보자. 시작!</p>
<p><br></p>
<h4 id="iOS-앱의-구조와-코코아-터치-프레임워크"><a href="#iOS-앱의-구조와-코코아-터치-프레임워크" class="headerlink" title="+ iOS 앱의 구조와 코코아 터치 프레임워크"></a>+ iOS 앱의 구조와 코코아 터치 프레임워크</h4><p>앱은 우리가 작성하는 커스텀 코드와 시스템 프레임워크 사이에서 매우 복잡한 상호작용을 합니다. (그래, 시스템 프레임워크는 또 무엇일까…이해가 가지 않으니 그림 먼저!)</p>
<p><br></p>
<p><img src="/image/ios1.jpeg" alt="ios1"></p>
<p><br></p>
<p>시스템 프레임워크는 iOS 기반의 앱이 실행되는 데에 필요한 기반 환경을 제공하고, 우리는 커스텀 코드를 제공하여 원하는 기능과 앱의 형태를 구현하죠. 이들은 서로 맞물려 정교하게 돌아가면서 iOS에서 우리가 원하는 기능을 제공합니다.</p>
<p><br></p>
<p><br></p>
<p>시스템 프레임워크는 iOS 기반의 앱이 실행되는 데에 필요한 기반 환경을 제공하고, 우리는 커스텀 코드를 제공하여 원하는 기능과 앱의 형태를 구현하죠. 이들은 서로 맞물려 정교하게 돌아가면서 iOS에서 우리가 원하는 기능을 제공합니다.</p>
<p><br></p>
<p>앱은 기본적으로 시스템 프레임워크에 정의된 원리에 따라 동작하지만, 이 영역을 제외한 나머지 범위에서는 커스텀 코드를 통해 원하는 기능과 유저 인터페이스를 구현할 수 있습니다. 이 말은 곧 앱 개발이 우리가 건드릴 수 있는 영역과 우리가 건드릴 수 없는 영역으로 분리된다는 것을 의미하며, 동시에 우리가 건드릴 수 없는 영역에 대해서는 신경 쓰지 않아도 된다는 것을 의미합니다. 효율적인 앱을 개발하기 위해서는 이같은 iOS 시스템의 기본 구조와 이것이 어떻게 동작하고 있는지를 잘 파악해야 합니다.</p>
<p><br></p>
<p>이번 장에서는 우리가 임의로 건드릴 수 없는 시스템 프레임워크 영역에 속한 앱의 기본 구조와 여기에 관련된 핵심 객체들에 대해 알아보겠습니다. 특히 이번 장에서 등장하는 앱 델리게이트, 뷰 컨트롤러, 뷰 등의 객체는 앱의 개발과 실행 전반을 관통하는 매우 중요한 객체이므로 이들의 역할과 특성을 잘 이해해야 합니다.</p>
<p><br></br></p>
<h4 id="앱의-기본-구조"><a href="#앱의-기본-구조" class="headerlink" title="앱의 기본 구조"></a>앱의 기본 구조</h4><p><br></p>
<h5 id="엔트리-포인트와-앱의-초기화-과정"><a href="#엔트리-포인트와-앱의-초기화-과정" class="headerlink" title="엔트리 포인트와 앱의 초기화 과정"></a>엔트리 포인트와 앱의 초기화 과정</h5><p>C 언어에 뿌리를 둔 모든 애플리케이션은 main() 함수로부터 시작됩니다. 이를 엔트리 포인트(Entry Point, 시작 진입점)라고 하죠. 운영체제가 해당 애플리케이션 내부에 정의된 main() 함수를 찾아 호출하면 여기에 작성된 코드들이 연쇄적으로 실행되면서 우리가 작성해 둔 커스텀 코드에까지 도달하게 되는 식입니다.</p>
<p><br></p>
<p>오브젝티브-C 역시 C 언어에 기반하고 있기 때문에, 이를 이용하여 만들어진 iOS 앱도 main() 함수로부터 시작됩니다. C 기반의 다른 애플리케이션과 차이가 있다면, iOS 앱에서는 main() 함수를 우리가 직접 작성하지 않는다는 것 정도입니다. 대신 Xcode 프로젝트를 생성하면 main() 함수가 자동으로 만들어지는데, 여기에는 iOS 앱이 실행될 때 처리해야 할 내용이 작성되어 있기 때문에 우리는 main() 함수를 전혀 건드릴 필요가 없습니다. 다음은 실제로 오브젝티브-C 기반의 Xcode 프로젝트를 생성했을 때 main.m 파일 안에 생성되는 main() 함수입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#<span class="keyword">import</span> "AppDelegate.h"</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])&#123;</span><br><span class="line">  @autoreleasepool&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="type">NSStringFromClass</span>([<span class="type">AppDelegate</span> <span class="class"><span class="keyword">class</span>]));</span></span><br><span class="line"><span class="class">  &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>main() 함수가 하는 일은 단순합니다. 실행 시 시스템으로부터 전달받은 두 개의 인자값과 AppDelegate 클래스를 이용하여 UIApplicationMain() 함수를 호출하고, 그 결과로 UIApplication 객체를 반환합니다. 생성된 UIApplication 객체는 UIKit 프레임워크에 속해있으므로 이후의 앱 제어권은 UIKit 프레임워크로 이관됩니다.</p>
<p><br></p>
<p>main() 함수가 C 기반 애플리케이션의 엔트리 포인트라면, UIApplicationMain() 함수는 그 중에서도 iOS 앱에 속하는 부분의 엔트리 포인트라고 할 수 있습니다. 이 함수는 앱의 핵심 객체를 생성하는 프로세스를 핸들링하고, 스토리보드 파일로부터 앱의 유저 인터페이스를 읽어들일뿐만 아니라 우리가 작성한 커스텀 코드를 호출해 줌으로써 앱 생성 초기에 필요한 설정을 구현할 수 있게 해 줍니다. 여기에 더해서 이벤트를 입력받기 위한 이벤트 루프를 실행시키기도 하죠. 이 과정에서 우리가 직접 구현해야 하는 것은 스토리보드 파일이나 초기화를 위한 커스텀 코드뿐입니다.</p>
<p><br></p>
<p>UIApplicationMain() 함수가 생성하는 UIApplication은 앱의 본체라고 할 수 있는 객체로, 사실상 앱 그 자체를 의미합니다. 우리가 작성한 커스텀 코드나 객체들, 그리고 우리가 앱의 기능이라고 생각하는 모든 것들은 다 UIApplication에 포함되어 있는 하위 객체입니다. 모바일 디바이스에 설치된 앱을 실행하면 초기 구동 과정을 거쳐 앱 프로세스가 메모리에 등록되는데, 이때의 앱 프로세스가 곧 UIApplication 객체라고 보아도 무방합니다.</p>
<p><br></p>
<p>UIApplication 객체의 역할은 매우 다양합니다. 이벤트 루프나 다른 높은 수준의 앱 동작을 관리할 뿐만 아니라 푸시 알림과 같은 특수한 이벤트를 우리가 정의한 커스텀 객체인 델리게이트에게 알려주기도 합니다. 우리는 이 클래스를 특별한 일이 있거나 중대한 목적이 있는 경우가 아니면 서브 클래싱 없이 그대로 사용합니다. 굳이 서브 클래싱할 필요도 없고, 하기도 어렵기 때문입니다.</p>
<p><br></p>
<p>그런데 달리 생각해보면 UIApplication 객체를 서브 클래싱하지 않고 그대로 사용하는 것에는 한계가 있습니다. 우리의 의도와 목적에 맞게 특별히 처리해야 할 것도 있을 수 있기 때문이죠. 그래서 UIApplication 객체는 AppDelegate라는 대리인, 아니 대리 객체를 내세우고 커스텀 코드를 처리할 수 있도록 약간의 권한을 부여합니다. AppDelegate는 UIApplication으로부터 위임받은 일부 권한을 이용하여 커스텀 코드와 상호작용하는 역할을 담당하고, 이를 통해 우리가 필요한 코드를 구현할 수 있도록 도와줍니다.</p>
<p><br></p>
<p>이 관계가 쉽게 이해되지 않는다면 기업의 회장과 비서실의 관계를 떠올려 보면 됩니다. 보통 회장은 회사의 아주 중요하고 핵심적인 일을 처리합니다. 즉 회사의 신사업 구상이나 방향성, 대외 업무 등을 담당하는 거죠. 하지만 사업을 구상하기 위해서는 자료 조사도 필요하고, 구상된 사업을 실제로 진척시키려면 현업에서 처리해야 할 일들이 많습니다. 이런 것들을 회장님이 직접 하지 않습니다. 대부분의 경우 최근 연구 동향을 조사해서 보고하게라든가 개발 사업을 진행할 사업부를 구성하게 하는 식으로 큰 방향성에 대한 오더를 비서진에 내리는 거죠. 이에 대한 권한을 위임받은 비서진은 이를 바탕으로 현업 부서에게 업무를 지시하고, 각 현업 부서는 이를 바탕으로 세부적인 업무를 짜서 진행하게 됩니다.</p>
<p><br></p>
<p>여기서 회장은 UIApplication 객체이고, 비서실은 AppDelegate 객체라고 생각하면 됩니다. 쉽게 말해 UIApplication 객체는 앱이 해야 할 아주 중요하고 핵심적인 일, 즉 앱의 생명 주기 관리나 이벤트 처리와 같은 것들을 담당하고, 앱 델리게이트는 커스텀 코드를 처리하는 비서의 성격을 띠는 것이죠.</p>
<p><br></p>
<p>AppDelegate 객체는 커스텀 코드와 연결되는 만큼, 대부분의 경우 커스터마이징하거나 혹은 서브클래싱하여 사용할 수 있도록 오픈되어 있습니다. 프로젝트를 생성하면 만들어지는 파일 중에서 AppDelegate.swift 파일을 보셨을 텐데요. 앞 장에서 그 안에 sleep(5) 구문을 넣어 시작 화면 노출 시간을 지연시켰던 것처럼 손쉽게 커스텀 코드를 작성할 수 있습니다.</p>
<p><br></p>
<p>AppDelegate 객체는 iOS 애플리케이션 내에서 오직 하나의 인스턴스만 생성되도록 시스템적으로 보장받습니다. 게다가 앱이 처음 만들어질 때 객체가 생성되고, 앱이 실행되는 동안 계속 유지되다가 앱이 종료도면 그때 함께 소멸하는 등 앱 전체의 생명 주기와 함께 합니다. 이런 특성 때문에 AppDelegate 객체에 데이터를 저장하면 앱이 종료될 때까지 계속 데이터를 유지할 수 있죠. 따라서 AppDelegate 객체는 종종 앱의 초기 데이터 구조를 설정하기 위해 사용되기도 합니다.</p>
<p><br></p>
<p>UIApplication 객체와 AppDelegate 객체가 연관되어 앱이 실행되는 전체 과정을 정리해 보면 다음과 같습니다.</p>
<p><br><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. main() 함수가 실행된다.</span><br><span class="line"><span class="number">2</span>. main() 함수는 다시 <span class="type">UIApplicationMain</span>() 함수를 호출한다.</span><br><span class="line"><span class="number">3</span>. <span class="type">UIApplicationMain</span>() 함수는 앱의 본체에 해당하는 <span class="type">UIApplication</span> 객체를 생성한다.</span><br><span class="line"><span class="number">4</span>. <span class="type">UIApplication</span> 객체는 info.plist 파일을 바탕으로 앱에 필요한 데이터와 객체를 로드한다.</span><br><span class="line"><span class="number">5</span>. <span class="type">AppDelegate</span> 객체를 생성하고 <span class="type">UIApplication</span> 객체와 연결한다.</span><br><span class="line"><span class="number">6</span>. 이벤트 루프를 만드는 등 실행에 필요한 준비를 진행한다.</span><br><span class="line"><span class="number">7</span>. 실행 완료 직전, 앱 델리게이트의 application(<span class="number">_</span>:didFinishLaunchingWithOptions:) 메소드를 호출한다.</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>반면, 스위프트는 C 기반의 언어가 아닙니다. 따라서 스위프트 기반 프로젝트에는 main.m 파일이 존재하지 않으며 엔트리 포인트 역시 존재하지 않습니다. 이 때문에 스위프트에서는 위의 1~5 과정을 다음과 같은 어노테이션 표기로 대체합니다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class="keyword">Any</span>]?]-&gt;Bool&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="literal">true</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>스위프트에서는 직접 UIApplicationMain()을 호출하여 델리게이트 클래스를 인자값으로 전달할 수 없으므로 대신 앱 델리게이트 역할을 할 클래스에 @UIApplicationMain 어노테이션을 걸어 표시하는 방식으로 시스템에 델리게이트 클래스 정보를 전달합니다. iOS 시스템은 앱을 실행할 때 이 어노테이션이 표시된 클래스를 찾아 델리게이트로 지정하게 되죠. 이후로 진행되는 나머지 과정은 모두 앞에서 설명한 것과 동일합니다. 아래 그림은 방금 설명한 일련의 과정을 요약하여 보여줍니다. 앱의 실행 과정을 설명하는 데에 많이 인용되는 유명한 그림입니다.</p>
<p><br></p>
<p><img src="/image/ios2.png" alt="ios2"></p>
<p><br></p>
<p>이 그림에 따라 앱이 실행되는 과정을 다시 한 번 정리해 봅시다. 왼쪽은 iOS 시스템 프레임워크이고, 오른쪽은 우리가 작성하는 커스텀 코드입니다. 시스템 프레임워크는 사용자가 앱 아이콘을 탭 했을 때 이를 인식하고 앱을 구동합니다. 최초에 main() 함수가 실행되고, 함수 내부에서 UIApplicationMain()을 호출하면 앱이 구동됩니다. 물론 스위프트에서는 main() 함수를 통해 UIApplicationMain()을 호출하는 대신 @UIApplicationMain 어노테이션을 찾아 해당하는 클래스를 실행하겠죠. 이때 우리의 커스텀 코드 쪽에서는 앱 델리게이트 클래스에 작성된 application(_:didFinishLaunchingWithOptions:) 메소드가 시스템에 의해 자동으로 호출됩니다. 즉, AppDelegate 클래스의 application(_:didFinishLaunchingWithOptions:) 메소드에 원하는 커스텀 코드를 작성해 두면 앱이 처음 시작될 때 해당 코드를 실행할 수 있다는 뜻입니다.</p>
<p><br></p>
<p>이어서 시스템 프레임워크의 이벤트 루프가 실행되면서 우리가 작성하는 이벤트 핸들에 의해 커스텀 코드로 연결됩니다. 시스템에서 발생할 수 있는 여러 이벤트 중에서 우리가 원하는 이벤트를 제어하도록 핸들을 만들어 커스텀 코드와 연결해 놓으면 이벤트 루프에서는 특정 이벤트가 발생했을 때 우리가 만든 핸들을 통하여 커스텀 코드를 실행할 수 있도록 처리합니다. 여기서 말하는 핸들은 앞에서 만들었던 @IBAction 메소드를 떠올리면 됩니다. 사용자가 어떤 객체를 클릭하거나 특정 액션을 취했을 때 실행되도록 구현해 놓는 것을 말하죠.</p>
<p><br></p>
<p>앱이 실행 목적을 모두 완료하고 더이상 사용되지 않으면 시스템은 앱을 메모리에서 제거하기 위한 준비를 합니다. 이 과정에서 앱 시스템은 델리게이트 클래스의 applicationWillTerminate(_:) 메소드를 호출합니다. ‘앱이 곧 종료될 테니 정리할 것이 있으면 얼른 하세요’하는 신호죠. 앱 종료 시에 처리해야 할 내용이 있다면 이 메소드 내부에 커스텀 코드로 작성해 두기만 하면 됩니다.</p>
<p><br></p>
<p>앱 델리게이트 프로토콜에는 위에서 설명한 두 개의 메소드뿐만 아니라 더 많은 메소드가 정의되어 있고, 각 메소드는 미리 약속된 시점에 맞추어 시스템에 의해 호출될 수 있도록 구성되어 있습니다. 이처럼 iOS 시스템에 의해 특정 시점마다 호출해주는 메소드가 이미 정의되어 있으므로 우리는 지정된 메소드에 커스텀 코드를 작성하기만 하면 앱의 생명 주기에 맞추어 원하는 내용을 실행시킬 수 있습니다.</p>
<p><br></p>
<p>(이만하고 우선 기본 문법으로 넘어가보자…!)</p>
<p><br></p>
<h4 id="스위프트-언어의-특징"><a href="#스위프트-언어의-특징" class="headerlink" title="스위프트 언어의 특징"></a>스위프트 언어의 특징</h4><p>스위프트는 파이썬이나 자바스크립트처럼 동적 바인딩(Dynamic Binding)을 채용하고 있는 언어는 아닙니다. C, C++, 오브젝티브-C, 자바처럼 정적 바인딩을 채용하고 있는 언어죠. 비록 데이터 타입 추론 기능에 의해 컴파일러가 알아서 변수와 상수의 타입을 결정하기 때문에 마치 동적 바인딩 언어인 것처럼 착각되기도 하지만, 기본적으로 스위프트는 정적 바인딩 언어입니다.</p>
<p><br></p>
<p>또한 스위프트는 데이터 타입에 대한 구분이 엄격합니다. 스위프트에서 선언된 변수와 상수는 컴파일 단계에서 데이터 타입이 미리 정의되어 있어야 하고, 일단 변수의 데이터 타입이 정의되면 다른 타입으로 변경할 수 없습니다. 이같은 엄격성을 바탕으로 컴파일러는 타입에 맞지 않는 데이터가 변수에 대입되는 것을 사전에 차단하여 안정성을 높일 수 있습니다.</p>
<p><br></p>
<p>스위프트는 네임스페이스를 사용하여 필요한 객체들을 참조하는데, 일반적으로 프로젝트 전체가 네임스페이스의 범위로 지정됩니다. 이는 같은 프로젝트 내에 작성된 객체일지라도 오브젝티브-C에서는 참조를 위해 일일이 헤더 파일을 반입해 주어야 했던 것과 다르게, 스위프트에서는 같은 프로젝트 내에 작성된 객체들은 반입 과정 없이 참조할 수 있다는 뜻입니다. 이 덕분에 스위프트에서 import 구문은 UIKit, Foundation 등의 프레임워크나 라이브러리 정도에만 사용하게 되어 개발 생산성을 향상할 수 있게 되었습니다.</p>
<p><br><br>자바스크립트 프로그래머들은 대괄호 구문을 이용하여 값을 배열로 만들거나 문자열을 입력받는데, 이것이 해시 테이블 역할을 합니다. 스위프트도 마찬가지입니다. 대괄호를 사용하여 해시 테이블을 만들 수 있죠. 애플에서는 이것을 딕셔너리라고 부르며, 초기화할 수 있는 구문을 제공합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports = [<span class="type">String</span>: <span class="type">String?</span>]()</span><br><span class="line">airports[<span class="string">"ICN"</span>] = <span class="string">"Inchon International Airport"</span></span><br><span class="line">airports[<span class="string">"ICN"</span>] = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="데이터-타입-추론-함수형-프로그래밍-언어"><a href="#데이터-타입-추론-함수형-프로그래밍-언어" class="headerlink" title="데이터 타입 추론 - 함수형 프로그래밍 언어"></a>데이터 타입 추론 - 함수형 프로그래밍 언어</h5><p>프로그래머 관점에서 변수를 특정 데이터 형식으로 강제하면 코드를 실행해 보기 전에 버그를 미리 잡을 수 있어 효율적입니다. 컴파일러가 데이터 형식을 확인하고 비호환성이 발견되면 오류를 검출해주기 때문입니다. 하지만 편리함을 추구하는 현대 프로그래밍에서 모든 변수마다 데이터 형식을 일일이 지정하는 고생을 감수할 사람은 그다지 많지 않습니다.</p>
<p><br></p>
<p>최근의 우수한 컴파일러들은 데이터로부터 스스로 형식을 추론할 수 있으므로 컴파일러가 알아서 변수에 데이터 형식을 지정할 수 있게 되었습니다. 데이터 타입은 강제하지만, 데이터 타입을 생략할 수 있는 스위프트 컴파일러의 발전 덕분에 iOS 개발자들도 이제 코드 입력에 드는 수고를 조금은 덜 수 있게 되었습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meaningOfLife = <span class="number">42</span></span><br><span class="line"><span class="comment">// meaningOfLife is inferred to be of type Int</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>(그러면 변수가 무엇인지 잠시 살펴보러 가자…)</p>
<p><br></p>
<h4 id="변수와-상수"><a href="#변수와-상수" class="headerlink" title="변수와 상수"></a>변수와 상수</h4><p>스위프트는 데이터가 저장되는 메모리 내 주소 공간을 개발자가 쉽게 인식하고 사용할 수 있도록 이름으로 연결한 변수와 상수를 제공합니다. 예를 들어 연도를 의미하는 1999라는 숫자 데이터가 메모리 주소 0x12345678~0x1234567B까지에 걸쳐 저장되어 있다고 해 봅시다. 숫자 데이터를 꺼내어 사용할 때마다 항상 이 주소값을 사용할 수 없습니다. 그러기엔 주소값이 너무 길고, 단순히 16진수 숫자들로 되어 있어 외우기도 어려기 때문입니다. 그래서 이 주소값을 “year”라는 이름으로 연결합니다.</p>
<p><br></p>
<p><img src="/image/ios3.png" alt="ios3"></p>
<p><br></p>
<p>우리가 “year”라는 단어를 특정 형식에 따라 사용하면 컴파일러는 내부에 저장된 메모리 주소록을 뒤져서 year라는 이름으로 연결된 0x12345678~0x1234567B까지의 주소를 확인하고, 각각의 주소에 저장된 값을 읽어와 하나로 합친 1999라는 데이터를 만들어 줍니다. 이름으로 메모리 주소를 등록해 두지 않았다면 저장된 값을 꺼내기 위해서는 주소 공간 하나하나를 직접 찾아 값을 합쳐서 사용해야 하지만, 이름을 저장해 놓는다면 year라는 인식하기 쉬운 단어만으로 저장된 값을 쉽게 불러올 수 있습니다.</p>
<p><br></p>
<p>이렇게 값을 저장한, 혹은 저장할 메모리 주소값을 이름으로 연결해 놓은 것을 변수와 상수라고 합니다. 우리는 변수와 상수를 이용하여 메모리 주소에 해당하는 공간에 손쉽게 값을 저장하거나 꺼낼 수 있습니다. 일반적으로 이같은 과정을 떠올리는 대신 변수와 상수에 값을 저장한다고 생각해도 무방합니다.</p>
<p><br></p>
<p>변수와 상수는 값을 저장할 수 있다는 공통점이 있지만, 상수는 한 번 저장된 값을 다른 값으로 변경할 수 없는 반면에 변수는 필요에 따라 저장된 값을 몇 번이라도 다른 값으로 변경할 수 있습니다. 그래서 변수에는 프로그램 실행에 따라 변하는 값을 저장하고, 상수에는 변하지 않을 값을 저장합니다.</p>
<p><br></p>
<p>하지만 변수라고 해서 아무 값이나 마음대로 저장할 수 있는 것은 아닙니다. 변수의 값을 변경할 때에는 처음 저장했던 값과 일치하는 타입이어야 합니다. 예를 들어, 변수에 처음 저장된 값이 정수였다면 이후로도 정수만 저장할 수 있습니다. 처음 저장한 값이 문자열이었다면 이후로 변경할 수 있는 값 역시 문자열뿐입니다. 즉 변수는 처음 입력한 값과 동일한 타입에 한해서만 값을 변경할 수 있습니다. 변경할 값이 처음 저장한 값과 일치하는 형태인지는 곧이어 자료형을 배우고 나면 알게 될 겁니다.</p>
<p><br></p>
<p>이쯤에서 상수가 왜 필요한지에 대해 궁금한 독자들이 있을지도 모르겠습니다. 변수에 값을 저장해 놓고 변경하지 않으면 그만이지, 왜 굳이 상수가 있어야 하냐 하고 말이죠. 하지만 성능이나 기타 다른 기술적 이점은 차치하고라도, 프로그래밍 소스 관리 목적상 변하지 않는 값은 상수에 저장하는 것이 훨씬 효율적입니다. 실수로 값이 변경되는 일도 막을 수 있고, 값의 성격이 명확히 분류되므로 관리하기에도 용이하기 때문입니다.</p>
<p><br></p>
<p>질문!! 억지로 다른 자료형의 값을 집어넣으면 어떻게 되죠? 오류가 발생합니다. 스위프트에서는 변수의 초기값이 지정되면 그 값에 의해 변수의 타입이 결정되고, 이후로는 타입의 변경이 불가능합니다. 따라서 억지로 다른 타입의 값을 집어넣으려고 한다면 이는 컴파일 오류로 이어지게 됩니다.</p>
<p><br></p>
<p>(무언가 공부에 효율이 안난다…Do it! 첫 앱 만들기)</p>
<p><br></p>
<ul>
<li>레이블 추가</li>
<li>버튼 추가</li>
<li>버튼 클릭시, 기존 레이블 변경</li>
</ul>
<ul>
<li>스토리보드에서 할일</li>
</ul>
<ul>
<li>레이블 추가하기</li>
<li>버튼 추가 하기</li>
<li>뷰 컨트롤러에 버튼 액션 연결하기</li>
</ul>
<ul>
<li>코드에서 할일</li>
</ul>
<ul>
<li>메소드 새로 추가하기</li>
</ul>
<p><br></p>
<p>이제 스토리보드를 사용하여 간단한 앱 화면을 꾸며 보겠습니다. 이 앱에서는 텍스트를 보여주는 레이블(Label) 객체와 사용자가 직접 글자를 입력할 수 있는 텍스트 필드(Text Field) 객체, 이름을 전송하는 버튼(Button) 객체를 사용합니다. 객체란 사용자 인터페이스를 위해 사용하는 레이블, 버튼 등의 오브젝트를 의미하며 라이브러리에서 가져와 사용할 수 있습니다. 스토리보드에 배치된 객체는 사용자로부터 입력을 받거나 사용자 인터페이스 역할을 합니다. 아래 그림은 완성된 스토리보드 화면입니다. 이 그림과 사용된 객체를 참고하여 배치해 보겠습니다.</p>
<p><br></p>
<p><img src="/image/ios4.jpeg" alt="ios4"></p>
<p><br></p>
<h5 id="1-레이블-추가하기"><a href="#1-레이블-추가하기" class="headerlink" title="1. 레이블 추가하기"></a>1. 레이블 추가하기</h5><p>먼저 ‘Welcome’이라는 메시지를 출력할 레이블을 추가해 보겠습니다.</p>
<p><br></p>
<h5 id="2-레이블-두-개-더-추가하기"><a href="#2-레이블-두-개-더-추가하기" class="headerlink" title="2. 레이블 두 개 더 추가하기"></a>2. 레이블 두 개 더 추가하기</h5><p>같은 방법으로 레이블을 두 개 더 추가합니다. 두 번째 레이블의 내용은 비워두고, 세 번째 레이블에는 ‘Name:’을 입력합니다.</p>
<p><br></p>
<h5 id="3-텍스트-필드-추가하기"><a href="#3-텍스트-필드-추가하기" class="headerlink" title="3. 텍스트 필드 추가하기"></a>3. 텍스트 필드 추가하기</h5><p>텍스트 필드는 사용자로부터 텍스트를 입력받을 때 사용하는 객체입니다. 여기서는 텍스트 필드를 사용하여 이름을 입력받고, 입력 완료의 의미로 버튼을 클릭하여 앱에 전달할 용도로 텍스트 필드와 버튼을 추가하여 배치해 보겠습니다.</p>
<p><br></p>
<h5 id="4-버튼-추가하기"><a href="#4-버튼-추가하기" class="headerlink" title="4. 버튼 추가하기"></a>4. 버튼 추가하기</h5><p><br></p>
<h5 id="5-레이블에-아웃렛-변수-추가하기"><a href="#5-레이블에-아웃렛-변수-추가하기" class="headerlink" title="5. 레이블에 아웃렛 변수 추가하기"></a>5. 레이블에 아웃렛 변수 추가하기</h5><p>스토리보드에 추가한 객체를 선택하고 내용을 변경하거나 특정 동작을 수행하도록 하기 위해서는 해당 객체에 접근할 수 있는 변수인 ‘아웃렛 변수’와 동작을 정의한 함수인 ‘액션 함수’가 필요합니다. 예를 들어 앞에서 만든 텍스트 필드에 사용자가 이름을 입력하면 입력한 텍스트를 받아 저장할 변수를 만들고, 만든 변수와 텍스트 필드를 연결시켜줘야 합니다. 이러한 변수를 아웃렛 변수라고 합니다. 그리고 [Send] 버튼을 클릭했을 때 입력한 이름을 읽어서 레이블에 출력하는 함수를 만들고 이 함수를 버튼과 연결시켜줘야 합니다. 이런 함수를 액션 함수라고 합니다.</p>
<p><br></p>
<h5 id="ViewController-swift"><a href="#ViewController-swift" class="headerlink" title="ViewController.swift"></a>ViewController.swift</h5><p><p><p></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> lblName: <span class="type">UILabel!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> txtName: <span class="type">UITextField!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>(위의 코드에서 !의 의미를 조금 더 파헤쳐 보자!)<br>(만약 !를 지우면 다음과 같은 오류가 나타난다…)</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> property has non-<span class="keyword">optional</span> type '<span class="type">UILabel'</span></span><br><span class="line"><span class="type">Add</span> '?' to form the <span class="keyword">optional</span> type '<span class="type">UILabel?</span>'</span><br><span class="line"><span class="type">Add</span> '!' to form an implicitly unwrapped <span class="keyword">optional</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위의 내용에 따라 ? 혹은 !을 붙여줘야 오류가 나지 않는다. 해당 라인에서는 변수를 선언할 때 콜론을 붙이고 그 타입을 명시적으로 선언해 줌으로써 어떤 타입의 값이 저장될 것인지를 컴파일러에게 직접 알려주고 있다. 그렇다면 UILabel 혹은 UITextField가 변수의 타입이라는 점을 유추해 볼 수 있는데, 기본 자료형이 아니라는 점에서 특정 클래스 정의에 따른 자료형, 즉 객체가 된다는 것일까?</p>
<p><br></p>
<p>아직 자신이 없으니 !을 좀 더 살펴보도록 하자. 이를 위해서는 옵셔널을 알아야 한다. 옵셔널 타입이란 반환하고자 하는 값을 옵셔널 객체로 다시 한 번 감싼 형태를 의미한다. 스위프트에서는 일단 오류가 발생할 가능성이 있기만 하면, 성공적으로 처리했더라도 일단 옵셔널 타입으로 감싸서 반환한다. 처리가 성공적일 경우, 옵셔널 타입으로 반환된 값을 열어보면 실제 값이 옵셔널 타입으로 둘러싸여 있는 것을 볼 수 있다. 이를 옵셔널 래핑(Optional Wrapping)이라고 한다. 이렇게 받은 값은 옵셔널 언래핑(Optional Unwrapping)이라고 불리는 특수한 처리 과정을 통해 옵셔널 타입을 해제하고 실제 값을 추출하여 사용해야 한다. 단, 처리 결과가 실패여서 옵셔널 타입의 값이 nil이라면 옵셔널 타입을 해체해서는 안 된다.</p>
<p><br></p>
<p>만약 위의 코드에서 var lblName: UILabel?로 선언한다면 옵셔널 타입으로 만들게 되는 것이다. 즉, Optional UILabel 타입을 의미하게 되며, 이로써 nil을 대입할 수 있다. 이렇게 전달받은 옵셔널 타입의 결과값은 그 자체로는 아무것도 할 수 없다. 옵셔널 타입은 애초에 연산을 지원하지 않는 타입이다. 따라서 옵셔널 타입과 일반 타입은 서로 연산할 수 없으며 옵셔널 타입끼리의 연산이나 결합도 지원하지 않는다.</p>
<p><br></p>
<p>이 옵셔널 값을 사용하는 방법에 대해 알아보면 위의 코드의 비밀이 서서히 풀린다. 우리가 결과값으로 전달받는 것이 Optional 객체인 것이다. 그 내부에 우리가 원하는 값이 들어있는 것이다. 이 값을 우리가 원하는 대로 사용하려면 실제 값을 둘러싼 옵셔널 객체를 해제해야 한다. 옵셔널 객체를 해제하면 일반 타입의 값이 되는데, 이 값이 비로소 우리가 직접 사용할 수 있는 값이다. 이처럼 옵셔널 객체를 해제하고 내부에 있는 값을 추출하는 과정을 옵셔널 해제, 혹은 옵셔널 언래핑이라고 하는 것이다.</p>
<p><br></p>
<p>옵셔널 해제 방식은 명시적 해제와 묵시적 해제로 나누어지는데, 위의 오류에서 알 수 있듯이 묵시적 해제는 각각 컴파일러에 의한 자동 해제와 연산자를 사용한 자동 해제로 나눌 수 있다. 위에서는 ! 연산자를 통한 자동 해제를 말하고 있다. 이렇게 처리해 주면 옵셔널 객체가 해제되고, 그 내부에 저장된 값을 꺼내 사용할 수 있게 된다. 자, 이제 다시 코드로 돌아가보자…</p>
<p><br></p>
<h5 id="6-버튼-클릭-시-동작할-함수-구현하기"><a href="#6-버튼-클릭-시-동작할-함수-구현하기" class="headerlink" title="6. 버튼 클릭 시 동작할 함수 구현하기"></a>6. 버튼 클릭 시 동작할 함수 구현하기</h5><p>[Send] 버튼을 클릭했을 때 동작할 btnSend 액션 함수를 다음과 같이 코딩합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">btnSend</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">    lblName.text = txtName.text!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="7-시뮬레이터로-결과-화면-확인하기"><a href="#7-시뮬레이터로-결과-화면-확인하기" class="headerlink" title="7. 시뮬레이터로 결과 화면 확인하기"></a>7. 시뮬레이터로 결과 화면 확인하기</h5><p><br></p>
<p><img src="/image/ios5.png" alt="ios5"></p>
<p><br><br></p>
<p>(자, 이제 답답함은 풀렸으니 다시금 문법편으로 돌아가자…)</p>
<p><br></p>
<h4 id="변수와-상수를-정의하는-방법"><a href="#변수와-상수를-정의하는-방법" class="headerlink" title="변수와 상수를 정의하는 방법"></a>변수와 상수를 정의하는 방법</h4><p>스위프트에서 변수와 상수는 반드시 먼저 선언한 다음에 사용해야 합니다. 이것은 ‘이러이러한 변수를 사용하겠다’ 또는 ‘이런 이름의 상수를 사용하겠다’라는 것을 컴파일러에게 알려주기 위함입니다. 마치 해외 여행 시 숙소를 정할 때 호텔에다 ‘이런이런 타입의 방을 XXX 이름으로 예약해주세요’라고 하는 것과 같다고 할까요? 변수와 상수를 정의하는 실제 구문을 살펴 보겠습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> year = <span class="number">1999</span> <span class="comment">// 정수형 변수</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello, World"</span> <span class="comment">// 문자열 변수</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>작성된 구문에서 두 개의 변수는 각각 정수 또는 문자열을 담을 목적으로 정의되었습니다. ‘=’ 연산자를 통해 대입된 값을 보면 알 수 있죠. year라는 이름을 가진 변수에는 1999라는 정수를 대입했으므로 정수형 타입의 변수가 되고, message라는 이름으로 정의된 변수에는 “Hello, World”라는 문자열을 대입했으므로 문자열 타입의 변수가 됩니다.</p>
<p><br></p>
<p>한번 정해진 타입은 바꿀 수 없어서, 정수형 타입의 변수에는 이후로도 정수만 대입할 수 있고, 문자열 타입의 변수에는 문자열만 대입할 수 있습니다. 스위프트에서 변수의 타입은 대부분 맨 처음 대입된 값에 따라 정해지고, 이후로는 타입을 변경할 수 없습니다. 마치 새끼 오리가 세상에 태어나 맨 처음 본 존재를 엄마로 삼는 것과 비슷하죠. var 키워드로 선언된 변수애 처음으로 값을 대입하는 과정을 초기화라고 합니다. 예제에서 본 것처럼, 대입 연산자를 이용하여 이루어지죠. 스위프트는 대부분 초기화 과정에서 변수의 타입이 결정되는데, 이때 활약하는 것이 바로 컴파일러입니다. 컴파일러는 변수에 대입될 값을 검토하여 가장 적절한 타입을 추론하고 그에 맞는 메모리 공간을 확보한 다음, 여기에 값을 저장합니다. 이때부터 우리는 해당 변수를 사용할 수 있게 됩니다.</p>
<p><br></p>
<p>타입에 따라 필요한 메모리 공간이 다르기 때문에, 변수의 타입을 결정하는 과정은 프로그래밍 언어의 성능과 효율성을 결정하는 중요한 요소가 되기도 햡니다. 4바이트만 있으면 충분함에도 확장성을 너무 고려한 나머지 8바이트나 그 이상의 공간을 잡아 놓는다면 그건 결국 메모리의 낭비로 이어질 테니까요. 이 때문에 스위프트는 ‘타입 추론기’라는 기능 모듈을 컴파일러에 별도로 내장하여, 항상 최적의 타입을 결정하고자 합니다.</p>
<p><br></p>
<p>(다 따라치면 오히려 효율이 떨어지네…그냥 코드만 남겨두자…!)</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello, playground"</span></span><br><span class="line"><span class="built_in">print</span>(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 선언과 초기화 분리</span></span><br><span class="line"><span class="keyword">var</span> year: <span class="type">Int</span>  <span class="comment">// 변수 선언</span></span><br><span class="line">year = <span class="number">1999</span>  <span class="comment">// 선언된 변수의 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수의 값 변경하기</span></span><br><span class="line"><span class="keyword">var</span> vValue = <span class="number">3</span></span><br><span class="line">vValue = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 상수의 값 변경하기</span></span><br><span class="line"><span class="keyword">let</span> cValue = <span class="number">3</span></span><br><span class="line"><span class="comment">// cValue = 7  오류: Cannot assign to value: 'cValue' is a 'let' constant</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수의 선언 및 초기화</span></span><br><span class="line"><span class="keyword">var</span> intValue = <span class="number">3</span>  <span class="comment">// Int 타입으로 초기화</span></span><br><span class="line"><span class="keyword">var</span> strValue = <span class="string">"Hello World"</span>  <span class="comment">// String 타입으로 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 새로운 값으로 변경</span></span><br><span class="line"><span class="comment">// intValue = "안녕하세요"  // Int 타입을 String 타입으로 변경 // 오류: Cannot assign value of type 'String' to type 'Int'</span></span><br><span class="line"><span class="comment">// strValue = 100  // String 타입을 Int 타입으로 변경 // 오류: Cannot assign value of type 'Int' to type 'String'</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="자료형"><a href="#자료형" class="headerlink" title="자료형"></a>자료형</h4><p>Int 자료형에 현미경을 들이대 봅시다. Int는 사실 SignedInteger를 구현한 구조체의 일종입니다. 지금은 Int 자료형이 ‘SignedInteger’라는 객체를 뼈대로 하여 만들어졌다는 정도만 이해하는 것으로 합시다.</p>
<p><br></p>
<p><img src="/image/ios6.png" alt="ios6"></p>
<p><br></p>
<p>소수점이 포함된 실수 값을 저장해야 하는 경우 사용할 수 있는 자료형이 Double 타입과 Float 타입입니다. 일반적으로 Float 타입이 소수점 아래 7~8자리까지의 값을 정확하게 저장할 수 있는 반면 Double 타입은 소수점 아래 15~16자리의 값에 대한 정확도를 보장하기 때문에 훨씬 더 세밀한 값을 저장하는 데 유리합니다. 당연히 메모리에서 차지하는 크기도 Double 타입이 더 크고 말이죠. 재미있는 것은 스위프트에서 Float 타입의 서브 자료형으로 사용되는 Float32와 Float64입니다. 이 둘은 실제로 존재하는 객체가 아니라 타입알리어스(typealias)에 의해 정의된 타입들입니다. 여기에서 타입알리어스란 타입을 가리키는 표현만 달리하는 것을 의미합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A 32-bit floating point type</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Float32</span> = <span class="type">Float</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// A 64-bit floating point type</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Float</span> <span class="number">64</span> = <span class="type">Double</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>문자열을 저장할 때 기존의 오브젝티브-C를 사용했던 분들이라면 NSString이라는 객체에 익숙할 텐데요. NSString 객체는 오브젝티브-C 언어용 String 타입이라고 생각하면 됩니다. 파운데이션 프레임워크에서 문자열을 쉽게 다루기 위해 제공하는 클래스이죠. 프레임워크 레벨에서 제공하는 객체이니만큼 import Foundation이라는 구문을 통해 프레임워크를 반입한 다음에야 사용할 수 있습니다. 하지만 String 타입은 스위프트 언어에서 제공되는 기본 자료형이므로 프레임워크 반입 없이도 사용할 수 있습니다. 스위프트의 String과 오브젝티브-C의 NSString은 서로 호환되기 때문에 NSString을 String으로, 또는 String을 NSString으로 변환할 수 있습니다. 따라서 오브젝티브-C에서 NSString으로 정의된 값을 스위프트에서 사용하려면 String 타입으로 변환하면 됩니다. 아, 물론 스위프트에서도 NSString을 사용할 수도 있습니다. import Foundationd이라는 구문을 사용하여 파운데이션 프레임워크만 반입하면 말이죠.</p>
<p><br></p>
<p>앞서 소개한 String은 여러 글자로 이루어진 문자열을 저장할 수 있는 일종이 집단 자료형이지만, Character는 한 개의 문자를 저장할 수 있는 단일 자료형입니다. String 타입에 저장된 문자열을 하나씩 분해하면 Character 타입이 됩니다.</p>
<p><br></p>
<h4 id="타입-추론과-타입-어노테이션"><a href="#타입-추론과-타입-어노테이션" class="headerlink" title="타입 추론과 타입 어노테이션"></a>타입 추론과 타입 어노테이션</h4><p>타입 어노테이션(Type annotation)이란, 변수나 상수를 선언할 때 그 타입을 명시적으로 선언해 줌으로써 어떤 타입의 값이 저장될 것인지를 컴파일러에게 직접 알려주는 문법입니다. 변수나 상수명 뒤에 콜론(:)을 붙이고, 이어서 저장될 값의 타입을 작성해주면 됩니다. 그런데 뭔가 이상하다고 느낀 것 없으세요? 지금까지는 변수나 상수를 선언할 때 타입을 명시해 준 적이 없었잖아요. 그냥 값만 넣어 초기화해줬을 뿐이죠. 어떻게 된 걸까요? 이 궁금증을 해소하기 위해 우리는 먼저 타입 추론에 대해 학습해 볼 필요가 있습니다. 타입 추론은 변수나 상수를 초기화할 때 입력된 값을 분석하여 변수에 적절한 타입을 컴파일러가 스스로 추론하는 기능입니다.</p>
<p><br></p>
<p>그렇다면 타입 어노테이션을 써야 할지 말아야 할지 고민이 될 때는 어떻게 해야 할까요? 결론부터 말하자면, 반드시 타입 어노테이션을 사용해야 하는 다음 두 가지 경우를 제외하면 타입을 명시적으로 선언하지 않아도 됩니다.</p>
<p>첫 번째] 선언과 초기화를 분리할 경우<br>타입 추론은 변수나 상수의 선언 시 입력된 초기값을 이용하여 가장 적절한 타입을 추론해 내는 과정입니다. 스위프트에서 변수와 상수는 선언하는 시점에서 타입이 결정되어야 하는데, 선언과 동시에 값을 초기화하면 자동으로 타입을 결정할 수 있어 타입 어노테이션이 필요 없습니다.</p>
<p><br></p>
<p>변수는 그렇다 치더라도, 상수는 선언과 초기화를 분리할 수 없으니 타입 어노테이션이 필요 없는 것 아니냐고 생각하는 분들을 위해 부연 설명드리자면 반드시 그런 것만은 아닙니다. 일반적으로 상수를 선언할 때 반드시 초기화를 함께 해주어야 하지만, 클래스나 구조체에서 멤버로 선언된 상수는 선언과 초기화가 동시에 이루어지지 않더라도 오류가 발생하지 않습니다. 단, 초기화 블록 내에서 상수의 값을 결정해 주어야 하지만요.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: <span class="type">String</span></span><br><span class="line">s = <span class="string">"Hello"</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"># error: cannot assign to value: 's' <span class="keyword">is</span> a '<span class="keyword">let</span>' constant</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>두 번째] 타입 추론으로 얻어지는 타입이 아닌, 다른 타입을 직접 지정할 필요가 있을 때</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Int 타입으로 정의 (타입 추론)</span></span><br><span class="line"><span class="keyword">var</span> temper1 = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(temper1)  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Float 타입으로 정의 (타입 어노테이션)</span></span><br><span class="line"><span class="keyword">var</span> temper2: <span class="type">Float</span> = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(temper2)  <span class="comment">// 3.0</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>스위프트에서는 문자열과 문자에 모두 큰따옴표를 사용합니다. 보통 이럴 때 컴파일러가 취할 수 있는 합리적인 판단은 더 넓은 범위의 타입으로 추론하는 것입니다. 따라서 타입 어노테이션 없이 변수나 상수에 한 글자 문자를 대입하면 컴파일러는 문자열로 추론하고, 해당 변수를 String 타입으로 정의합니다.</p>
<p><br></p>
<p>동일한 값이라도 마찬가지입니다. 타입 어노테이션을 작성한 것과 작성하지 않은 것은 엄연히 다른 결과를 나타냅니다. 아래 두 변수는 동일한 “C”라는 값으로 초기화되지만 타입 어노테이션이 명시된 변수는 Character 타입으로 선언되는 반면 타입 어노테이션이 생략된 변수는 String 타입으로 선언됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cValue: <span class="type">Character</span> = <span class="string">"C"</span>  <span class="comment">// Character</span></span><br><span class="line"><span class="keyword">var</span> sValue = <span class="string">"C"</span>  <span class="comment">// String</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="타입이-다른-변수끼리의-결합"><a href="#타입이-다른-변수끼리의-결합" class="headerlink" title="타입이 다른 변수끼리의 결합"></a>타입이 다른 변수끼리의 결합</h4><p>스위프트에서 서로 다른 타입의 변수나 상수끼리의 결합 연산은 허용되지 않습니다. 변수의 타입을 변경해서 결합해 보려고 해도, 한 번 타입이 정해지고 나면 다른 타입으로 변경할 수도 없죠. 타입이 서로 다른 변수, 예를 들어 문자열과 숫자를 결합하려면 어떻게 해야 할까요?</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stmt = <span class="string">"꼼꼼한 재은씨의 키는 "</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="number">185</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> heightStmt = stmt + <span class="type">String</span>(height)</span><br><span class="line"><span class="built_in">print</span>(heightStmt)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>앞의 예제에서 stmt와 height는 타입 추론에 따른 결과로 각각 String과 Int 타입입니다. 우리가 원하는 것은 이 두 개의 변수를 합하여 문자열을 만들어내는 것이지만, 서로 타입이 다르기 때문에 두 변수 간의 결합은 불가능합니다. stmt를 Int 타입으로 바꾸거나 height를 String 타입으로 바꿀 수도 없습니다. 일단 타입이 정해진 변수와 상수는 다른 타입으로 변경할 수 없으니까요.</p>
<p><br></p>
<p>변수의 값을 다른 타입으로 변경해야 할 필요가 있다면, 바꾸고자 하는 타입의 새로운 객체를 명시적으로 생성해야 합니다. 이떄의 객체는 보통 변수나 상수를 의미합니다. 다행히 스위프트의 기본 자료형 객체들은 다른 타입의 값을 자신의 타입에 맞게 변환하여 새로운 객체를 만드는 방법을 제공합니다. 정확하게 짚고 넘어갑시다. 정수값이나 기존의 변수를 문자열 타입으로 바꾸는 것이 아니라, 새로운 문자열 인스턴스를 만드는 것입니다. 기존의 변수에는 아무런 영향이 없이, 새로 생성하는 것이라는 점에 주의해야 합니다. </p>
<p><br></p>
<h4 id="문자열-템플릿"><a href="#문자열-템플릿" class="headerlink" title="문자열 템플릿"></a>문자열 템플릿</h4><p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 상수와 변수를 정의</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"꼼꼼한 재은씨"</span></span><br><span class="line"><span class="keyword">let</span> year = <span class="number">2014</span></span><br><span class="line"><span class="keyword">let</span> month = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> day = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 템플릿을 사용한 문자열 결합</span></span><br><span class="line"><span class="keyword">let</span> profile = <span class="string">"\(name)는 \(year)년 \(month)월 \(day)일에 출간되었습니다."</span></span><br><span class="line"><span class="built_in">print</span>(profile)</span><br><span class="line"><span class="comment">// 꼼꼼한 재은씨는 2014년 10월 1일에 출간되었습니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 상수 정의</span></span><br><span class="line"><span class="keyword">let</span> apple = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> banana = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> orange = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 출력할 구문을 문자열 템플릿으로 구성</span></span><br><span class="line"><span class="keyword">let</span> desc = <span class="string">"과일은 총 \(apple+banana+orange)개 입니다."</span></span><br><span class="line"><span class="built_in">print</span>(desc)</span><br><span class="line"><span class="comment">// 과일은 총 9개 입니다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="string">"1부터 5까지의 숫자의 합은 \(1+2+3+4+5)입니다."</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">// 1부터 5까지의 숫자의 합은 15입니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="범위-연산자"><a href="#범위-연산자" class="headerlink" title="범위 연산자"></a>범위 연산자</h4><p><br></p>
<p>닫힌 범위 연산자는 주어진 피연산자 a, b를 포함하는 범위를 나타내는 연산자입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> ... <span class="number">5</span> <span class="comment">// 1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>반 닫힌 범위 연산자는 반이란 반대가 아닌 절반을 이야기합니다. 해석하자면 절반만 닫힌 연산자를 뜻으로, 연산자의 양쪽 경계 중에서 왼쪽 경계는 포함하되 오른쪽 경계는 포함하지 않는 연산자입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> .. &lt; <span class="number">5</span> <span class="comment">// 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>닫힌 범위 연산자는 양쪽 값 모두 포함하는 특성 때문에 for~in 구문에서 일정 횟수만큼 반복할 때 사용되는 경우가 많습니다. 반면에, 반 닫힌 연산자는 마지막 값을 범위에 포함하지 않는 특성이 배열의 인덱스와 일치하기 때문에 배열을 순회할 때 많이 사용됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 닫힌 범위 연산자</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> a ... b&#123;</span><br><span class="line">    row</span><br><span class="line">&#125; <span class="comment">// 5 times</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 반 닫힌 범위 연산자</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> a ..&lt; b&#123;</span><br><span class="line">    row</span><br><span class="line">&#125; <span class="comment">// 4 times</span></span><br></pre></td></tr></table></figure>

    </div>

    

    
        <div class="post-tags">
            <i class="fa fa-tags" aria-hidden="true"></i>
            <a href="/tags/ios/">#iOS</a> <a href="/tags/swift/">#swift</a>
        </div>
    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo" target="_blank" rel="noopener">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/05/19/hackerrank-class-vs-instance/">[HackerRank] Class vs. In</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/05/17/hackerrank-intro-to-conditional-statements/">[HackerRank] Intro to Con</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/05/17/hackerrank-operator/">[HackerRank] Operators</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/05/13/hackerrank-data-types/">[HackerRank] Data Types</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/algorithm/selection-sort/">selection sort</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/algorithm/graph/">graph</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/vuejs/">vuejs</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/computational-modeling/">Computational Modeling</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

</body>

</html>