<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="밑바닥부터 시작하는 iOS 앱 개발 (5)
본 포스팅은 “꼼꼼한 재은씨의 Swift”와 “야곰의 iOS 프로그래밍”을 정리한 내용입니다.
로그인 페이지
View Controller
Navigation
MVC Programming Design Pattern
Alert C">
    

    <!--Author-->
    
        <meta name="author" content="Sunny Cho">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="[iOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (5)"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="QuantPsy"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>[iOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (5) - QuantPsy</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2020/02/24/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%8F%84%EC%A0%84%EA%B8%B0-5/">
                [iOS] 밑바닥부터 시작하는 iOS 앱 개발 도전기 (5)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-24</span>
            
            
            
                <span class="category">
                    <a href="/categories/ios/">iOS</a>
                </span>
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h1 id="밑바닥부터-시작하는-iOS-앱-개발-5"><a href="#밑바닥부터-시작하는-iOS-앱-개발-5" class="headerlink" title="밑바닥부터 시작하는 iOS 앱 개발 (5)"></a>밑바닥부터 시작하는 iOS 앱 개발 (5)</h1><p><br></p>
<h5 id="본-포스팅은-“꼼꼼한-재은씨의-Swift”와-“야곰의-iOS-프로그래밍”을-정리한-내용입니다"><a href="#본-포스팅은-“꼼꼼한-재은씨의-Swift”와-“야곰의-iOS-프로그래밍”을-정리한-내용입니다" class="headerlink" title="본 포스팅은 “꼼꼼한 재은씨의 Swift”와 “야곰의 iOS 프로그래밍”을 정리한 내용입니다."></a>본 포스팅은 “꼼꼼한 재은씨의 Swift”와 “야곰의 iOS 프로그래밍”을 정리한 내용입니다.</h5><p><br></p>
<h4 id="로그인-페이지"><a href="#로그인-페이지" class="headerlink" title="로그인 페이지"></a>로그인 페이지</h4><ul>
<li>View Controller</li>
<li>Navigation</li>
<li>MVC Programming Design Pattern</li>
<li>Alert Controller</li>
<li>Application: Life Cycle / Execution States</li>
<li>UIViewController: View Status callback methods</li>
</ul>
<p><br><br></p>
<h4 id="CHAPTER-07-함수-함수가-갑입니다"><a href="#CHAPTER-07-함수-함수가-갑입니다" class="headerlink" title="CHAPTER 07 함수: 함수가 갑입니다"></a>CHAPTER 07 함수: 함수가 갑입니다</h4><p><br></p>
<p>함수(Function)는 대부분의 프로그래밍 언어에서 지원하는 개념으로, 프로그램의 실행 과정 중에서 독립적으로 처리될 수 있는 부분을 분리하여 구조화한 객체를 의미합니다. 즉, 외부에 의존하는 부분 없이 툭 떼어 분리할 수 있는 실행 단위를 일종의 캡슐처럼 포장해놓은 것이죠. 이렇게 독립적으로 작성된 함수는 간단한 방식으로 여러 번 호출하여 사용할 수 있어서 같은 코드를 반복해서 작성할 필요가 없습니다.</p>
<p><br></p>
<p>스위프트는 함수형 프로그래밍 패러다임을 채택하고 있는 언어이므로 함수형 프로그래밍의 특성을 이해하는 것은 매우 중요합니다. 함수의 인자값은 하나도 없을 수도 있고, 하나 이상일 수도 있습니다. 특별한 경우에는 인자값의 개수가 제한되지 않는 형태를 가지기도 합니다. 함수의 반환값 역시 내부의 실행 과정 후 특정 결과값을 반환하는 형태와 실행 후 아무것도 반환하지 않는 형태 두 가지로 나눌 수 있습니다. 이 중에서 특정 결과값을 반환하는 함수는 일반적으로 하나의 값만을 반환합니다. 만약 둘 이상의 값을 반환해야 할 필요가 있다면 반환할 값들을 집단 자료형 하나에 담아 반환합니다. 즉, 실질적으로 반환하는 값이 여러 개더라도, 반환하는 객체 자체는 하나라는 거죠.</p>
<p><br></p>
<p>기본적으로 함수는 의존성 없이 독립 실행되는 코드를 뗴어 놓은 것이지만, 크게 보면 전체 프로세스의 일부분으로 동작하므로 함수 대신 함수 내부의 실행 코드만 가져다 전체 코드에 포함해서 사용해도 됩니다. 다시 말해 프로그래밍에서 함수를 반드시 사용해야 하는 것은 아니라는 겁니다. 그런데도 함수를 만들어서 사용하는 것은 다음과 같은 이점들 때문입니다.</p>
<p><br></p>
<ul>
<li>동일한 코드가 여러 곳에서 사용될 때 이를 함수화하면 재작성할 필요 없이 함수 호출만으로 처리할 수 있습니다.</li>
<li>전체 프로세스를 하나의 소스 코드에서 연속적으로 작성하는 것보다 기능 단위로 함수화하면 가독성이 좋아지고, 코드와 로직을 이해하기 쉽습니다.</li>
<li>비즈니스 로직을 변경해야 할 때 함수 내부만 수정하면 되므로 유지보수가 용이합니다.</li>
</ul>
<p><br></p>
<p>함수의 기본은 인자값을 입력받아 내부적으로 처리하고, 그 결과를 외부로 다시 반환하는 과정에 있습니다. 함수는 값을 반환하고 나면 실행이 종료되므로 사실상 return 구문이 함수의 종료 구문이라고 생각해도 됩니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(name: String?)</span></span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> _name = name <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(_name)님, 안녕하세요"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>return은 함수의 실행을 명시적으로 종료할 목적으로 사용됩니다. 위 함수는 매개변수의 값을 사용하여 메시지를 출력하는데, 이 과정에서 옵셔널 바인딩이 실패했을 경우 return 구문을 호출하여 실행을 종료합니다.</p>
<p><br></p>
<p>인자 레이블은 함수의 호출 시 인자값을 구분하기 위해 사용되는 레이블입니다. 스위프트에서 인자값이 있는 함수를 호출할 때에는 인자값 앞에 반드시 인자 레이블을 붙여서 호출해 주어야 합니다. 만약 인자 레이블 없이 인자값을 호출하면 컴파일 오류가 발생합니다. 일반적으로 스위프트에서 인자 레이블은 매개변수명과 동일합니다.</p>
<p><br></p>
<p>최초에 발표된 스위프트가 언어 자체의 특성에 초점을 맞추었다면 그다음의 스위프트는 코코아 터치 프레임워크를 사용하기 위한 역할로서의 언어에 초점을 맞추었습니다. 이에 따라 코코아 터치 프레임워크에 적용하기 좋은 형태로 문법이 변화된 겁니다. 정리하자면 함수의 식별자에 포함되는 것은 인자 레이블일 뿐, 결코 매개변수가 아님을 확실하게 인지해야 합니다. </p>
<p><br><br></p>
<h4 id="함수의-반환값과-튜플"><a href="#함수의-반환값과-튜플" class="headerlink" title="함수의 반환값과 튜플"></a>함수의 반환값과 튜플</h4><p>함수는 반드시 하나의 값만을 반환해야 합니다. 여러 개의 값을 반환해야 한다면, 이 값들을 담을 수 있는 집단 자료형이 필요하죠. 이때 사용할 수 있는 집단 자료형에는 딕셔너리나 배열, 튜플, 또는 구조체나 클래스가 있습니다. 앞에서 이미 배운 딕셔너리나 배열, 튜플은 물론이거니와 나중에 배우게 될 구조체와 클래스 역시 내부에 여러 개의 변수를 담을 수 있는 객체이므로 함수의 반환값으로 사용할 수 있습니다. 이 중, 활용도가 꽤 높으면서도 반환 타입의 표시 방법이 다른 자료형과 차이가 있는 튜플을 사용하는 예를 살펴보겠습니다.</p>
<p><br></p>
<p>튜플에는 여러 종류의 자료형이 다양하게 섞여 정의될 수 있으므로 이를 빠짐없이 표시해야 하죠. 튜플을 반환하는 변수를 받아 사용하는 방법을 다시 한번 확인해 보겠습니다. 튜플을 반환하는 함수의 반환값을 대입 받은 변수나 상수는 튜플의 인덱스를 이용하여 튜플 내부의 요소를 사용할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUserInfo</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Character</span>, <span class="type">String</span>)&#123;</span><br><span class="line">    <span class="comment">// 데이터 타입이 String으로 추론되는 것을 방지하기 위해 타입 어노테이션 선언</span></span><br><span class="line">    <span class="keyword">let</span> gender: <span class="type">Character</span> = <span class="string">"M"</span></span><br><span class="line">    <span class="keyword">let</span> height = <span class="number">180</span></span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"꼼꼼한 재은씨"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (height, gender, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uInfo = getUserInfo()</span><br><span class="line">uInfo.<span class="number">0</span></span><br><span class="line">uInfo.<span class="number">1</span></span><br><span class="line">uInfo.<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>인덱스를 사용하는 대신 가독성과 편리성을 위해 튜플 요소 각각을 변수로 직접 받을 수도 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (a, b, <span class="built_in">c</span>) = getUserInfo()</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="built_in">c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (height, <span class="number">_</span>, name) = getUserInfo()</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUserInfo</span><span class="params">()</span></span> -&gt; (h: <span class="type">Int</span>, g: <span class="type">Character</span>, n: <span class="type">String</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> gender: <span class="type">Character</span> = <span class="string">"M"</span></span><br><span class="line">    <span class="keyword">let</span> height = <span class="number">100</span></span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"꼼꼼한 재은씨"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (height, gender, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = getUserInfo()</span><br><span class="line">result.h</span><br><span class="line">result.g</span><br><span class="line">result.n</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>실행 결과로 반환되는 튜플의 각 아이템을 함수 정의 구문을 통해 변수에 미리 할당해 둘 수도 있습니다. 반환값 타입을 설정할 때 튜플 항목 하나하나에 미리 변수를 정의해 놓는 겁니다. 이렇게 정의해 두면 함수를 실행할 때 결과값을 바인딩하지 않아도 특정 변수명으로 바인딩된 튜플 인지라르 사용할 수 있습니다.</p>
<p><br></p>
<p>함수가 여러 개의 값을 반환할 때 이를 간단하게 묶기 위해 사용하는 것이 튜플이지만, 특정 튜플 타입이 여러 곳에서 사용될 경우에는 타입 알리어스를 통해 새로운 축약형 타입을 정의하는 것이 좋습니다. 타입 알리어스는 이름이 길거나 사용하기 복잡한 타입 표현을 새로운 타입명으로 정의해주는 문법으로, typealias 키워드를 사용하여 정의합니다. 타입 알리어스를 사용하면 길고 복잡한 형태의 타입 표현도 짧게 줄일 수 있어 전체적으로 소스 코드가 간결해지는 효과를 가져올 수 있습니다.</p>
<p><br></p>
<p>사용 방법도 간단합니다. 타입 알리어스를 정의하고 나면 컴파일러는 새로운 타입 이름을 타입 표현과 동일하게 간주합니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> infoResult = (<span class="type">Int</span>, <span class="type">Character</span>, <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUserInfo</span><span class="params">()</span></span> -&gt; infoResult&#123;</span><br><span class="line">    <span class="keyword">let</span> gender: <span class="type">Character</span> = <span class="string">"M"</span></span><br><span class="line">    <span class="keyword">let</span> height = <span class="number">100</span></span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"꼼꼼한 재은씨"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (height, gender, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info = getUserInfo()</span><br><span class="line">info.<span class="number">0</span></span><br><span class="line">info.<span class="number">1</span></span><br><span class="line">info.<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>함수에 튜플을 활용하는 예를 몇 가지 케이스별로 살펴보았습니다. 튜플이라는 타입의 단조로움과는 달리 튜플을 활용하는 방법이 상당히 많은 것을 잘 알았을 겁니다. 이처럼 함수에 튜플을 활용하면 코드를 쉽게 처리할 수 있어 활용도가 무척 높습니다. </p>
<p><br><br></p>
<h4 id="매개변수"><a href="#매개변수" class="headerlink" title="매개변수"></a>매개변수</h4><p>스위프트에서는 함수를 정의할 때 매개변수를 용도에 따라 두 가지로 분리할 수 있습니다. 내부 매개변수와 외부 매개변수가 그것이죠. 외부 매개변수는 함수를 호출할 때 인자값에 대한 레이블 역할을 하며, 동시에 함수의 식별자 일부로 사용되기도 합니다. 반면 내부 매개변수는 입력된 인자값을 함수 내부에서 참조하기 위해 사용하는 변수입니다. 함수의 범위 내에서는 내부 매개변수를 일반 변수처럼 사용하여 인자값을 얼마든지 참조할 수 있죠. 사실 정확하게 말하자면 변수가 아니라 상수입니다.</p>
<p><br></p>
<p>외부 매개변수를 사용하지 않은 일반 함수입니다. 이 함수에는 name과 msg라는 두 개의 매개변수가 정의되어 있죠. 매개변수가 나누어져 있지 않을 때에는 그냥 매개변수명을 인자 레이블로 사용하면 되므로 호출 구문에는 name, msg를 인자 레이블로 붙여주어야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(name: String, msg: String)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name)님, \(msg)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printHello(name: <span class="string">"홍길동"</span>, msg: <span class="string">"안녕하세요"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이제 변화를 주어, 외부 매개변수를 지정해 보겠습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(to name: String, welcomeMessage msg: String)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name)님, \(msg)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printHello(to: <span class="string">"홍길동"</span>, welcomeMessage: <span class="string">"안녕하세요"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이 함수는 여전히 name과 msg라는 두 개의 매개변수를 사용합니다. 하지만 외부 매개변수인 to, welcomeMessage가 추가되면서 name과 msg는 내부 매개변수가 되었습니다. 외부 매개변수가 정의되어 있지 않을 때에는 함수를 호출할 때 이 매개변수를 사용ㅎ야 하지만, 지금은 각각의 매개변수 앞에 외부 매개변수가 추가된 상태이므로 이를 사용하여 호출해야 합니다. 물론 이 to와 welcomeMessage라는 매개변수명은 어디까지나 외부에서 호출할 때 사용하는 이름에 지나지 않습니다. 함수 내부에서 인자값을 받아 사용할 때는 내부 매개변수명이 그대로 사용됩니다.</p>
<p><br></p>
<p>외부 매개변수를 따로 지정할 경우에는 함수의 이름 변화에도 주의해야 합니다. 기존 매개변수명이 아닌, 따로 지정된 외부 매개변수명이 함수 이름에 사용되기 때문이죠. 외부 매개변수의 사용을 달가워하지 않는 사람들을 위해 함수의 호출 시 매개변수를 생략할 수 있는 옵션도 있습니다. 함수 정의 구문에서 외부 매개변수 자리에 언더바를 넣어주면 함수를 호출할 때 매개변수를 사용하지 않아도 됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(<span class="number">_</span> name: String, <span class="number">_</span> msg: String)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name)님, \(msg)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>함수의 외부 매개변수명이 들어갈 자리에 대신 언더바를 사용했습니다. 스위프트에서 언더바는 대부분 문법은 적용하되 사용하지 않는다, 생략하겠다라는 의미로 많이 사용됩니다. 튜플의 각 아이템을 받는 개별 변수를 선언할 때도 굳이 받고싶지 않은 아이템의 경웅 언더바로 변수를 대체했던 기억이 날 겁니다. 그와 유사합니다. 외부 매개변수명 자리에 언더바를 사용하면 내부 매개변수와 외부 매개변수를 분리하지만 외부 매개변수명을 사용하지는 않겠다라는 뜻이 되어 매개변수를 생략하고 호출할 수 있습니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printHello(<span class="string">"홍길동"</span>, <span class="string">"안녕하세요"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>인자값 앞에 붙던 매개변수명이 사라지고 다른 언어에서처럼 단순히 인자값만을 이용해서 호출할 수 있게 되었습니다. 이제는 함수 호출 시 매개변수명을 붙이려고 하면 오히려 오류가 발생합니다. 매개변수가 여러 개일 때는 일부만 매개변수를 생략할 수도 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(<span class="number">_</span> name: String, welcomeMessage msg: String)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name)님, \(msg)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printHello(<span class="string">"홍길동"</span>, welcomeMessage: <span class="string">"안녕하세요"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>맨 앞의 매개변수를 생략한 이 구조는 코코아 터치 프레임워크에서 굉장히 많이 사용되는 방식입니다. 매개변수가 생략될 경우, 함수의 이름에도 변화가 생깁니다. 외부 매개변수가 사용될 자리에 대신 언더바가 들어갔으므로, 함수명 역시 외부 매개변수 자리에 언더바를 넣어 표시해 주어야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printHello(<span class="number">_</span>:<span class="number">_</span>:)</span><br><span class="line">printHello(to:<span class="number">_</span>:)</span><br><span class="line">printHello(<span class="number">_</span>:welcomeMessgae:)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>스위프트 언어의 특징이라 할 수 있는 외부 매개변수명은 매개변수명이 내부와 외부에서 바라보는 의미가 달라 외부와 내부로 구분하여 사용할 필요가 있을 때, 혹은 내부 매개변수명을 외부로 공개하기를 원치 않을 때 사용됩니다. 또 내부 매개변수명이 너무 길어서 호출 과정이 불편해질때도 사용됩니다. 하지만 가장 큰 목적은 뭐니뭐니해도 오브젝티브-C와의 호환성 때문이라고 할 수 있습니다.</p>
<p><br></p>
<h4 id="가변-인자"><a href="#가변-인자" class="headerlink" title="가변 인자"></a>가변 인자</h4><p>일반적으로 함수는 미리 정의된 형식과 개수에 맞는 인자값만 처리하지만, 때에 따라서는 가변적인 개수의 인자값을 입력받아야 할 때도 있습니다. 스위프트에서는 매개변수명 다음에 … 연산자를 추가하여 개수를 제한하지 않고 인자값을 입력받으며, 입력된 인자값을 배열로 저장합니다. 함수의 실행 블록 내에서 for~in 구문을 사용하면 입력된 모든 인자값을 순서대로 읽어 들일 수 있죠. 다음 예제를 보면서 개수의 제한 없이 점수를 입력받아 평균값을 산출하는 함수를 구현해봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">avg</span><span class="params">(score: Int...)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> score&#123;</span><br><span class="line">        total += r</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">Double</span>(total) / <span class="type">Double</span>(score.<span class="built_in">count</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(avg(score: <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>))  <span class="comment">// 25.0</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>매개변수 score는 가변 인자로 설정된 Int 타입입니다. 여기에 저장된 값은 배열로 처리됩니다. 따라서 for~in 구문에 넣고 순회 탐색을 처리하면 입력된 전체 인자값을 읽어 들일 수 있죠. 이 값들을 순회하면서 점수 합계에 더하고, 최종적으로 더한 값을 score 배열의 크기로 나누어 평균을 구합니다. 이때 total 변수와 배열의 크기는 모두 정수이므로 형변환 없이 그대로 계산하면 정수값으로 계산됩니다. 이를 방지하기 위해 Double 타입의 실수로 형변환을 해준 다음 평균을 구하는 연산을 수행하는 것이 위 예제의 내용입니다. 이처럼 가변 인자값은 입력 개수를 특정할 수 없는 형태의 매개변수에 사용됩니다.</p>
<p><br><br></p>
<h4 id="기본값을-갖는-매개변수"><a href="#기본값을-갖는-매개변수" class="headerlink" title="기본값을 갖는 매개변수"></a>기본값을 갖는 매개변수</h4><p>함수의 매개변수에는 유용한 기능이 있는데, 바로 기본값을 지정할 수 있다는 것입니다. 스위프트는 함수 호출할 때 반드시 직접 입력받아야 하는 값이 아니라면 인자값을 생략할 수 있도록, 함수 정의 시 매개변수에 기본 값을 지정할 수 있는 문법을 제공합니다. 이렇게 작성된 매개변수는 호출 시 인자값을 생략할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기본값이 지정된 함수</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(message: String, newline: Bool = <span class="literal">true</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> newline == <span class="literal">true</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(message, <span class="literal">true</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(message, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>작성된 echo 함수는 첫 번째 인자값으로 출력할 메시지를 입력받고, 두 번째 인자값으로 줄 바꿈 처리 여부를 결정합니다. 그런데 대부분 특별한 경우가 아니라면 기본적인 내용이 출력되고 난 다음 줄 바꿈 처리가 되기를 기대합니다. 이 때문에 줄 바꿈 여부에 대한 두 번째 인자값은 매번 똑같은 값을 넣어주어야 하는, 거추장스러운 인자값입니다. 이런 경우 두 번째 인자값에 기본값을 할당해주면 일반적인 출력 구문을 원할 때 단순히 출력할 메시지만 입력해주면 되고, 굳이 줄 바꿈을 하지 않고자 할 경우에만 두 번째 인자값에 false를 할당해주면 됩니다. 두 번째 인자값을 생략하여 호출하면 기본값 true가 두 번째 매개변수에 할당됩니다. 만약 두 번째 인자값에 명시적으로 false를 할당해주었다면 줄 바꿈 처리가 되지 않을 겁니다.</p>
<p><br><br></p>
<h4 id="매개변수의-수정"><a href="#매개변수의-수정" class="headerlink" title="매개변수의 수정"></a>매개변수의 수정</h4><p>고백할 것이 있습니다. 지금까지 함수를 설명하면서 매개변수라는 단어를 여러 번 사용했는데요. 이 단어에는 약간의 문제가 있습니다. 변수는 원래 마음대로 값을 수정할 수 있어야 하지만, 매개변수에 입력된 인자값을 함수 내에서 수정하려고 하면 오류가 발생하거든요. 이것은 스위프트에서 함수의 인자값이 변수가 아니라 상수로 정의되었기 때문으로, 정확한 표현은 매개상수라고 해야 맞습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 입력받은 값을 +1 하여 리턴해주는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementBy</span><span class="params">(base: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    base += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Left side of mutating operator isn't mutable: 'base' is a 'let' constant</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">이 함수는 입력받은 인자값을 base라는 정수 타입의 매개변수에 할당하고, 이 값을 += <span class="number">1</span> 연산 처리하여 반환합니다. += <span class="number">1</span> 연산은 앞에서 배운 바와 같이 그 자신의 값에 <span class="number">1</span>을 더한 다음 그 자신에게 다시 할당하는 연산입니다. 여기서 보여주고자 하는 것은 입력된 인자값에 대한 변경이 일어난다는 점입니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">오류 메시지를 해석해보면 <span class="string">"base는 '상수'로 정의되었으므로 왼쪽 수정 연산자가 값을 변경할 수 없다."</span>는 뜻입니다. 이처럼 함수의 인자값은 함수 내부에서 변수가 아니라 상수임에 주의해야 합니다. 인자값에 값을 새로 할당하거나 수정하는 구문을 작성해서는 안 된다는 거죠. 이는 변수를 함수의 인자값으로 대입해 준 경우도 마찬가지입니다. 인자값으로 전달된 값이 변수더라도 실제로는 값의 복사를 통해 상수가 새로 정의된 다음 전달됩니다. 변수 자체가 전달되는 것이 아니라 값만 전달된다는 겁니다. 그것도 원본이 아니라 복사된 값으로 말입니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">결론적으로 함수에 입력된 인자값은 함수 내부에서 항상 상수로 정의됩니다. 인자값을 변경할 수는 없습니다. 이런 사실들을 종합해보면 상수로서의 특징을 정확히 표현하기 위해 스위프트에서는 '매개상수'라는 단어를 사용해야 합니다. 스위프트에서 매개변수라고 일컫는 것은 특별한 언급이 없는 한 상수로 받아들이면 됩니다. 그런데 뜬금없이 지금 시점에서 이런 고백을 왜 했을까요? 그것은 상수로 정의되는 함수의 인자값이라 할지라도 내부에서 인자값을 수정하는 방법이 있다는 것을 설명하기 위해서입니다. 방법은 단순합니다. 기본적으로 매개변수와 동일한 이름으로 변수를 정의하고 매개변수의 값을 대입해 주면 됩니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementBy</span><span class="params">(base: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base = base</span><br><span class="line">    base += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>앞에서 오류가 발생했던 함수에서 매개변수의 이름과 동일한 변수 base를 정의하고, 여기에 매개변수를 대입하는 구문이죠. 이렇게 동일한 이름의 변수를 작성해서 값을 대입하고 나면, 이후로 base라는 이름의 호출은 모두 매개변수 base가 아니라 변수 base를 가리키게 됩니다. 여기에는 값을 수정하는 기존 구문을 그대로 사용해도 아무런 문제가 없습니다. 그저 변수의 값을 변경하는 것일 뿐이니까요.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">descAge</span><span class="params">(name: String, <span class="number">_</span> paramAge: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = name</span><br><span class="line">    <span class="keyword">var</span> paramAge = paramAge</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 입력된 값을 변경합니다.</span></span><br><span class="line">    name = name + <span class="string">"씨"</span></span><br><span class="line">    paramAge += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(name)의 내년 나이는 \(paramAge)세입니다."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>앞의 예제와 비슷하지만 이번에는 매개변수가 두 개입니다. 이 경우에도 크게 다른 점은 없습니다. 각각의 매개변수에 대해 변수화하는 구문을 추가해주면 되기 때문입니다. </p>
<p><br><br></p>
<h4 id="InOut-매개변수"><a href="#InOut-매개변수" class="headerlink" title="InOut 매개변수"></a>InOut 매개변수</h4><p>스위프트에서는 함수 내부에서 발생하는 사건은 함수 외부에 영향을 미칠 수 없습니다. 함수 내부에도, 외부에도 동일한 인자값이 존재하고 있지만 함수 내부에서 변경된 인자값은 4차원 공간 바깥에 있는 주인공의 과거 존재처럼 함수 외부의 인자값에는 아무런 영향도 끼칠 수 없습니다. 단순히 같은 값을 가지고 있을뿐, 둘은 단절된 서로 다른 객체이기 때문입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cnt = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">autoIncrement</span><span class="params">(value: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = value</span><br><span class="line">    value += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(autoIncrement(value: cnt))  <span class="comment">// 함수 내부의 value 변수값: 31</span></span><br><span class="line"><span class="built_in">print</span>(cnt) <span class="comment">// 외부에서 정의된 cnt 변수값: 30</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>외부에서 입력한 인자값이 직접 함수 내부로 전달되는 것이 아니라 그 값이 복사된 다음 전달됩니다. 다시 말해, 인자값으로 전달된 cnt와 매개변수 value는 서로 다른 변수입니다. 하지만 함수에서도 내부에서 수정된 인자값이 외부까지 영향을 미칠 수 있는 방법이 존재합니다. 물론 반환값을 이용하지 않고 말입니다. 이를 위해 사용되는 키워드가 inout입니다. 이 키워드를 이용하면 스위프트에서는 함수 내부에서 수정된 인자값을 함수 외부까지 전달할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(paramCount: <span class="keyword">inout</span> Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    paramCount += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> paramCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>inout 키워드가 붙은 매개변수는 인자값이 전달될 때 새로운 내부 상수를 만들어 복사하는 대신 인자값 자체를 함수 내부로 전달합니다. 함수 내부에서 사용하는 매개변수명이 외부의 변수명과 다를지라도 마찬가지입니다. inout 키워드가 붙은 매개변수는 인자값으로 사용된 변수와 동일한 객체입니다. 단순히 값만 똑같은 짝퉁 변수와는 다르죠.</p>
<p><br></p>
<p>사실 inout 키워드의 정확한 의미는 값 자체를 전달하는 것이 아니라 값이 저장된 메모리 주소를 전달한다는 의미입니다. 인자값에 할당된 데이터가 저장되어 있는 메모리 주소를 함수에 전달하는 것이죠. C를 해본 분들이라면 ‘어? 포인터인데.’라고 생각하실지도 모르겠네요. 맞습니다. C에서의 포인터와 유사합니다. 이 때문에 inout 키워드가 사용된 함수는 호출 시 주의가 필요합니다. 인자값을 전달할 때 값이 아닌 주소를 전달해야 하거든요. 따라서 inout 매개변수에 들어갈 인자값에는 주소 추출 연산자 &amp;을 붙여주어야 정상적으로 전달할 수 있습니다. 이 연산자는 변수나 상수 앞에 붙어서 값이 저장된 메모리 주소를 읽어오는 역할을 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(foo(paramCount: &amp;<span class="built_in">count</span>))  <span class="comment">// 함수 내부의 paramCount 변수값: 31</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">count</span>)  <span class="comment">// 외부에서 정의된 count 변수값: 31</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>함수를 호출하는 구문입니다. 변수 count가 인자값으로 사용된 부분에 주소 추출 연산자인 &amp; 연산자가 붙어 있죠. 함수를 호출할 때 인자값으로 사용된 변수 앞에 &amp;를 붙이면 값이 아닌 주소가 전달되며, 이 주소를 읽어 들이기 위해 함수에서는 매개변수에 inout 키워드가 추가된다고 보면 됩니다. 함수는 전달받은 메모리 주소를 통해 외부의 변수에 직접 접근할 수 있고, 값을 변경하면 그 결과가 외부 변수에도 바로 반영됩니다. 이처럼 주소를 전달하는 것을 프로그래밍 용어로 참조에 의한 전달이라고 하며, 기존처럼 값을 복사하여 전달하는 것을 값에 의한 전달이라고 합니다.</p>
<p><br></p>
<h4 id="값에-의한-전달과-참조에-의한-전달"><a href="#값에-의한-전달과-참조에-의한-전달" class="headerlink" title="값에 의한 전달과 참조에 의한 전달"></a>값에 의한 전달과 참조에 의한 전달</h4><p>값에 의한 전달은 인자값을 전달하면 내부적으로 값의 복사가 이루어져서 복사된 값을 이용하여 구문을 실행하는 것을 이야기합니다. 지금까지 우리가 대부분 사용해왔던 방식이죠. 이 방식은 내부적으로 복사를 통해 생성된 새로운 변수나 상수를 이용하여 함수의 기능을 실행하므로 인자값의 수정이 발생하더라도 원본 데이터에는 영향을 미치지 않습니다.</p>
<p><br></p>
<p>우리가 많이 사용하는 String, Int, Double, Float, Bool 등 기본 자료형들 대부분이 이처럼 값에 의한 전달 방식으로 인자값을 전달합니다. 원본 값은 그대로 둔 채 복사된 새로운 값이 전달되는 것이죠. 따라서 우리는 인자값을 내부에서 수정하더라도 외부 값의 변경을 고려할 필요가 없습니다. 값이 전달되는 순간 내부 인자값과 외부 인자값은 서로 상관없는 남남이 되기 때문입니다.</p>
<p><br></p>
<p>반면 참조에 의한 전달은 내부적으로 복사가 이루어지는 대신 값이 저장된 주소가 전달됩니다. 인자값을 저장하고 있는 객체 자체가 전달된다고 할 수 있죠. 이 방식은 외부의 인자값을 직접 참조하므로 함수 내부에서 인자값이 수정되면 그 결과가 외부 인자값 원본에도 고스란히 반영됩니다.</p>
<p><br></p>
<p>이처럼 주소를 직접 전달하는 참조에 의한 전달은 함수에서 inout 키워드를 사용했을 때 적용되지만, 예외적으로 클래스로 구현된 인스턴스는 inout 키워드를 사용하지 않아도 항상 참조에 의해 전달됩니다. 따라서 함수의 인자값으로 전달한 클래스 인스턴스는 함수 내부에서 값이 수정되면 원본 객체에도 영향을 미치므로 주의해야 합니다. </p>
<p><br></p>
<p>inout 키워드가 붙은 매개변수에 인자값을 입력할 때는 인자값 객체의 종류에 주의해야 합니다. 함수 내부에서 원본 객체에 직접 값을 수정할 수 있어야 하므로 상수는 전달 대상이 될 수 없습니다. 같은 이유에서 리터럴 역시 전달 대상이 될 수 없습니다. 오직 변수만 인자값으로 사용할 수 있습니다.</p>
<p><br></p>
<p>매개변수와 관련된 것은 아니지만, 참조에 의한 전달 방식이 적용되는 경우가 한 가지 더 있습니다. 변수의 범위 특성을 이용하는 것으로, 일반적으로 상위 범위에 정의된 변수는 하위 범위에서도 사용할 수 있다는 특성을 가집니다. 이 점을 이용하여 함수 외부에서 정의된 변수를 함수 내부에서 가져다 사용하면 inout 키워드를 사용하지 않고도 외부의 변수를 내부에서 바로 참조할 수 있을 뿐만 아니라 함수 내부에서 값을 변경하면 함수 외부에도 그대로 반영됩니다.</p>
<p><br><br></p>
<h4 id="변수의-생존-범위와-생명-주기"><a href="#변수의-생존-범위와-생명-주기" class="headerlink" title="변수의 생존 범위와 생명 주기"></a>변수의 생존 범위와 생명 주기</h4><p>범위를 기준으로 변수를 구분해 보면 크게 전역 변수와 지역 변수로 나눌 수 있습니다. 전역 변수는 프로그램의 최상위 레벨에서 작성된 변수를 의미합니다. 이 변수는 일반적으로 프로그램 내 모든 위치에서 참조할 수 있으며, 특별한 경우를 제외하면 프로그램이 종료되기 전까지는 삭제되지 않습니다.</p>
<p><br></p>
<p>반면 로컬 변수라고도 하는 지역 변수는 특정 범위 내에서만 참조하거나 사용할 수 있는 변수를 의미합니다. 조건절이나 함수 구문 등 특정 실행 블록 내부에서 선언된 변수는 모두 지역변수이며 선언된 블록 범위 안에서만 이 변수를 참조할 수 있습니다. 지역 변수는 선언된 블록이 실행되면서 생겨났다가 실행 블록이 끝나면 제거됩니다. 이를 변수의 생명 주기라고 합니다.</p>
<p><br></p>
<p>do 블록은 일반적으로 오류 처리를 위해 do~catch 구문 형식으로 사용되지만, 단독으로 사용되었을 때에는 단순히 실행 블록을 구분하는 역할을 합니다. do 블록은 중첩해서 사용할 수 있는데, 이때 내부에 중첩된 do 블록을 기준으로 실행 블록은 단계화됩니다. 내부에 더 많이 중첩되어 있을수록 더 하위 블록입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ccnt = <span class="number">3</span></span><br><span class="line">        ccnt += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(ccnt)</span><br><span class="line">    &#125;</span><br><span class="line">    ccnt += <span class="number">1</span>  <span class="comment">// Use of unresolved identifier 'ccnt'</span></span><br><span class="line">    <span class="built_in">print</span>(ccnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>선언된 블록보다 하위 블록에서 변수를 사용하는 과정을 단순히 하나의 코드 내에서 변수를 사용하는 것으로 여길 수도 있겠으나, 자세히 들여다보면 하나의 블록에서 다른 블록으로 참조에 의한 전달 과정이 일어나는 것입니다. 이를 위해 변수의 주소값이 필요하죠. 만약 변수가 초기화되지 않았다면 메모리를 할당받지 못한 상태이므로 주소값도 존재하지 않습니다. 따라서 오류가 발생합니다. </p>
<p><br></p>
<p>함수는 실행 블록을 가지고 있는 객체입니다. 때문에 앞서 설명한 범위가 그대로 적용됩니다. 함수 내에서 선언된 변수는 함수의 실행 블록 안에서만 존재하므로 이 변수에 직접 접근할 수 있는 조건 또한 함수의 실행 블록 내로 제한됩니다. 함수의 실행 블록 내부에 하위 블록이 존재하면 이 하위 블록 역시 함수의 실행 블록 내에 있으므로 변수에 접근할 수 있지만, 함수를 벗어난 블록에서는 변수에 접근할 수 없습니다.</p>
<p><br></p>
<p>전역 변수는 이와 반대입니다. 전역 변수는 최상위 블록에서 선언된 변수이므로 그보다 하위 블록인 함수 내부에서도 얼마든지 접근할 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()  <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>인자값을 받지 않는 foo() 함수가 정의되었습니다. 이 함수는 내부에서 count 변수를 1만큼 증가하는 처리를 하고 있죠. count 변수는 상위 블록인 전역 범위에서 선언된 변수입니다. 상위 블록에서 정의된 변수가 하위 블록에서 사용될 때는 값이 참조 방식으로 전달되기 때문에 블록 내부에서 값을 변경하면 외부에도 그대로 적용됩니다. 따라서 함수 내에서는 전역 변수의 값에 접근할 수도 있고, 수정할 수도 있습니다. 이번에는 전역 변수와 지역 변수가 겹칠 때는 어떤 현상이 발생하는지 알아봅시다. 다음은 조금 전의 foo 함수 내부에 전역 변수와 이름 및 타입이 동일한 매개변수를 정의한 예제입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="built_in">count</span></span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="built_in">count</span>: <span class="built_in">count</span>))  <span class="comment">// 함수 내부의 count 변수값 : 31</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">count</span>)  <span class="comment">// 외부에서 정의된 count 변수값 : 30</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>함수 외부에서 count 변수는 전역 범위로 선언되어 있습니다. 그리고 함수 내부에서도 count가 매개변수로, 그리고 지역 변수로도 선언되어 있습니다. foo 함수는 내부적으로 인자값을 1 증가시킨 다음 반환하는 역할을 하죠. 이 함수의 출력 결과는 예상할 수 있는 것처럼 31입니다. 30이라는 값이 입력되어 1만큼 증가한 다음 반환되었으므로 당여한 결과입니다. 그런데 전역 변수 count를 출력해보면 값이 일치하지 않습니다. 값이 바뀌지 않은 그대로이죠.</p>
<p><br></p>
<p>이것으로 보아 스위프트에서 함수의 외부와 내부에 각각 같은 이름의 변수가 존재하면 내부에서 선언된 변수는 외부와 상관없이 새롭게 생성된다는 것을 알 수 있습니다. 그렇지 않다면 외부 변수의 값도 함께 변경되었을 테니까요. 실제로 함수의 외부 영역과 내부 영역에 같은 이름의 변수가 정의되어 존재한다면 두 변수는 동일한 변수가 아닙니다. 위의 예에서 내부 영역에 정의된 count 변수는 지역 변수로서, 외부에서 정의된 count 변수와는 엄연히 다른 객체입니다. 또한, 외부와 내부에서 같은 이름의 변수가 선언되면 변수 사용의 우선순위에 따라 외부 변수가 아닌 내부 변수를 사용하게 됩니다. 이는 블록 내에서 적용되는 변수 우선순위 규칙과 관련됩니다. 함수처럼 블록 내부에서 변수나 상수가 사용될 경우 컴파일러는 이 변수가 정의된 위치를 다음의 순서에 따라 검색합니다.</p>
<p><br></p>
<p>가장 먼저 함수 내부에서 이 변수가 정의되어 있는지 검색하여 정의되어 있다면 이 변수의 값을 읽어오고, 없으면 상위 범위인 함수 외부로 이동합니다. 함수 외부 범위에서 이 변수가 정의되어 있는지 검색하고 있다면 이 변수를 사용하지만 여기에도 없다면 그보다 상위 블록으로 검색 범위를 확장합니다. 이번에도 변수가 발견되지 않으면 글로벌 범위까지 확장하여 변수를 검색합니다. 이처럼 검색 범위를 넓혀 최상위 범위까지 검색했음에도 정의된 변수를 찾을 수 없을 경우 컴파일러는 최종적으로 존재하지 않는 변수라는 오류를 발생시킵니다.</p>
<p><br><br></p>
<h4 id="일급-객체로서의-함수"><a href="#일급-객체로서의-함수" class="headerlink" title="일급 객체로서의 함수"></a>일급 객체로서의 함수</h4><p>스위프트는 객체지향 언어이자 동시에 함수형 언어입니다. 함수형 언어를 학습하게 되면 반드시 일급 객체라는 용어를 접하게 되는데요. 이는 프로그램 언어 안에서 특정 종류의 객체가 일급의 지위를 가지는가에 대한 의미입니다.</p>
<p><br></p>
<p>객체가 다음의 조건을 만족하는 경우 이 객체를 일급 객체로 간주합니다.</p>
<p><br></p>
<ul>
<li>객체가 런타임에도 생성이 가능해야 한다.</li>
<li>인자값으로 객체를 전달할 수 있어야 한다.</li>
<li>반환값으로 객체를 사용할 수 있어야 한다.</li>
<li>변수나 데이터 구조 안에 저장할 수 있어야 한다.</li>
<li>할당에 사용된 이름과 관계없이 고유한 구별이 가능해야 한다.</li>
</ul>
<p><br></p>
<p>함수가 이런 조건을 만족하면 이를 일급 함수라고 하고 그 언어를 함수형 언어로 분류합니다. 즉, 함수형 언어에서는 함수가 일급 객체로 대우받는다는 뜻입니다. 함수가 일급 객체로 대우받는다면 런타임에도 함수의 생성이 가능하고, 매개변수나 반환값으로 함수를 전달할 수 있으며, 함수를 변수나 데이터 구조 안에 저장할 수 있을 뿐만 아니라 함수의 이름과 관계없이 고유한 구별이 가능합니다. 이것들은 일급 객체가 되기 위한 조건이기 때문입니다. 일급 함수가 쉽게 와 닿지 않는다면, 자바에서 클래스의 특성을 떠올려보시기 바랍니다. 자바에서는 클래스가 일급의 지위를 가지니까요.</p>
<p><br></p>
<ul>
<li>변수나 상수에 함수를 대입할 수 있음</li>
</ul>
<p><br></p>
<p>일급 함수의 특성 중에서 처음으로 알아볼 특성은 변수나 상수에 함수를 대입할 수 있다는 점입니다. 변수나 상수에 함수를 대입한다는 것은 말 그대로 함수 자체를 변수에 집어넣는다는 뜻입니다. 이렇게 함수가 대입된 변수나 상수는 함수처럼 실행할 수도 있고, 인자값을 입력받을 수도 있습니다. 반환값을 가질 수도 있죠. </p>
<p><br></p>
<p>일급 함수에서 말하는 변수나 상수에 함수를 대입한다라는 의미는 이것과 다릅니다. 함수의 결과값을 대입하는 것이 아니라 함수 자체를 대입하는 것이니까요. 잠깐 언급했듯이 함수 자체를 변수에 할당하면 변수도 함수처럼 인자값을 받아 실행이 가능하고, 값을 반환할 수도 있습니다. 함수를 대입한 변수가 함수처럼 실행된다는 것은 우리가 학습한 함수 호출 형식이 확장됨을 의미합니다. 지금까지 우리는 함수를 호출할 때 함수의 이름 다음에 함수 호출 연산자를 붙여야 했습니다. 그러나 일급 함수의 특성에 따라 우리는 굳이 함수의 이름이 아니더라도 함수가 할당된 변수라면 그 변수에 함수 호출 연산자 ()를 붙여서 함수를 호출할 수 있습니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(base: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"결과값은 \(base + 1)입니다"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f1 = foo(base: <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(f1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn2 = foo  <span class="comment">// fn2 상수에 foo 함수가 할당됨</span></span><br><span class="line">fn2(<span class="number">5</span>)  <span class="comment">// "결과값은 6입니다"</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>상수 fn2에 foo 함수를 대입하고 있습니다. 함수 자체가 대입되었으므로 이제 fn2는 foo와 이름만 다를 뿐 같은 인자값, 같은 기능, 같은 반환값을 가지는 함수가 됩니다. 따라서 fn2에 함수 호출 연산자인 ()와 인자값 5를 넣어 호출할 수도 있고 그 결과값을 받을 수도 있습니다. fn2는 함수니까요.</p>
<p><br></p>
<p>변수나 상수에 함수를 대입할 때는 함수가 실행되는 것이 아니라 함수라는 객체 자체만 대입됩니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(base: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"함수 foo가 실행됩니다"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"결과값은 \(base + 1)입니다"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn3 = foo(base: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>앞서 작성했던 함수 foo에서 내부에 출력 구문을 추가하였습니다. 이 함수가 실행되면 “함수 foo가 실행됩니다”라는 구문이 출력되도록 말이죠. 이 함수의 결과값을 상수에 할당하였습니다. 함수의 결과값을 fn3에 대입하는 과정에서 함수가 실행되었습니다. 함수 내부에 작성해둔 출력 구문이 플레이그라운드의 콘솔에 찍히는 것을 보면 알 수 있죠. 이처럼 함수의 결과값을 대입할 때는 함수가 실행됩니다. 하지만 함수 자체를 대입하는 구문은 다릅니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn4 = foo</span><br><span class="line"><span class="comment">// 출력결과 없음</span></span><br><span class="line"></span><br><span class="line">fn4(<span class="number">7</span>)  <span class="comment">// 함수 foo가 실행됩니다</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>상수 fn4에 foo 함수를 대입하는 과정에서는 아무런 값도 출력되지 않습니다. foo 함수가 실행되지 않았다는 뜻이죠. 함수를 할당받은 상수 fn4가 인자값 7을 넣어 함수를 실행하면 그때서야 메시지가 출력됩니다. 이번에는 foo 함수가 실행되었다는 것을 알 수 있습니다.</p>
<p><br></p>
<p>이처럼 단순히 함수를 변수나 상수에 대입하는 과정에서는 함수가 실행되지 않습니다. 함수 객체 자체만 전달되기 때문입니다. 함수가 대입된 변수나 상수를 함수처럼 호출하면 그때 비로소 함수가 실행됩니다. 이것이 함수 결과값을 대입하는 것과 함수 자체를 대입하는 것의 차이점이라고 할 수 있습니다.</p>
<p><br></p>
<p>함수를 대입하기 위해 알아야 할 것이 하나 더 있습니다. 바로 타입(Types)입니다. 변수에 함수를 대입하면 그 변수는 일반적인 문자열, 정수, 배열 또는 딕셔너리와는 전혀 다른 타입이 됩니다. 이 타입을 함수 타입(Function Types)이라고 하죠. 함수 타입은 함수의 형태에 따라 셀수 없을 만큼 다양한 구조를 가집니다. 복잡하게 이해하면 어렵지만, 간단하게 생각하면 됩니다. 변수에 정수를 대입하면 Int 타입이, 문자열을 대입하면 String 타입이 되는 것처럼, 변수에 함수를 대입하면 함수 타입이 되는 겁니다.</p>
<p><br></p>
<p>함수 타입은 일반적으로 함수의 형태를 축약한 형태로 사용하는데, 이때 함수의 이름이나 실행 내용 등은 함수 타입에서는 아무런 의미가 없으므로 생략할 수 있습니다. 함수 타입에서 필요한 것은 단지 어떤 값을 입력받는지와 어떤 값을 반환하는지 뿐입니다. 실제 함수를 보면서 함수 타입에 대한 내용을 자세히 익혀 봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boo</span><span class="params">(age: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(age)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>정수 인수를 받고 문자열 타입을 반환하는 boo(age:) 함수입니다. 이 함수를 함수 타입 형태로 표현하면 다음과 같습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(int) -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>앞서 설명한 것처럼 함수명, 매개변수명, 그리고 실행 내용에 해당하는 부분은 모두 생략된 형태입니다. 남아 있는 것은 Int 타입의 인자를 입력받는 것과 그 결과로 String 타입을 반환한다는 것 두 가지죠. 만약 이 함수를 상수에 할당한다면 이 상수의 타입 어노테이션을 포함한 할당 구문은 다음과 같습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn: (<span class="type">Int</span>) -&gt; <span class="type">String</span> = boo</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이번에는 두 개의 인자값을 받는 함수의 타입을 작성해봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boo</span><span class="params">(age: Int, name: String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(name)의 나이는 \(age)세 입니다."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>age라는 정수 값과 name이라는 문자열 값을 인자값으로 받는 boo 함수가 다시 작성되었습니다. 이 함수를 상수 s에 할당해 봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = boo</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>그런데, 우리가 지금 대입 구문에 사용한 boo라는 이름은 우리가 알고 있는 정확한 함수 식별자가 아닙니다. 정확한 식별자는 boo(age:name:)죠. 그래서 위 구문은 다음과 같이 함수 식별자를 대입해주는 구문으로 바꾸어 작성할 수도 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = boo(age:name:)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>boo와 boo(age:name:) 두 가지 모두 함수를 대입하는 구문에 사용해도 아무런 문제가 없습니다. 물론 둘 중에서 정확한 표현을 선택하라면 boo(age:name:)을 선택해야겠지만요. 그러면 boo는 뭘까요? 함수의 이름도 아닌 것이 왜 함수의 대입 구문에 사용해도 아무런 문제가 없는 것일까요?</p>
<p><br></p>
<p>이를 설명하려면 함수의 이름과 함수의 식별자를 구분하는 이야기를 다시 꺼내야 합니다. 앞에서 함수의 이름에 대해 배울 때, 인자 레이블까지 포함된 전체 이름을 함수의 식별자라고 부르고 함수의 이름과는 구분하는 것이 좋겠다고 설명한 적이 있는데요. 기억하나요? 바로 지금과 같은 경우 때문입니다. 만약 boo(age:name:)가 함수의 정확한 이름이라면, boo 만으로도 함수 대입이 가능한 위의 케이스를 설명할 방법이 없기 때문이죠. 이를 설명하기 위해서는 boo는 함수의 이름, boo(age:name:)은 함수의 식별자로 나누어 생각해 주어야 합니다. 물론 함수의 대입구문을 작성할 때는 함수의 이름이나 함수의 식별자 어느 것을 사용해도 됩니다.</p>
<p><br></p>
<p>정확하게는 boo는 매개변수를 제외한 함수의 이름이 boo인 모든 함수를 대변하고, boo(age:name:)은 함수의 이름이 boo이면서 매개변수가 각각 age, name인 함수를 가리킵니다. 따라서 함수의 이름은 조금 더 범용적으로 사용할 수 있는 여지가 있지만, 이로 인해 문제를 일으키기도 합니다. 주로 함수 타입에 대한 타입 어노테이션을 누락하는 경우인데요. 다음 예제를 살펴봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boo</span><span class="params">(age: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(age)"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boo</span><span class="params">(age: Int, name: String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(name)의 나이는 \(age)입니다"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let t = boo  // Ambiguous use of 'boo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 해결방법 1) 타입 어노테이션을 통해 입력받을 함수의 타입을 지정</span></span><br><span class="line"><span class="keyword">let</span> t1: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = boo</span><br><span class="line"><span class="comment">// 해결방법 2) 함수의 식별값을 통해 입력받은 정확한 함수를 지정</span></span><br><span class="line"><span class="keyword">let</span> t2 = boo(age:name:)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">앞에서 등장한 두 함수를 같은 자리에서 정의했습니다. 그리고 t 상수에 boo 함수를 대입하죠. 그러면 이때의 boo 함수는 위쪽일까요, 아래쪽일까요? 두 함수 모두 함수의 이름은 boo이지만, 뒤의 매개변수 차이 때문에 서로 다른 식별값을 가집니다. 따라서 boo로 대입하려면 둘 중 어느 함수를 가리키는 것인지 정확하게 판단할 수 없으므로 오류가 발생합니다. 이 오류를 방지하기 위해서는 대입 구문을 위의 두 가지 중 하나의 형태로 바꾸어 주어야 합니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">타입 어노테이션을 사용하는 경우에는 입력받을 값의 타입이 명확하기 때문에, boo가 가리키는 함수가 다소 불확실하더라도 컴파일러가 찾아서 대입할 수 있습니다. 마찬가지로 식별값을 통해 지정하는 경우도 정확한 함수를 찾아 대입할 수 있기 때문에 문제가 되지 않습니다. 가령, 다음과 같이 타입 어노테이션을 적절히 사용하면, 같은 함수 이름을 사용하여 대입하더라도 서로 다른 결과를 가져오기도 합니다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="keyword">let</span> fn01: (<span class="type">Int</span>) -&gt; <span class="type">String</span> = boo <span class="comment">// boo(age:)</span></span><br><span class="line"><span class="keyword">let</span> fn02: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = boo <span class="comment">// boo(age:name:)</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>두 상수 fn01, fn02는 모두 boo라는 함수 이름으로 함수를 할당받고 있습니다. 하지만 타입 어노테이션의 차이로 인해, 각각 다른 함수가 대입됩니다. 먼저 fn01에 대입된 함수는 boo(age:)입니다. 타입 어노테이션이 가리키는 형식이 인자값이 하나인 함수이기 때문이죠. 반면에 fn02에 대입된 함수는 boo(age:name:)입니다. 타입 어노테이션이 Int, String 두 개의 인자값을 가진 함수를 가리키고 있기 때문입니다. 이처럼 동일한 함수 이름을 사용하여 대입하더라도 타입 어노테이션에 의해 대입되는 함수가 달라지기도 하므로 주의해야 합니다.</p>
<p><br></p>
<p>타입 어노테이션과 함수 이름의 조합으로 대입 구문을 구성하면 안 되는 경우도 있습니다. 동일한 함수 타입을 사용하지만 매개변수명이 서로 다른 함수가 이에 해당합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hoo</span><span class="params">(age: Int, name: String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(name)의 나이는 \(age)세 입니다"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boo</span><span class="params">(height: Int, nick: String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(nick)의 키는 \(height)입니다"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn03 = boo(age:name:)</span><br><span class="line"><span class="keyword">let</span> fn04 = boo(height:nick:)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>함수 타입을 표시할 때 반환값이 없는 경우에는 빈 괄호 대신 ‘Void’를 사용하여 명시적으로 ‘값이 없음’을 표시하기도 합니다. Void는 빈 튜플을 나타내는 값으로, 타입 알리어스로 정의된 단어입니다. 클래스나 구조체 등의 객체가 아닌 키워드임에 주의해야 합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Void</span> = ()</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 코드가 Void 키워드를 선언하는 스위프트 내부 코드입니다. typealias 키워드와 함께 선언된 Void에 빈 튜플을 의미하는 “()”이 대입되어 있죠. 이렇게 선언된 키워드 Void는 빈 괄호를 대신하여 사용할 수 있습니다. Void를 적용해보면 함수 타입은 다음과 같이 표현됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Int</span> -&gt; ()  =&gt; (<span class="type">Int</span>) -&gt; <span class="type">Void</span></span><br><span class="line">() -&gt; () =&gt; () -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>Void 키워드는 본래 빈 인자값의 표현에도 사용할 수 있었으나 4.0 버전부터는 반환 타입에만 사용할 수 있도록 제한되었습니다. 그러면 이렇게 새로 학습한 함수 타입을 직접 사용해보아야겠죠? 그래야 오래오래 머리에 남을테니 말입니다. 그래서 다음 절에서는 함수 타입을 충분히 사용할 수 있는 주제를 준비했습니다. 바로 일급 함수의 두 번째 특성, 함수의 반환 타입으로 함수를 사용하는 방법에 대해서입니다.</p>
<p><br></p>
<ul>
<li>함수의 반환 타입으로 함수를 사용할 수 있음</li>
</ul>
<p><br></p>
<p>일급 함수의 특성 중에서 두 번째로 학습할 부분은 함수의 반환 타입으로 함수를 사용할 수 있다는 특성입니다. 일급 객체로 대우받는 함수는 실행 결과로 정수, 실수, 문장열 등의 기본 자료형이나 클래스, 구조체 등의 객체를 반환할 수 있을 뿐만 아니라 함수 자체를 반환할 수도 있습니다. 함수가 함수를 반환한다는 의미를 알기 위해 다음 예제를 봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">desc</span><span class="params">()</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is desc()"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pass</span><span class="params">()</span></span> -&gt; () -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> desc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = pass()</span><br><span class="line"><span class="built_in">print</span>(p())</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>얼핏 보면 이해하기 힘든 구문일 수도 있으니 차근차근 살펴봅시다. 먼저 가장 위에 작성된 것은 desc 함수입니다. 같은 이름으로 여러 번 등장하고 있는 이 함수는 인자값 없이 문자열을 반환하는 함수 형식으로 정의되어 있습니다. 그 다음으로 작성된 것은 pass 함수입니다. 이 함수의 내부 블록을 살펴보면 다른 실행 구문 없이 desc라는 함수 자체를 반환하는 구문뿐입니다. 여기서 pass 함수의 반환 타입은 함수 타입인 () -&gt; String으로 정의됩니다. 이는 pass 함수가 desc 함수를 반환하기 때문으로, () -&gt; String은 desc 함수의 타입 표현에 해당합니다. desc 함수는 인자값 없이 문자열만 반환하고 있기 때문에 이를 함수 타입으로 표현하면 () -&gt; String 형식이 됩니다. 이 함수 타입의 표현이 pass 함수의 반환 타입으로 사용되고 있는 겁니다. </p>
<p><br></p>
<p>이어서 상수 p는 pass 함수의 실행 결과값을 할당받고 있습니다. 만약 pass 함수 자체를 할당받았다면 상수 p에 할당된 것은 pass 함수였겠지만, pass 함수의 실행 결과는 desc 함수이므로 상수 p에는 desc 함수가 할당됩니다. 이제 p 상수는 desc 함수나 마찬가지입니다. p에 함수호출 연산자를 붙여 실행하면 desc 함수를 실행하는 것이 되죠. 이러한 과정을 거쳐 p()의 실행 결과는”this is desc()”가 됩니다.</p>
<p><br></p>
<p>함수의 반환값이 함수일 경우, 아무래도 함수의 형식이 복잡해질 가능성이 큽니다. 가독성도 매우 떨어지죠. 이를 방지하기 위해 최근의 문법에서는 반드시 인자값 부분에 괄호를 통해 감싸주도록 강제하지만, 점점 더 복잡한 형태의 함수 타입을 사용할수록 형식을 분석하기 어려워질 겁니다. 이어서 함수의 반환 타입으로 함수를 사용하는 조금 복잡한 예제를 살펴보겠습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minus</span><span class="params">(a: Int, b:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">times</span><span class="params">(a: Int, b:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a: Int, b:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> b != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(<span class="number">_</span> operand: String)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> operand &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">        <span class="keyword">return</span> plus</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">        <span class="keyword">return</span> minus</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">        <span class="keyword">return</span> times</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">        <span class="keyword">return</span> divide</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> plus</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = calc(<span class="string">"+"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(calc(<span class="string">"+"</span>)(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>하나하나의 함수는 주석이 필요 없을 만큼 단순한 기능입니다. 각각 덧셈, 뺄셈, 곱셈, 나눗셈 연산을 수행하여 그 결과를 반환하는 함수들이죠. 나눗셈에서만 예외로 나눌 값이 0인 경우를 대비하여 guard 구문이 추가된 것을 제외하면 모든 함수의 구성이 거의 같습니다. 마지막으로 작성된 calc는 조금 다릅니다. 이 함수는 사칙연산의 연산자를 문자열 형식으로 입력받습니다. 이 인자값을 기준으로 switch 구문에서 각 인자값에 대응하는 함수를 반환하는 것이 calc 함수가 처리하는 내용입니다. 반환하는 함수의 인자값과 반환값은 모두 일치하며 이들 함수의 타입 표현식은 (Int, Int) -&gt; Int입니다. 함수 calc에 인자값으로 연산자를 입력하면 그에 해당하는 함수를 반환받을 수 있죠. 외부 매개변수를 언더바로 처리함으로써 함수 호출 시 인자 레이블을 생략할 수 있도록 해 놓은 것도 눈여겨볼 부분입니다.</p>
<p><br></p>
<p>“+” 문자열을 인자값으로 하여 함수를 실행한 결과, switch 구문의 패턴 비교에 의해 plus 함수가 반환됩니다. 이 함수가 상수 c에 할당되었으므로 이를 함수 호출 연산자로 실행하면 plus 함수가 실행됩니다. 결과값은 7이죠. 이처럼 함수의 실행 결과로 다른 함수를 반환할 수 있는 것이 일급 함수의 특성입니다. 이 특성은 중첩 함수(Nested Functions)를 학습할 때 다시 다룹니다.</p>
<p><br></p>
<ul>
<li>함수의 인자값으로 함수를 사용할 수 있음</li>
</ul>
<p><br></p>
<p>일급 함수는 반환값으로 함수를 사용할 수 있을 뿐만 아니라 다른 함수의 인자값으로 함수를 전달할 수 있는 특성도 있습니다. 일급 함수를 다루는 타 언어 중에서 특히 널리 알려진 언어로 자바스크립트가 있는데, 이 언어를 이용하여 웹 프로그래밍에서 Ajax 구현을 해보면 반드시 다루게 되는 개념으로 콜백 함수(Callback Function)가 있습니다. 콜백 함수는 특정 구문의 실행이 끝나면 시스템이 호출하도록 처리된 함수로서, 일반적으로 Ajax 통신을 위한 구문을 작성할 때 콜백 함수를 등록합니다. 콜백 함수 등록이란, 실행하고자 하는 구문을 담은 함수를 인자값으로 넣는 것을 의미하죠. 이때 사용되는 개념이 바로 일급 함수의 특성인 함수를 인자값으로 사용할 수 있다입니다.</p>
<p><br></p>
<p>함수를 인자값으로 전달할 때 그 함수는 하나의 타입이 됩니다. 따라서 함수를 입력받는 인자값은 함수 타입으로 정의되어야 합니다. 이 점을 제외하면 인자값으로 함수를 전달하는 방식에는 특별한 것이 없습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(param: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> param + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broker</span><span class="params">(base: Int, function fn: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn(base)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(broker(base: <span class="number">3</span>, function: incr))</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>incr(param:)은 정수값을 입력받아 +1을 처리한 값을 반환하는 함수입니다. 뒤이어 정의된 broker(base:function:)은 인자로 받은 함수를 실행하는 함수죠. broker(base:funcion:)은 두 번째 매개변수에 대한 인자값에 어떤 함수가 들어오는지 상관하지 않습니다. 단지 정수를 입력받고 정수를 반환하는 타입의 함수이기만 하면 됩니다. 그렇게 매개변수 타입이 정의되어 있기 때문입니다. 정의된 타입에 맞는 함수가 입력되면, 그게 어떤 함수이든 간에 그냥 실행하고 그 결과를 반환해 버립니다. 그러나 broker(base:function:) 함수의 정의 구문만으로는 어떤 연산이 실행될지 짐작하기 어렵습니다. 실질적인 연산은 인자값으로 받는 함수에 달려 있기 때문입니다. 보통 이런 식으로 중개 역할을 하는 함수를 브로커(Broker)라고 합니다.</p>
<p><br></p>
<p>마지막 행에서 broker(base:function:) 함수는 정수 3과 incr(param:) 함수를 인자값으로 하여 호출됩니다. 내부적으로 실행될 함수가 incr(param:)인 것이 파악된 지금에서야 비로소 broker(base:functiion:)가 처리할 내용을 짐작할 수 있게 되는 거죠. 이처럼 함수를 인자로 사용하면 실행 전까지 어떤 구문이 수행될지 컴파일러가 미리 알 수 없으므로 컴파일 시점에서 디버깅할 수 없는 단점이 있습니다. 하지만 잘 활용하면 동적으로 정의되는 훌륭한 함수를 만들 수 있습니다. 이번에는 콜백 함수를 사용하는 예를 살펴봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">successThrough</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"연산 처리가 성공했습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failThrough</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"처리 과정에서 오류가 발생했습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(base: Int, success sCallBack: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>, fail fCallBack: () -&gt; <span class="type">Void</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> base != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        fCallBack() <span class="comment">// 실패 함수를 실행한다.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        sCallBack() <span class="comment">// 성공 함수를 실행한다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> / base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divide(base: <span class="number">30</span>, success: successThrough, fail: failThrough)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위의 예제는 함수 인자를 사용하여 콜백을 처리하고 있습니다. 이 함수는 첫 번째 인자로 받은 정수를 사용하여 100을 나누고, 그 몫을 정수 형태로 반환하는 역할을 합니다. 두 번째 인자는 내부 연산 과정이 성공적으로 완료되었을 때 실행할 함수이며, 세 번째 인자는 내부 연산 과정이 실패했을 때 실행할 함수입니다. divide(base:succfess:fail:) 함수는 내부 연산이 성공하거나 실패했을 때 값을 반환하는 것 이외에는 아무것도 하지 않습니다. 단순히 인자값으로 입력받은 함수를 실행할 뿐입니다.</p>
<p><br></p>
<p>이런 식의 구문을 작성하면 함수가 성공, 또는 실패했을 때의 처리 과정을 외부에서 제어할 수 있습니다. 즉, 함수의 내부 코드를 수정하지 않고도 외부에서 함수 내부의 실행 과정에 간섭할 수 있다는 뜻입니다. 완전히 실행 흐름을 꺾지는 못하지만, 그 실행 흐름에 합류하여 추가 기능을 수행하는 것 정도는 충분히 가능합니다. 첫 번째 입력값이 0이면 divide 함수는 내부 연산을 수행할 수 없습니다. Divide By Zero 오류가 발생하기 때문입니다. 이 때문에 guard 구문을 사용하여 입력값이 0이 되는 경우를 방지해 주어야 합니다.</p>
<p><br></p>
<p>만약 입력된 base가 0이라면 조건 실패로 인해 else 구문의 내용이 실행됩니다. fCallback은 함수처럼 보이지만 실제로는 매개변수입니다. 여기에 함수가 대입되었을 뿐이죠. else 구문은 외부에서 전달된 실패 처리 함수를 fCallBack 매개변수를 통하여 실행한 다음 0을 반환하면서 함수를 종료합니다. 이 때문에 실제로 함수가 실행되기 전에는 실패 처리 내용을 알 수 없습니다. 오로지 ‘fCallBack 매개변수에 대입된 함수를 실행한다’라는 구문만 있을 뿐입니다.</p>
<p><br></p>
<p>마찬가지로 입력된 base의 값이 0이 아닐 경우 나누기 연산이 실행됩니다. 연산이 성공했을 때에는 sCallBack 매개변수에 대입된 함수가 실행되는데, 이때 값을 반환하는 return 구문과 성공 함수를 실행하는 과정 사이에 발생할 수 있는 미묘한 타이밍 차이를 해결하기 위해 defer 구문이 사용됩니다. defer 블록은 함수나 메소드에서 코드의 흐름과 상관없이 가장 마지막에 실행되는 블록입니다. 지연 블록이라고 부르기도 하는 이 블록에 작성된 구문은 작성된 위치에 상관없이 항상 함수의 종료 직전에 실행되기 때문에, 종료 시점에 맞추어 처리해야 할 구문이 있다면 우리는 어디에 작성해야 할지 고민하지 않고 defer 블록에 넣어두기만 하면 됩니다. 실제로 이 블록은 함수에서 사용된 각종 리소스 처리나 해제, 연결 종료 등의 구문을 처리하는 용도로 유용하게 사용됩니다. defer 블록은 다음과 같은 특성을 가지고 있습니다.</p>
<p><br></p>
<ol>
<li>defer 블록은 작성된 위치와 순서에 상관없이 함수가 종료되기 직전에 실행된다.</li>
<li>defer 블록을 읽기 전에 함수의 실행이 종료될 경우 defer 블록은 실행되지 않는다.</li>
<li>하나의 함수나 메소드 내에서 defer 블록을 여러 번 사용할 수 있다. 이때에는 가장 마지막에 작성된 defer 블록부터 역순으로 실행된다.</li>
<li>defer 블록을 중첩해서 사용할 수 있다. 이때에는 바깥쪽 defer 블록부터 실행되며 가장 안쪽에 있는 defer 블록은 가장 마지막에 실행된다.</li>
</ol>
<p><br></p>
<p>defer는 주로 함수가 연산을 처리하는 과정에 영향을 끼치지 않으면서 실행해야 할 다른 내용이 있을 때 사용하거나, 함수를 종료하기 직전에 정리해야 하는 변수나 상수값들을 처리하는 용도로 사용됩니다. 다시 말해, 함수를 종료하기 전에 처리해야 하는 변수나 상수들 중에서 처리 시점이 모두 달라서 적절한 처리 시점을 잡기 어려울 때 defer 구문을 통해 처리하면 된다는 뜻입니다.</p>
<p><br></p>
<p>함수를 인자로 넘기는 가장 큰 목적은 함수 내부의 코드를 건드리지 않고도 외부에서 실행 흐름을 추가하기 위함입니다. 원래대로라면 실행 구문들이 들어가야 하겠지만, 구문 자체를 인자로 넣을 수는 없으므로 구문을 집약한 함수가 인자값으로 사용되는 것입니다. 함수 외부에서 함수 내부에 실행 구문을 추가할 수 있다는 것은, 함수를 그만큼 재활용할 수 있다는 장점이 되기도 합니다.</p>
<p><br></p>
<p>위 함수가 성공/실패 함수를 인자값으로 받지 않는다고 가정하고, 만약 이 함수의 연산을 두 군데에서 호출해야 하는데 호출하는 지점마다 함수가 연산 성공/실패 시 처리해야 하는 내용이 다르다면 어떻게 해야 할까요? 아마도 그때마다 함수를 새로 작성해야 할 겁니다. 성공/실패 처리 구문 차이 때문에 거의 같은 연산을 처리하는 함수가 중복으로 작성되어야 하죠. 하지만 이처럼 호출하는 지점마다 다르게 적용되어야 하는 부분을 함수 인자값으로 받도록 처리하면 함수를 공통으로 사용할 수 있는 범위가 넓어집니다. 공통 코드를 사용하고, 각자 다르게 작용되어야 할 부분만 함수 인자를 통하여 제어하면 되기 때문입니다. 결국, 함수의 재사용성이 높아지는 셈입니다.</p>
<p><br></p>
<p>그런데 인자값으로 사용하기 위해 매번 새로운 성공/실패 함수를 작성해야 하는 것도 번거로운 작업입니다. 특히 재사용하지 않는 코드를 굳이 함수로 작성해야 한다는 것은 매우 비능률적인 일에 틀림없습니다. 이런 문제를 해결하고자 많은 함수형 언어에서는 익명 함수를 지원합니다. 익명 함수는 쉽게 생각해서 일회용 함수라고 생각하면 됩니다. 함수의 형태를 가지지만 이름이 부여되지 않으며, 일회용이기 때문에 여러 가지 간편한 작성 형식을 따른다는 특성이 있습니다.</p>
<p><br></p>
<p>스위프트에서도 익명 함수를 지원합니다. 이를 클로저(Closure)라고 부르죠. 우리는 클로저를 이용하여 익명 함수 형태의 코드 블록을 작성합니다. 클로저에 대해서는 뒤에 자세히 다루게 되므로 여기에서는 위 예제의 호출 부분을 익명 함수를 이용한 코드로 변경하는 내용만 살펴보고 넘어가도록 하겠습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">divide(base: <span class="number">30</span>,</span><br><span class="line">       success: &#123;</span><br><span class="line">        () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"연산 처리가 성공했습니다"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">       fail: &#123;</span><br><span class="line">        () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"처리 과정에 오류가 발생했습니다"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>복잡해 보이지만, 생각보다 단순합니다. 가존에 함수 이름이 입력되었던 부분에 함수 본문이 작성된 것에 지나지 않습니다. 복잡해 보이는 이유는 클로저의 형태로 작성되었기 때문입니다. 자세한 것은 클로저를 학습한 다음에 이해할 수 있으므로 단순히 익명 함수의 형태로 코드를 작섣ㅇ할 수 있다는 것만 이해하고 넘어가면 됩니다.</p>
<p><br><br></p>
<h4 id="함수의-중첩"><a href="#함수의-중첩" class="headerlink" title="함수의 중첩"></a>함수의 중첩</h4><p>스위프트에서 함수는 중첩하여 작성할 수 있습니다. 함수 내에 다른 함수를 작성해서 사용할 수 있다는 것입니다. 이렇게 작성된 함수를 중첩 함수라고 합니다. 함수 내에 작성할 수 있는 내부 함수의 수에는 제한이 없습니다. 외부 함수 내에 여러 개의 내부 함수를 정의할 수도 있고, 외부 함수 내에 작성된 내부 함수에 또 다른 내부 함수를 작성할 수도 있습니다. 구조가 복잡해지고 유지보수가 힘들어질지언정, 중첩 함수의 수에는 제한이 없습니다.</p>
<p><br></p>
<p>함수를 중첩해서 정의하면 내부 함수는 외부 함수가 실행되는 순간 생성되고, 종료되는 순간 소멸합니다. 외부 함수는 프로그램이 실행될 때 생성되고 프로그램이 종료될 때 소멸하지만, 내부 함수는 외부 함수의 실행과 종료 사이에서 생겼다가 사라집니다. 즉 외부 함수가 종료되면 내부 함수도 더는 존재하지 않는 것이죠. 이것이 내부 함수의 생명 주기입니다. 내부 함수는 일반적으로 외부 함수를 거치지 않으면 접근할 수 없습니다. 이 때문에 내부 함수는 외부의 코드로부터 차단되는 결과를 가져옵니다. 이를 함수의 은닉성이라고 합니다. 중첩된 함수를 구현하면 함수의 은닉성을 높일 수 있습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 외부함수</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outer</span><span class="params">(base: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="comment">// 내부함수</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inner</span><span class="params">(inc: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\(inc)를 반환했습니다"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = inner(inc: base + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer(base: <span class="number">3</span>)  <span class="comment">// 4를 반환했습니다</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>outer는 Int 타입의 값을 인자로 받아 문자열을 반환하는 함수입니다. 이 함수의 내부에는 inner라는 이름의 함수가 작성되어 있는데, 이 함수의 외부에서 참조할 수 없으며 오로지 outer 함수 내부에서만 참조할 수 있습니다. 직접 인자값을 전달할 수도 없죠. 말하자면 inner 함수는 외부로부터 은닉되어 있습니다.</p>
<p><br></p>
<p>내부 함수의 생명 주기를 알아봅시다. 일반적으로 함수는 자신을 참조하는 곳이 있으면 생성되었다가 참조하는 곳이 사라지면 제거되는 생명 주기를 가집니다. 다시 말해 함수의 생명 주기는 참조 카운트와 관련되어 있습니다. 함수는 참조 카운트가 0에서 1이 되는 순간 생성되어 1 이상인 동안 유지되다가, 0이 되면 소멸하는 과정을 반복합니다. 내부 함수의 경우에는 어떨까요?</p>
<p><br></p>
<p>내부 함수를 참조할 수 있는 곳은 그 함수를 선언해준 외부 함수 이외에는 없습니다. 나머지 외부 범위로부터 내부 함수는 은닉되기 때문이죠. 따라서 이러한 경우 내부 함수의 생명 주기는 전적으로 외부 함수에 의존합니다. 외부 함수가 실행되면서 내부 함수에 대한 참조가 발생하면 생성되고, 외부 함수가 종료되면서 내부 함수에 대한 참조도 종료되면 내부 함수는 소멸합니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 외부함수</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outer</span><span class="params">(param: Int)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="comment">// 내부함수</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inner</span><span class="params">(inc: Int)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\(inc)를 리턴합니다"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn1 = outer(param: <span class="number">3</span>)  <span class="comment">// outer()가 실행되고, 그 결과로 inner가 대입됩니다.</span></span><br><span class="line"><span class="keyword">let</span> fn2 = fn1(<span class="number">30</span>)  <span class="comment">// inner(inc: 30)과 동일합니다.</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 예제에서는 함수 outer가 실행 결과로 inner를 반환합니다. 이 값을 할당받은 상수 fn1는 내부 함수 inner와 동일한 함수이므로, 함수 호출 연산자를 통해 인자값을 입력하고 호출하면 inner 함수를 호출한 것과 같은 결과를 얻을 수 있습니다. 실제로도 inner 함수가 실행된 것이라고 볼 수 있습니다. 여기까지는 단순히 앞의 일급 함수 특성에 대한 설명에 지나지 않습니다. 이제 이 예제가 갖는 의미에 대해 해석해봅시다.</p>
<p><br></p>
<p>위 예제에서 주의 깊게 보아야 할 것은 은닉성이 있는 내부 함수 inner를 외부 함수의 실행 결과로 반환함으로써 내부 함수를 외부 함수에서도 접근할 수 있는 길이 열렸다는 점입니다. 이제까지 내부에서 정의된 함수 inner는 오롲지 외부 함수인 outer를 통해서만 접근할 수 있었습니다. 이로 인해 완벽한 은닉성이 제공되었죠. 하지만 내부 함수를 이렇게 반환하면 outer 함수의 실행 결과는 내부 함수 inner 그 자체가 됩니다. 이를 할당받은 상수 fn1에는 내부 함수가 대입되므로 fn1을 사용하여 얼마든지 inner를 호출할 수 있습니다.</p>
<p><br></p>
<p>inner 함수의 생명 주기에 대해서도 주의할 필요가 있습니다. 본래 inner는 외부 함수인 outer가 실행 종료되면 소멸하도록 설계되어 있습니다. 따라서 원래대로라면 let fn1 = outer(param: 3) 구문이 실행되었을 때 inner는 소멸해야 합니다. 그런데 다음 줄을 살펴보면 inner 함수가 소멸하지 않고 fn1에 할당된 채로 생명을 유지하다가 (30)이라는 함수 호출 연산자 구문을 만나 실행되는 것을 확인할 수 있습니다. 즉, 외부 함수에서 내부 함수를 반환하게 되면 외부 함수가 종료되더라도 내부 함수의 생명이 유지되는 것입니다.</p>
<p><br></p>
<p>실제로 중첩된 외부 함수 outer는 let fn1 = outer(param: 3) 구문의 실행 종료와 함께 제거됩니다. 더는 자신을 참조하는 곳이 없기 때문이죠. 만약 outer 함수 내부에 지역 변수가 정의되어 있다면 함수의 종료 시 함께 제거됩니다. 지역 변수는 자신을 선언한 블록의 실행 종료와 운명을 함께하기 때문입니다. 하지만 내부 함수인 inner는 결과값으로 반환되어 상수 fn1에 참조되었으므로 참조 카운트가 존재합니다. 이로 인해 외부 함수의 종료에도 아랑곳하지 않고 생명을 유지할 수 있습니다. 정리하자면 내부 함수 inner는 혼자만 살아남은 겁니다. 그렇다면 만약 내부 함수에 외부 함수의 지역 상수, 또는 지역 변수가 참조되면 어떤 일이 벌어질까요?</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">basic</span><span class="params">(param: Int)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = param + <span class="number">20</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(add: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value + add</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> append</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = basic(param: <span class="number">10</span>)  <span class="comment">// (1)</span></span><br><span class="line">result(<span class="number">10</span>)  <span class="comment">// (2)</span></span><br><span class="line"><span class="comment">// 40</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>basic 함수는 정수를 인자값으로 받고 내부에 중첩된 함수 append를 반환하는 형식으로 정의되어 있습니다. 내부 함수 append는 외부 함수 basic이 받은 인자값에 20을 더한 값을 자신의 인자값과 더하여 반환합니다. 두 함수는 모두 상수 value를 참조하는데, 이는 basic 함수에 정의된 지역 상수입니다. (1)에서 구문이 실행되면 basic 함수가 실행되고, 그 결과로 내부 함수인 append가 반환됩니다. basic 함수는 실행이 모두 끝났으므로 종료되지만 반환된 내부 함수 append는 상수 result가 참조하고 있는 까닭에 소멸하지 않고 계속 남아있다가 (2)에서 실행됩니다.</p>
<p><br></p>
<p>이 과정에서 value 상수에 주목해봅시다. 일반적으로 함수 내에서 정의된 값들은 그 함수가 종료되기 직전까지만 존재하므로, value 상수는 (1)의 실행이 종료되기 직전까지만 존재해야 합니다. 즉, (1)의 실행이 완료될 때 함께 제거될 것이라는 뜻이죠. 따라서 (2) 구문이 실행되는 시점에서는 value 상수는 더는 존재하지 않으며, append 함수의 내부 블록에서는 결과적으로 존재하지 않는 상수를 참조하고 있는 모양이 됩니다. 오류가 발생할 것이라고 쉽게 예상할 수 있습니다. 하지만 실제로 실행해 보면 예상과 달리 이 코드는 문제없이 동작하며, (2)는 40이라는 결과를 반환합니다. 어떻게 된 일일까요?</p>
<p><br></p>
<p>이러한 현상에 대한 원인은 바로 클로저 때문입니다. 더 정확히는 append 함수가 클로저를 갖기 때문입니다. 클로저를 설명하자면 다음과 같습니다.</p>
<p><br></p>
<ol>
<li>클로저는 두 가지로 이루어진 객체입니다. 하나는 내부 함수이며, 또 다른 하나는 내부 함수가 만들어진 주변 환경입니다.</li>
<li>클로저는 외부 함수 내에서 내부 함수를 반환하고, 내부 함수가 외부 함수의 지역 변수나 상수를 참조할 때 만들어집니다.</li>
</ol>
<p><br></p>
<p>어렵죠? 클로저를 조금 더 간단하게 요약한다면 다음과 같습니다. 클로저란 내부 함수와 내부 함수에 영향을 미치는 주변 환경(Context)를 모두 포함한 객체입니다. 주변 환경이라는 것은 내부 함수에서 참조하는 모든 외부 변수나 상수의 값, 그리고 내부 함수에서 참조하고 있는 다른 객체까지를 말합니다. 이를 문맥(Context)이라고 합니다. 즉 클로저란 내부함수와 이 함수를 둘러싼 주변 객체들의 값을 함께 의미하는 것이라고 할 수 있습니다.</p>
<p><br></p>
<p>클로저란, ‘내부 함수 + 함수의 줒변 환경’입니다. 더 나아가서 클로저에서 저장하는 주변 환경은 변수나 객체 자체가 아니라 이들의 값입니다. 이를 위해 클로저가 만들어지려면 함수가 정의되는 것만으로는 충분치 않고, 실제로 basic 함수가 호출되어야 합니다. 즉, (1) 구문이 싫행되어야 클로저가 만들어질 수 있다는 거죠. 이 구문이 실행될 때 생성되는 클로저는 표시된 그림에서 보는 것처럼 두변 환경을 포함하지만, 포함하는 것은 어디까지나 주변 환경의 객체 자체가 아니라 값이라는 거죠. 따라서 상수 result에 저장되는 클로저는 다음과 같은 형태로 생성됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(add: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">30</span> + add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>내부 함수를 둘러싼 환경 객체가 값으로 바뀌어 저장됩니다. 이 때문에 기존에 value라는 객체 자체가 사용되던 append 함수의 코드가 basic(param: 10)의 실행으로 얻게 된 값인 30으로 바뀐 것이죠. 이 역시도 완전히 정확한 표현은 아닙니다만, 그ㅐㄹ도 어느 정도 클로저의 성격을 표현해준 것이라고 할 수 있습니다. 이러한 클로저의 특성 때문에 같은 정의를 갖는 함수가 서로 다른 환경을 저장하는 결과가 생겨납니다.</p>
<p><br></p>
<p>이처럼 외부 함수에서 정의된 객체가 만약 내부 함수에서도 참조되고 있고, 이 내부 함수가 반환되어 참조가 유지되고 있는 상태라면 클로저에 의해 내부 함수 주변의 지역 변수나 상수도 함께 저장됩니다. 정확히는 지역 변수의 값이 ‘저장’되는 것이라고 할 수 있죠. 이를 값이 캡처(Capture)되었다라고 표현합니다. 값의 캡처는 문맥에 포함된 변수나 상수의 타입이 기본 자료형이나 구조체 자료형일 때 발생하는데, 이러한 캡처 기능은 클로저의 고유 기능 중 하나입니다.</p>
<p><br><br></p>
<h4 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h4><p>조금 전까지 학습한 클로저는 많은 함수형 언어에서 공통적으로 가지는 소프트웨어 아키텍처적인 개념이었다면, 이제부터 학습해야 할 클로저는 유사하지만 조금 다른 의미의 객체입니다. 실제로 스위프트에서 클로저라고 객체를 지칭하는 대부분은 지금부터 학습할 개념의 클로저를 의미합니다.</p>
<p><br></p>
<p>스위프트에서 클로저는 일회용 함수를 작성할 수 있는 구문입니다. 일회용 함수란 한 번만 사용할 구문들의 집합이면서, 그 형식은 함수로 작성되어야 하는 제약조건이 있을 때 만들어 사용할 수 있는 함수를 이야기합니다. 전통적인 명령형 언어에서는 모든 함수에 이름이 부여되어야 하지만 일회용 함수는 한 번만 사용하면 되므로 굳이 함수의 이름을 짝성할 필요 없이 생략된다는 점에서 익명 함수라고 부르기도 합니다.</p>
<p><br></p>
<p>스위프트에서 제공하는 클로저는 앞 절에서 학습했던 클로저의 개념과 동떨어진 개념은 아닙니다. 앞에서 학습했던 클로저의 개념을 모두 포함합니다. 따라서 클로저는 자신이 정의되었던 문맥(Context)으로부터, 모든 상수나 변수의 값을 캡처하거나 레퍼런스를 저장하는 익명 함수라고 할 수 있습니다. 사실 스위프트에서 익명 함수를 클로저라고 부르게 된 것도, 이러한 함수형 언어에서의 클로저 개념을 사용하고 있기 때문이라고 할 수 있습니다. 스위프트에서 클로저라고 부르는 객체는 대부분 다음 세 가지 경우 중 하나에 해당합니다.</p>
<p><br></p>
<ol>
<li>전역 함수: 이름이 있으며, 주변 환경에서 캡처할 어떤 값도 없는 클로저</li>
<li>중첩 함수: 이름이 있으며, 자신을 둘러싼 함수로부터 값을 캡처할 수 있는 클로저3. 클로저 표현식: 이름이 없으며 주변 환경으로부터 값을 캡처할 수 있는 경량 문법으로 작성된 클로저</li>
</ol>
<p><br></p>
<p>이들 중 전역 함수와 중첩 함수는 앞에서 차례로 알아보았습니다. 이번 절에서 주로 다룰 개념은 클로저 표현식임을 알아두기 바랍니다.</p>
<p><br><br></p>
<h4 id="클로저-표현식"><a href="#클로저-표현식" class="headerlink" title="클로저 표현식"></a>클로저 표현식</h4><p>클로저 표현식은 함수와 달리 생략되는 부분이 많습니다. 우선, 함수를 선언하는 func 키워드를 생략하며, 함수의 이름 또한 생략합니다. 클로저 표현식은 일반 함수의 선언 형식에서 func 키워드와 함수명을 제외한 나머지 부분만 작성하는 경량 문법을 사용합니다. 클로저 표현식은 중괄호 형태의 블록으로 싲작되고, 닫는 블록으로 구문을 완료합니다. 클로저 표현식의 블록 내부에서 가장 먼저 작성하는 것은 함수의 인자 타입과 반환 타입에 대한 정의입니다. 이 부분은 함수 타입으로 표현할 수 있습니다.</p>
<p><br></p>
<p>이때 일반적인 함수 정의라면 반환 타입이 표현된 다음에 실행 블록의 시작을 나타내는 중괄호가 와야 하지만, 클로저 표현식에서는 시작 부분에서 이미 중괄호가 선언된 상태이므로 중괄호 대신 in 키워드를 사용하여 실행 블록의 시작을 표현합니다. in 키워드 다음부터 클로저 표현식의 실행 블록이 작성되는 것이죠.</p>
<p><br></p>
<p>작성된 클로저 표현식은 그 자체로 함수라고 할 수 있습니다. 클로저 표현식은 대부분 인자값으로 함수를 넘겨주어야 할 때 사용하지만, 직접 실행해볼 수도 있습니다. 이를 위한 두 가지 방법이 제공되는데, 첫 번째 방법은 일급 함수로서의 특성을 활용하여 상수나 변수에 클로저 표현식을 할당한 다음 실행하는 방법입니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"클로저가 실행됩니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 구문은 실제로 함수의 인자값으로 전달된 클로저 표현식이 함수 내에서 실행되는 방식입니다. 상수 f에 클로저 표현식으로 작성된 함수 전체가 할당되고, 이 상수에 함수 호출 연산자를 추가함으로써 클로저 표현식이 실행됩니다. 이번에는 클로저를 직접 실행하는 두 번째 방법을 알아봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"클로저가 실행됩니다"</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>두 번째 방법은 클로저 표현식을 할당받을 상수 f마저 생략하고 싶을 때 작성하는 구문입니다. 클로저 표현식 전체를 소괄호로 감싸고, 여기에 함수 호출 연산자를 붙이면 클로저 표현식이 실행됩니다. 클로저 표현식 전체를 소괄호로 감싸지 않으면 컴파일러에서는 이 구문을 클로저 표현식의 정의가 아니라 그 실행값을 변수나 상수에 할당하려는 의도로 해석하여 오류를 발생시키므로 주의해야 합니다.</p>
<p><br></p>
<p>이번에는 매개변수가 있는 형태의 클로저 표현식을 알아봅시다. 매개변수가 있는 클로저 표현식도 그 자체는 크게 다르지 않습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> co = &#123; (s1: <span class="type">Int</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"s1: \(s1), s2: \(s2)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(<span class="number">1</span>, <span class="string">"closure"</span>)</span><br><span class="line"></span><br><span class="line">(&#123; (s1: <span class="type">Int</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"s1: \(s1), s2: \(s2)"</span>)</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="string">"closure"</span>)</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h4 id="클로저-표현식과-경량-문법"><a href="#클로저-표현식과-경량-문법" class="headerlink" title="클로저 표현식과 경량 문법"></a>클로저 표현식과 경량 문법</h4><p>클로저 표현식은 주로 인자값으로 사용되는 객체인 만큼, 간결성을 극대화하기 위해 생략할 수 있는 구문들로 이루어져 있습니다. 필요에 따라 여러 부분을 생략할 수 있죠. 배열의 정렬 메소드 예제를 통해 실제로 클로저 표현식에 적용되는 경량 문법에 대해 조금 더 알아봅시다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = [<span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>위 배열은 정렬 함수인 sort(by:)를 이용하여 큰 순서나 작은 순서대로, 또는 임의의 순서대로 정렬할 수 있습니다. 정렬 기준을 잡기 위해서는 특정 형식을 따르는 함수를 정의하여 인자값으로 넣어주어야 합니다. 형식이라고 해도 두 개의 인자값을 입력받고 크기를 비교하여 Bool 타입으로 반환하는 것이 전부입니다. 기본적으로 정렬은 두 값의 비교를 반복하는 알고리즘입니다. 두 값을 비교하여 작은 값을 앞으로, 큰 값을 뒤로 배치하는 과정을 무수히 반복하죠. 수차례 실행한 결과, 순서를 바꿀 값들이 더 이상 나타나지 않을 때가 정렬이 완료되는 시점입니다. 즉, 정렬의 기준은 두 개의 값을 비교하고, 어느 것이 더 큰지만 판단할 수 있으면 충분합니다. 인자값으로 사용하는 정렬 기준 함수가 위의 형식을 따르는 것을 이 때문입니다.</p>
<p><br></p>
<p>정렬 기준 함수는 순서대로 인자값을 받아 첫 번째 인자값이 두 번째 인자값보다 앞쪽에 와야 한다고 판단되면 true를, 이 외에는 false를 반환함으로써 비교 결과를 전달합니다. 정렬 기준이 되는 함수를 작성하고, 이를 sort(by:) 메소드의 인자로 넣어 배열을 정렬해보겠습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = [<span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">order</span><span class="params">(s1: Int, s2: Int)</span></span> -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> s1 &gt; s2&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">value.<span class="built_in">sort</span>(by: order)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>작성된 함수 order는 입력된 두 인자값을 크기 비교하여 첫 번째 인자값이 크면 true를, 이외에는 false를 반환합니다. true가 반환되면 sort 메소드는 배열에서 두 인자값의 위치를 변경하지 않습니다. 반대로 결과값이 false라면 두 인자값의 위치를 변경합니다. 이 기준에 따라 정렬이 실행된 결과 가장 큰 9가 앞으로, 가장 작은 1이 뒤로 배치되는 내림차순 정렬이 완성되었습니다. 이제 함수 order를 클로저 표현식으로 바꾸어 작성해 보겠습니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">value.<span class="built_in">sort</span>(by: &#123;</span><br><span class="line">    (s1: <span class="type">Int</span>, s2: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> s1 &gt; s2&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">이 클로저 표현식은 여러 형태로 간결화할 수 있습니다. </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">&#123;</span><br><span class="line">    (s1: <span class="type">Int</span>, s2: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    (s1: <span class="type">Int</span>, s2: <span class="type">Int</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125;</span><br><span class="line"></span><br><span class="line">&#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>앞에서부터 차근차근 구문을 생략해 나가지 않았다면 당황스러울 정도로 짧아진 클로저 표현식입니다. 하지만 생략해 나간 순서대로 해석해보면 그리 난해한 구문도 아닙니다. 사실 sort 메소드에서는 클로저 표현식보다 더 간결하게 표현할 수도 있는 방법도 있습니다. 이를 연산자 함수라고 부르는데, 연산자만을 사용하여 의미하는 바를 정확히 나타낼 수 있을 때 사용됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value.<span class="built_in">sort</span>(by: &gt;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="트레일링-클로저"><a href="#트레일링-클로저" class="headerlink" title="트레일링 클로저"></a>트레일링 클로저</h4><p>트레일링 클로저(Trailing Closure)는 함수의 마지막 인자값이 클로저일 때, 이를 인자값 형식으로 작성하는 대신 함수의 뒤에 꼬리처럼 붙일 수 있는 문법을 의미합니다. 이때 인자 레이블은 생략됩니다. 주의할 점은 이같은 문법은 함수의 마지막 인자값에만 적용된다는 겁니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value.<span class="built_in">sort</span>()&#123; (s1, s2) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>외견상 크게 달라진 점은 없어 보입니다. 하지만 자세히 살펴보면 안자값으로 사용되던 클로저가 통째로 바깥으로 빼내어진 다음, sort() 메소드의 뒤쪽에 달라붙은 것을 알 수 있습니다. 이처럼 트레일링 클로저를 사용하면 함수와 메소드의 괄호를 일단 닫은 다음에 별도의 블록으로 클로저를 붙여주면 되므로 사소한 실수가 줄어들 수 있습니다. 인자값이 하나일 경우, 트레일링 클로젖 문법은 조금 더 변화 가능한 여지가 있습니다. </p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value.<span class="built_in">sort</span>&#123; (s1, s2) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>이번에는 sort 메소드 뒤의 괄호가 아예 사라졌습니다. 더 필요한 인자값도 없거니와, 트레일링 클로저 문법 덕분에 호출 구문이라는 점을 명확히 할 수 있으므로 굳이 괄호를 써야 할 필요성이 없거든요. 그래서 인자값이 하나일 때에는 마지막 인자값 뿐만 아니라 인자값을 넣어주기 위한 괄호 부분도 생략이 가능합니다. 만약 인자값이 여러개라면 무작정 괄호를 생략해서는 안됩니다.</p>
<p><br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(base: Int, success s: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">defer</span>&#123;</span><br><span class="line">        s() <span class="comment">// 성공 함수를 실행한다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> / base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divide(base: <span class="number">100</span>)&#123; () <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"연산이 성공했습니다"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>

    </div>

    

    
        <div class="post-tags">
            <i class="fa fa-tags" aria-hidden="true"></i>
            <a href="/tags/ios/">#iOS</a> <a href="/tags/swift/">#swift</a>
        </div>
    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo" target="_blank" rel="noopener">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/04/15/ios-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EC%8B%A4%EC%8A%B5%ED%8E%B8-1/">[iOS] 앱 개발 실습편 (1)</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/04/13/algorithm-%EA%B7%B8%EB%9E%98%ED%94%84/">[Algorithm] 그래프</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/04/09/beakjoon-1-7/">[BaekJoon] A/B</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/04/04/SEM-%EC%B8%A1%EC%A0%95%EB%AA%A8%ED%98%95/">[SEM] 측정모형</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/hci/">HCI</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/nlp/">NLP</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/algorithm/selection-sort/">selection sort</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/algorithm/graph/">graph</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

</body>

</html>