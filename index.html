<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="Sunny Cho">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="QuantPsy"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="QuantPsy"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>QuantPsy</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">QuantPsy</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/20/SEM-%EC%B8%A1%EC%A0%95%EB%AA%A8%ED%98%95/">
                [SEM] 측정모형
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-20</span>
            
            
            
                <span class="category">
                    <a href="/categories/structural-equation-modeling/">structural equation modeling</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="측정모형"><a href="#측정모형" class="headerlink" title="측정모형"></a>측정모형</h1><p>경로모형은 측정의 오차(measurement error)를 가정하지 않는 모형이다. 하지만 현실 속에서 연구자가 생각하는 잠재적 구인이 하나 또는 여러 개의 관찰변수에 의해 완벽하게 측정된다는 것은 거의 불가능하다. 매우 간단한 예를 이용해 완벽한 측정이란 가정이 만족되지 못했을 경우에 발생하는 문제점을 살펴보자. 아래 그림은 하나의 지표변수와 하나의 잠재변수가 있는 경우의 측정모형이다. 사실 몇 가지 제약이 없으면 판별이 가능한 모형은 아니지만 완벽한 측정이라는 주제를 다루기에 적절한 쉬운 모형이다.</p>
<p><br></br></p>
<p><img src="/image/perfect.jpeg" alt="perfect"></p>
<p><br></br></p>
<p>위 그림의 모형을 측정모형의 식으로 표현하면 아래와 같다.</p>
<p><br></br></p>
<script type="math/tex; mode=display">x = \mu + \lambda f + e</script><p><br></br></p>
<p>위에서 $\mu$는 모형의 절편, $\lambda$는 요인계수 또는 요인부하, $\mathit{e}$는 측정오차다. 사실 좀 더 정확히 말하자면 측정오차와 공통요인들로 설명되지 않는 다른 요인(모형 안에 없는 요인)으로 이루어져 있다고 할 수 있다. 이렇게 보면, 위의 모형은 관찰변수인 종속변수 $\mathit{x}$와 잠재변수인 독립변수 $\mathit{f}$ 사이의 회귀모형으로 쉽게 표현된다. 그래서 회귀모형의 가정에 의해 $\mathit{e}$의 기대값(평균)은 0으로 가정하고($\mathit{E(e)=0}$), 거짓고립 가정에 의해 $\mathit{f}$와 $\mathit{e}$의 상관(공분산) 역시 0으로 가정한다. 물론 이 모형의 추정을 위하여 일반적인 회귀분석의 추정 방법(예: 최소제곱법)을 사용할 수는 없다. 이는 $\mathit{x}$의 값들이 관찰되는 데 반해 $\mathit{f}$의 값들은 관찰이 되지 않기 때문이다. $\mathit{f}$는 상상 속의 변수이기 때문에 사실 측정단위조차 존재하지 않는다. 위 식의 모형을 추정하기 위해서는 $\mathit{f}$에 측정단위를 부여해야 하는데, 기술적으로는 어떤 단위를 부여해도 추정이 가능하다. 보통 $\mathit{x}$가 가진 단위와의 관계를 생각하여 줄 수 있는데, 편의상 $\lambda = 1$로 주는 것이 가능하다. 이렇게 되면 $\mathit{f}$의 측정단위가 $\mathit{x}$의 측정단위와 같아지는데, 예를 들어 $\mathit{x}$의 측정단위가 센티미터라면 $\mathit{f}$의 단위도 센티미터가 된다. </p>
<p>정리하면, 측정모형은 하나의 구인이 관찰변수에 의하여 완벽하게 측정될 수 없다는 합리적인 타당성에 기초하여, 잠재변수들과 하나 이상의 관찰된 지표변수 사이의 관계를 설정하고 연구자가 생각하고 있는 잠재적인 구인을 만들어 내는 모형이다. 측정모형은 모형 자체로 구인의 타당도 등을 확인하는 목적도 있으며, 구조방정식 모형의 전 단계로서도 그 중요성이 있다. </p>
<p>측정모형은 요인분석이라는 이름으로 더 많이 알려져 있는데, 관찰변수와 잠재변수의 관계에 대한 가설이 없는 상태에서 그 관계를 탐색적으로 연구하는 방법을 탐색적 요인분석(exploratory factor analysis)이라고 한다. 그에 반해, 관찰변수와 잠재변수의 관계에 대한 가설이 이미 존재하는 상태에서 그 관계를 확인하고자 하는 방법은 확인적 요인분석(confirmatory factor analysis)이라고 한다. 아래에서 설명하겠지만 EFA는 사실 부정(indeterminate) 모형이기 때문에 일반적으로 구조방정식 모형은 CFA에 바탕을 두고 발전한 것이라 볼 수 있다. 그리고 최근 EFA를 이용한 구조방정식 모형(exploratory structural equation modeling, ESEM) 또한 관심을 받고 있기 때문에 EFA에 대하여 잘 알아 두는 것이 필요하다. </p>
<p>여기서 염두에 두어야 할 점은 지금부터 이루어지는 탐색적 요인분석모형이나 확인적 요인분석모형에 대한 설명은 모두 관찰변수가 연속형 변수(continuous variable)임을 가정한다는 것이다. 이런 경우의 요인분석모형을 선형 요인분석(linear factor analysis) 모형이라고 한다. 관찰변수가 연속형이 아닌 경우(이분형 또는 다분형)는 나중에 따로 다루게 될 것이며, 이를 비선형 요인분석(nonlinear factor analysis) 또는 일반화 요인분석 또는 범주형 요인분석 모형이라고 한다. 마지막으로 측정모형의 주요한 응용 방법들인 측정불변성이나 MIMIC 모형 등 여러 추가적인 주제에 대해서 다음에 다루도록 하겠다.</p>
<p><br></br></p>
<h2 id="탐색적-요인분석-EFA"><a href="#탐색적-요인분석-EFA" class="headerlink" title="탐색적 요인분석(EFA)"></a>탐색적 요인분석(EFA)</h2><p>요인분석은 영국의 심리학자인 Spearman(1904)의 전설적인 논문인 “General intelligence”에서 두 요인 이론이라고 지칭한 자신의 지능 이론을 보여 주는 과정에서 개발되었다. 이번 섹션에서는 특히 탐색적 요인분석모형으로 알려진 제약이 없는 요인분석(unrestricted factor analysis) 모형에 대하여 여러 가지로 알아볼 것이다.</p>
<h4 id="공통요인모형과-가정"><a href="#공통요인모형과-가정" class="headerlink" title="공통요인모형과 가정"></a>공통요인모형과 가정</h4><p>먼저 공통요인모형(common factor model)이라고도 불리는 요인분석모형이 있다. 여기서는 총 $\mathit{p}$개의 관찰변수와 $\mathit{m}$개의 요인이 있는 경우를 가정한다.</p>
<p><br></br></p>
<script type="math/tex; mode=display">x_1 = (\mu_1) + \lambda_{11}f_1 + \lambda_{12}f_2 + ... + \lambda_{1m}f_m + e_1</script><script type="math/tex; mode=display">x_2 = (\mu_2) + \lambda_{21}f_1 + \lambda_{22}f_2 + ... + \lambda_{2m}f_m + e_2</script><script type="math/tex; mode=display">\vdots</script><script type="math/tex; mode=display">x_p = (\mu_p) + \lambda_{p1}f_1 + \lambda_{p2}f_2 + ... + \lambda_{pm}f_m + e_p</script><p><br></br></p>
<p>각 구성 요소에 대하여 간략하게 다시 한 번 설명한다. 위에서는 $\mathit{x}$는 관찰변수 또는 지표변수, $\mathit{f}$는 잠재변수 또는 요인, $\mu$는 각 식에서의 절편, $\lambda$는 관찰변수와 잠재변수 사이의 회귀계수로서 요인계수 또는 요인부하, $\mathit{e}$는 측정오차다. 일반적인 요인모형에서 지표변수와 잠재변수는 연속형이라고 가정한다. 연속형이 아닌 지표변수와 잠재변수에 대해서는 나중에 다루게 될 것이다. 위에서 요인들끼리의 상관이 0이라는 가정이 있기 때문에, 특히 $\lambda$는 상응하는 관찰변수와 요인 간의 상관이 된다.</p>
<p>위의 식을 보면 모든 지표변수($\mathit{x_1}$ ~ $\mathit{x_p}$)가 많은 요인부하를 통하여 모든 요인($\mathit{f_1}$ ~ $\mathit{f_m}$)과 서로 관련이 되어 있음을 확인할 수 있는데, 이것이 전형적인 탐색적 요인분석 모형이다. 즉, EFA는 어떤 요인이 어떤 지표변수와 관련이 있는지에 대한 사전적인 가설이 없는 모형이다. 또한 위 식에서는 절편 $\mu$가 각각의 식에 포함되어 있는데, 이는 공분산 행렬에 평균 구조를 더하여 추정할 수 있는 부분이다. 다시 말해, 요인분석의 핵심적인 모수인 $\lambda$들을 추정하는 데 있어서 자료의 변수들로 이루어진 공분산 행렬만 있으면 된다. $\mu$를 모두 제거한 요인모형을 평균 조정 요인분석 모형(mean-corrected factor analysis)이라고 한다. 요인분석모형에서 $\lambda$와 더불어 핵심적으로 추정해야 하는 모수는 측정오차들의 분산 $\psi$이다.</p>
<p><br></br></p>
<h4 id="탐색적-요인분석의-예"><a href="#탐색적-요인분석의-예" class="headerlink" title="탐색적 요인분석의 예"></a>탐색적 요인분석의 예</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Mplus VERSION <span class="number">7</span></span><br><span class="line">MUTHEN &amp; MUTHEN</span><br><span class="line"></span><br><span class="line">INPUT INSTRUCTIONS</span><br><span class="line"></span><br><span class="line">  TITLE: An EFA model of Vocational Interests</span><br><span class="line"></span><br><span class="line">  DATA: FILE IS <span class="string">"C:\Users\내pc\Desktop\final2019\interest_mplus.csv"</span>;</span><br><span class="line"></span><br><span class="line">  VARIABLE: NAMES ARE GEN, EDUC, AGE, COG1-COG6 PER1-PER6 INT1-INT18;</span><br><span class="line">            USEVARIABLES ARE INT1-INT18;</span><br><span class="line"></span><br><span class="line">  ANALYSIS: TYPE = EFA <span class="number">1</span> <span class="number">5</span>; ROTATION = Geomin;</span><br><span class="line"></span><br><span class="line">  PLOT: TYPE = Plot2;</span><br></pre></td></tr></table></figure>
<p><br></br></p>
<p>ANALYSIS 커맨드의 TYPE = EFA1 5; 부분이 바로 탐색적 요인분석을 위한 직접적인 명령어이며, 이는 1요인 모형부터 5요인 모형까지의 결과를 모두 보이라는 뜻이다. Rotation = Geomin;은 사실 Mplus의 디폴트이기 때문에 적어주지 않아도 된다. Promax 등 다양한 종류의 회전방법을 제공하므로 적절하게 선택하면 되는데, 상대적으로 최신 방법인 Geomin을 사용하였다. 이처럼 Mplus의 경우에 디폴트 회전 방법으로서의 사각회전인 Geomin(Yates, 1987)을 사용하는데, Thurstone(1947)의 단순구조를 잘 달성하는 상대적으로 최신의 방법이다. 이 방법은 Thurstone의 단순구조 패널티 함수(complexity function)을 Yates(1987)가 수정하고 Geomin이라고 이름 붙인 패널티 함수를 최소화한다. PLOT 커맨드의 TYPE=Plot2;는 스크리 도표를 보기 위한 옵션이다. 모형을 추정한 다음 Mplus의 메뉴 중에 Plot-View plots를 선택하면 도표를 확인할 수 있다. </p>
<p>탐색적 요인분석모형을 추정하게 되면 몇 개의 요인이 적절한가에 대한 결정을 해야 한다. 대부분의 경우, 연구자의 주 관심사는 자료 세트(R)에 존재하는 분산, 공분산을 최대한으로 설명하는 최소한의 요인 개수가 몇 개인지를 결정하는 것이다. Kaiser(1960)는 R 행렬에서 고유값들을 모두 구해 1이 넘는 개수만큼 요인을 추출해야 한다고 하였으나, 과대추출이나 과소추출 등 여러 문제로 인하여 이 방법을 단독으로 사용하지는 않는다.</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/15/edwith-%EC%9B%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B8%B0%EC%B4%88/">
                [edwith] 웹 프로그래밍 기초
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-15</span>
            
            
            
                <span class="category">
                    <a href="/categories/edwith/">edwith</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="edwith-웹-프로그래밍"><a href="#edwith-웹-프로그래밍" class="headerlink" title="[edwith] 웹 프로그래밍"></a>[edwith] 웹 프로그래밍</h1><p></p>

<h3 id="웹-프로그래밍-기초"><a href="#웹-프로그래밍-기초" class="headerlink" title="웹 프로그래밍 기초"></a>웹 프로그래밍 기초</h3><ol>
<li>웹에 대한 기본이해를 한다.</li>
<li>웹클라이언트와 웹백엔드의 역할을 안다.</li>
<li>HTML 구조화 설계를 할 수 있다.</li>
<li>CSS 기본 스타일을 꾸밀 수 있다.</li>
<li>JAVA 기반의 엡 백엔드 환경을 구성할 수 있다.</li>
<li>서블릿을 이해하고 기본 구성을 할 수 있다.</li>
</ol>
<p><br></br></p>
<p><hr><br><br></br></p>
<h4 id="1-웹-프로그래밍을-위한-프로그램-언어들"><a href="#1-웹-프로그래밍을-위한-프로그램-언어들" class="headerlink" title="1) 웹 프로그래밍을 위한 프로그램 언어들"></a>1) 웹 프로그래밍을 위한 프로그램 언어들</h4><p><br></br></p>
<h5 id="학습목표"><a href="#학습목표" class="headerlink" title="학습목표"></a>학습목표</h5><ol>
<li>다양한 프로그래밍 언어의 종류에 대하여 알아봅시다.</li>
<li>웹 프로그래밍에 좀 더 최적화된 프로그래밍 언어의 장단점에 대하여 알아봅니다.</li>
</ol>
<p></p>

<h5 id="핵심개념"><a href="#핵심개념" class="headerlink" title="핵심개념"></a>핵심개념</h5><ul>
<li>저급언어</li>
<li>고급언어</li>
<li>컴파일러</li>
</ul>
<p><br></br></p>
<h5 id="저급언어"><a href="#저급언어" class="headerlink" title="저급언어"></a>저급언어</h5><p>저급언어는 기계 중심의 언어라고 말할 수 있습니다. 기계가 직접 알아들을 수 있는 말로 프로그램 코드를 작성한다고 말할 수 있습니다. 컴퓨터는 전기로 동작합니다. 즉, 전기신호인 켜졌다(on)와 꺼졌다(off) 2가지 상태 값으로 동작한다고 말할 수 있습니다. 보통 숫자로 표현하면 켜졌다는 1, 꺼졌다는 0을 의미합니다. 0과 1로 표현되는 숫자를 우리는 2진수라고 말합니다. 2진수로 이뤄진 값으로 작성하는 프로그래밍 언어를 기계어(Machine Language)라고 말합니다. 숫자로만 되어 있기 때문에 유지보수도 굉장히 어렵습니다. 숫자로만 된 프로그래밍 언어는 사용이 굉장히 어려웠습니다. 그래서, 이 숫자로 된 문장과 1:1로 대응하는 기호를 만들고, 그 기호로 프로그래밍을 하게 되었습니다. 단 기호로 작성된 프로그램은 기계가 바로 알아들을 수 없기 때문에 기호로 작성된 문장들을 원래의 숫자로 바꿔야 하는 과정이 더 필요하게 되었습니다. 이러한 과정에서 사용되는 도구를 컴파일러(Compiler)라고 말하며, 이러한 기호로 작성된 언어를 어셈블리어(Assembly Language)라고 말합니다. 현재는 아주 특수한 경우를 제외하고는 기계어와 어셈블리어로 프로그램을 개발하는 경우는 거의 없습니다. 그만큼 프로그래밍이 어렵고 유지보수가 어렵기 때문입니다.</p>
<p><br></br></p>
<h5 id="고급언어"><a href="#고급언어" class="headerlink" title="고급언어"></a>고급언어</h5><p>고급언어는 사람 중심의 언어라고 말할 수 있습니다. 사람이 좀 더 이해하기 쉬운 문법으로 프로그래밍을 할 수 있습니다. 이런 일이 가능하기 위해선 작성된 소스코드를 번역하는 과정이 필요합니다. 이를 컴파일한다고 말하며, 이러한 일을 수행하는 것을 컴파일러라고 말합니다. 앞에서 어셈블리어도 기계어로 컴파일이 된다고 말했었죠? 컴퓨터 성능이 좋아지고, 컴파일러와 관련된 기술이 발전하면서 사람 중심의 언어로 프로그래밍할 수 있다고 생각하면 됩니다. 이러한 고급 언어로는 다음과 같은 언어들이 있습니다.</p>
<p></p>

<ul>
<li><p>FORTRAN : 최고의 고급언어 중의 하나라고 말할 수 있으며, 과학 계산용으로 주로 사용됩니다. 현재 공대에서도 많이 사용되고 있습니다.</p>
</li>
<li><p>COBOL : FORTRAN과 더불어 역사가 오래된 언어입니다. 일반 업무에서 사용할 목적으로 만들어졌으며, 현재도 은행 등에서 사용되고 있습니다.</p>
</li>
<li><p>PROLOG : 논리형 프로그래밍 언어로써, 논리식을 토대로 오브젝트와 오브젝트 간의 관계에 관한 문제를 해결하기 위해 사용됩니다.</p>
</li>
<li><p>C : 1972년 미국 벨 연구소의 데니스 리치에 의해 개발된 고급 언어로써 시스템 프로그래밍에 가장 적합한 평가를 받는 언어입니다.</p>
</li>
<li><p>Erlang : 스웨덴의 에릭슨에서 개발한 함수형 병행성 프로그래밍 언어이며 통신 인프라를 위한 언어입니다.</p>
</li>
<li><p>Lisp : LISt Processor의 약자로써 대표적인 함수형 언어입니다. 프로그래밍 언어의 역사를 말할 때, 현대의 컴퓨터를 위해 등장한 고급 언어 중 가장 오래된 것이 포트란이고, 두 번째로 오래된 것이 바로 이 리스프입니다. </p>
</li>
<li><p>Swift : 2014년 WWDC(Apple WorldWide Developers Conference)에서 공개한 프로그래밍 언어입니다. 최근에 만들어진 언어로 현대 프로그래밍 언어의 발전을 대다수 계승한 모던 프로그래밍 언어라고 말할 수 있습니다.</p>
</li>
<li><p>Kotlin : IntelliJ IDEA의 개발사 JetBrains에서 2011년에 개발한 프로그래밍 언어입니다. JVM기반의 언어이며 Java와의 상호 운영이 100% 지원됩니다. Swift와 마찬가지로 현대 프로그래밍 언어의 발전을 대다수 계승한 모던 프로그래밍 언어라 말할 수 있습니다.</p>
</li>
<li><p>Clojure : 클로저는 리치 히키가 만든 리스프 프로그래밍 언어의 방언으로서, 범용 함수형 언어입니다.</p>
</li>
<li><p>Python : 프로그래밍 입문자가 읽기 쉽고 적은 코드를 사용하여 프로그램을 개발할 수 있습니다. 많은 사람에게 추천되는 언어이며, 데이터 과학에서도 자주 사용되며 웹사이트 개발에서도 많이 사용되고 있습니다. 최근 python은 ML(Machine Learning)에서도 많이 사용됩니다.</p>
</li>
<li><p>JAVA : 1995년 썬 마이크로 시스템즈에서 개발한 객체지향 프로그래밍 언어입니다. 거의 매년 세계에서 가장 많이 사용되는 인기 1등을 차지하고 있습니다.</p>
</li>
</ul>
<p><br></br><br></p>
<h4 id="2-웹의-동작-HTTP-프로토콜-이해"><a href="#2-웹의-동작-HTTP-프로토콜-이해" class="headerlink" title="2) 웹의 동작 (HTTP 프로토콜 이해)"></a>2) 웹의 동작 (HTTP 프로토콜 이해)</h4><p><br></br></p>
<h5 id="학습목표-1"><a href="#학습목표-1" class="headerlink" title="학습목표"></a>학습목표</h5><ol>
<li>HTTP 프로토콜의 작동방식에 대하여 알아봅시다.</li>
<li>HTTP 프로토콜의 요청/응답 데이터 포맷에 대하여 알아봅시다.</li>
</ol>
<p><br></br></p>
<h5 id="HTTP-작동방식"><a href="#HTTP-작동방식" class="headerlink" title="HTTP 작동방식"></a>HTTP 작동방식</h5><ul>
<li>HTTP는 서버/클라이언트 모델을 따릅니다.</li>
<li><p>장점</p>
<ul>
<li>불특정 다수를 대상으로 하는 서비스에는 적합하다.</li>
<li>클라이언트와 서버가 계속 연결된 형태가 아니기 때문에 클라이언트와 서버 간의 최대 연결 수보다 훨씬 많은 요청과 응답을 처리할 수 있다.</li>
</ul>
</li>
<li><p>단점</p>
<ul>
<li>연결을 끊어버리기 때문에, 클라이언트의 이전 상황을 알 수가 없다.</li>
<li>이러한 특징을 무상태(stateless)라고 말한다.</li>
<li>이러한 특징 때문에 정보를 유지하기 위해서 cookie와 같은 기술이 등장하게 되었다.</li>
</ul>
</li>
</ul>
<p><br></br></p>
<h5 id="URI-Uniform-Resource-Locator"><a href="#URI-Uniform-Resource-Locator" class="headerlink" title="URI(Uniform Resource Locator)"></a>URI(Uniform Resource Locator)</h5><ul>
<li>인터넷 상의 자원의 위치</li>
<li>특정 웹 서버의 특정 파일에 접근하기 위한 경로 혹은 주소</li>
</ul>
<p><br></br></p>
<h5 id="HTTP-Hypertext-Transfer-Protocol"><a href="#HTTP-Hypertext-Transfer-Protocol" class="headerlink" title="HTTP(Hypertext Transfer Protocol)"></a>HTTP(Hypertext Transfer Protocol)</h5><ul>
<li>요청 메서드: GET, PUT, POST, PUSH, OPTIONS 등의 요청 방식이 온다.</li>
<li>요청 URI : 요청하는 자원의 위치를 명시한다.</li>
<li>HTTP 프로토콜 버전 : 웹 브라우저가 사용하는 프로토콜 버전이다.</li>
</ul>
<p></p>

<ul>
<li>GET : 정보를 요청하기 위해서 사용한다. (SELECT)</li>
<li>POST : 정보를 밀어넣기 위해서 사용한다. (INSERT)</li>
<li>PUT : 정보를 업데이트하기 위해서 사용한다. (UPDATE)</li>
<li>DELETE : 정보를 삭제하기 위해서 사용한다. (DELETE)</li>
<li>HEAD : (HTTP)헤더 정보만 요청한다. 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인하기 위해서 사용한다.</li>
<li>OPTIONS : 웹서버가 지원하는 메서드의 종류를 요청한다.</li>
<li>TRACE : 클라이언트의 요청을 그대로 반환한다. 예컨대 echo 서비스로 서버 상태를 확인하기 위한 목적으로 주로 사용한다.</li>
</ul>
<p><br></br><br></p>
<h4 id="3-웹-Front-End와-웹-Back-End"><a href="#3-웹-Front-End와-웹-Back-End" class="headerlink" title="3) 웹 Front-End와 웹 Back-End"></a>3) 웹 Front-End와 웹 Back-End</h4><p><br></br></p>
<h5 id="학습목표-2"><a href="#학습목표-2" class="headerlink" title="학습목표"></a>학습목표</h5><ol>
<li>웹프론트엔드에 대한 역할과 기술적 구성</li>
<li>웹백엔드에 대한 역할과 기술적 구성</li>
</ol>
<p><br></br><br></p>
<h4 id="4-브라우저의-동작"><a href="#4-브라우저의-동작" class="headerlink" title="4) 브라우저의 동작"></a>4) 브라우저의 동작</h4><p>웹을 통해서 전달되는 데이터는 어딘가에서 해석돼야 합니다. 서버에서 전송한 HTML과 같은 데이터가 클라이언트에 도착해야 할 곳은 브라우저입니다. 브라우저에는 데이터를 해석해주는 파서와 데이터를 화면에 표현해주는 렌더링엔진이 포함되어 있습니다. 이런 작업의 대부분은 브라우저 내부에서 이뤄지기 때문에 반드시 알아야 하는 것은 아닙니다. 하지만 브라우저의 내부를 이해하면 웹 개발을 하면서 맞닥뜨리는 난해한 문제를 해결할 수 있고, 보다 최적화된 웹개발을 할 수 있습니다.</p>
<p><br></br></p>
<h5 id="학습목표-3"><a href="#학습목표-3" class="headerlink" title="학습목표"></a>학습목표</h5><ol>
<li>HTML 파일이 올 때 브라우저가 어떻게 렌더링과정을 거쳐서 화면에 보이게 되는지 간단히 이해한다.</li>
</ol>
<p><br></br></p>
<p>브라우저는 월드와이드웹(WWW)에서 정보를 검색, 표현하고 탐색하기 위한 소프트웨어입니다. 인터넷에서 특정 정보로 이동할 수 있는 주소 입력창이 있고 서버와 HTTP로 정보를 주고 받을 수 있는 네트워크 모듈도 포함하고 있습니다. 그리고 서버에서 받은 문서(HTML, CSS, Javascript)를 해석하고 실행하여 화면에 표현하기 위한 해석기(Parser)들을 가지고 있습니다. 브라우저마다 서로 다른 엔진을 포함하고 있습니다.</p>
<p></p>

<p>HTML을 해석하기 위해서 DOM Tree를 만들고, CSS를 해석해서 역시 CSS Tree(CSS Object Model)을 만듭니다. 이 과정에서 Parsing 과정이 필요하며 토큰 단위로 해석되는 방식은 일반적인 소스코드의 컴파일 과정이라고 보시면 됩니다. DOM Tree와 CSS Tree, 이 두 개는 연관되어 있으므로 Render Tree로 다시 조합됩니다. 이렇게 조합된 결과는 화면에 어떻게 배치할지 크기와 위치 정보를 담고 있습니다. 이후에 이렇게 구성된 Render Tree 정보를 통해서 화면에 어떤 부분에 어떻게 색칠을 할지 Painting 과정을 거치게 됩니다.</p>
<p><br></br><br></p>
<h4 id="5-브라우저에서의-웹-개발"><a href="#5-브라우저에서의-웹-개발" class="headerlink" title="5) 브라우저에서의 웹 개발"></a>5) 브라우저에서의 웹 개발</h4><p>웹 클라이언트 코드는 브라우저 안에서 동작합니다.</p>
<p><br></br></p>
<h5 id="학습목표-4"><a href="#학습목표-4" class="headerlink" title="학습목표"></a>학습목표</h5><ol>
<li>HTML 요청 이후 브라우저에서 해석되는 웹페이지 안의 내용구성과 소스코드를 어떻게 위치시키면될지 이해한다.</li>
</ol>
<p><br></br></p>
<h5 id="알게-된-몇-가지-특징"><a href="#알게-된-몇-가지-특징" class="headerlink" title="알게 된 몇 가지 특징"></a>알게 된 몇 가지 특징</h5><ul>
<li>HTML문서는 html이라는 태그로 시작해서 html태그로 끝난다.</li>
<li>head는 무엇을 하는걸까?</li>
<li>body는?</li>
<li>HTML은 계층적이다!</li>
<li>HTML은 tag를 사용해서 표현한다.</li>
<li>JavaScript와 CSS가 html 안에 여기저기 존재한다.</li>
</ul>
<p><br></br></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width-device=width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Boostcourse<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      div&#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">      alert(1)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    alert(2)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p></p>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width-device=width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Boostcourse<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>웹프론트엔드<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p></p>

<h6 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"main.js 코드입니다."</span>)</span><br></pre></td></tr></table></figure>
<p></p>

<p>HTML 문서 안에 HTML 태그뿐 아니라 CSS, JavaScript 코드가 존재합니다.<br>JavaScript 코드는 body 태그가 닫히기 전에 위치하는 것이 랜더링을 방해하지 않아 좋고, CSS 코드는 head 안에 위치해서 렌더링 처리 시에 브라우저가 더 빨리 참고할 수 있게 하는 것이 좋습니다.</p>
<p><br></br><br></p>
<h4 id="6-웹-서버"><a href="#6-웹-서버" class="headerlink" title="6) 웹 서버"></a>6) 웹 서버</h4><p>웹 브라우저를 실행한 후 주소 입력창에 URL 주소를 입력하면, 그 URL 주소에 해당하는 결과물이 화면에 보입니다. 우리가 현실에서 주소를 보고 집을 찾아가는 것처럼, 웹브라우저는 URL 주소에 해당하는 웹서버에 연결하고, 해당 주소에서 볼 수 있는 내용을 읽어 들여 보여주게 됩니다. 웹 브라우저의 요청을 받아 HTML 문서나 오브젝트를 반환하는 웹 서버에 대하여 알아보도록 하겠습니다.</p>
<p><br></br></p>
<h5 id="웹-서버란"><a href="#웹-서버란" class="headerlink" title="웹 서버란?"></a>웹 서버란?</h5><ul>
<li>웹 서버는 소프트웨어를 보통 말하지만, 웹 서버 소프트웨어가 동작하는 컴퓨터를 말한다.</li>
<li>웹 서버의 가장 중요한 기능은 클라이언트가 요청하는 HTML문서나 각종 리소스를 전달하는 것입니다.</li>
<li>웹 브라우저나 웹 크롤러가 요청하는 리소스는 컴퓨터에 저장되어 있는 정적(static)인 데이터이거나 동적인 결과가 될 수 있다.</li>
</ul>
<p><br></br></p>
<p>웹 브라우저는 웹 서버로부터 전송받은 HTML 문서를 읽어들인 후에 해석을 합니다. HTML 문서를 알맞게 보여주기 위해서 필요한 이미지, CSS, JavaScript와 같은 리소들에 대해서 URL을 추출합니다. 웹 서버에게 동시에 여러 개의 리소스를 요청하게 됩니다. 웹 서버는 동시에 요청한 여러 개의 요청을 받아들여 그 결과를 브라우저에게 전송합니다. 웹 브라우저는 아까 해석했던 HTML 문서와 읽어들인 여러 개의 응답을 하나로 합쳐 그 결과를 화면에 보이게 하는 겁니다.</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/14/fnlp-%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC-1/">
                [FNLP] 밑바닥부터 시작하는 자연어처리 (1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-14</span>
            
            
            
                <span class="category">
                    <a href="/categories/natural-language-processing/">Natural Language Processing</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="한국어-임베딩-서론"><a href="#한국어-임베딩-서론" class="headerlink" title="한국어 임베딩: 서론"></a>한국어 임베딩: 서론</h1><h6 id="본-포스팅은-“한국어-임베딩-이기창-”을-바탕으로-“밑바닥부터-시작하는-딥러-2-사이토-고키-”를-추가하여-정리한-내용입니다"><a href="#본-포스팅은-“한국어-임베딩-이기창-”을-바탕으로-“밑바닥부터-시작하는-딥러-2-사이토-고키-”를-추가하여-정리한-내용입니다" class="headerlink" title="본 포스팅은 “한국어 임베딩(이기창)”을 바탕으로 “밑바닥부터 시작하는 딥러 2(사이토 고키)”를 추가하여 정리한 내용입니다."></a>본 포스팅은 “한국어 임베딩(이기창)”을 바탕으로 “밑바닥부터 시작하는 딥러 2(사이토 고키)”를 추가하여 정리한 내용입니다.</h6><p><br></br></p>
<h4 id="한국어-임베딩"><a href="#한국어-임베딩" class="headerlink" title="한국어 임베딩"></a>한국어 임베딩</h4><p></p>

<h5 id="01-서론"><a href="#01-서론" class="headerlink" title="01 서론"></a>01 서론</h5><p></p>

<p>1.1 임베딩이란<br>1.2 임베딩의 역할</p>
<ul>
<li>단어/문장 간 관련도 계산</li>
<li>의미/문법 정보 함축</li>
<li>전이 학습<br>1.3 임베딩 기법의 역사와 종류</li>
<li>통계 기반에서 뉴럴 네트워크 기반으로</li>
<li>단어 수준에서 문장 수준으로</li>
<li>룰, 엔드투엔드, 프리트레인/파인 튜닝</li>
<li>임베딩의 종류와 성능</li>
</ul>
<p><br></br></p>
<h4 id="밑바닥부터-시작하는-딥러닝-2"><a href="#밑바닥부터-시작하는-딥러닝-2" class="headerlink" title="밑바닥부터 시작하는 딥러닝 2"></a>밑바닥부터 시작하는 딥러닝 2</h4><p></p>

<h5 id="CHAPTER-2-자연어와-단어의-분산-표현"><a href="#CHAPTER-2-자연어와-단어의-분산-표현" class="headerlink" title="CHAPTER 2 자연어와 단어의 분산 표현"></a>CHAPTER 2 자연어와 단어의 분산 표현</h5><p>2.1 자연어 처리란<br>2.2 시소러스</p>
<ul>
<li>WordNet</li>
<li>시소러스의 문제점<br>2.3 통계 기반 기법</li>
<li>파이썬으로 말뭉치 전처리하기</li>
<li>단어의 분산 표현</li>
<li>분포 가설</li>
<li>동시발생 행렬</li>
<li>벡터 간 유사도</li>
<li>유사 단어의 랭킹 표시</li>
</ul>
<p>2.4 통계 기반 기법 개선하기</p>
<ul>
<li>상호정보량</li>
<li>차원 감소</li>
<li>SVD에 의한 차원 감소</li>
<li>PTB 데이터셋</li>
<li>PTB 데이터셋 평가</li>
</ul>
<p><br></br></p>
<p><hr><br><br></br></p>
<h4 id="임베딩이란"><a href="#임베딩이란" class="headerlink" title="임베딩이란"></a>임베딩이란</h4><p></p>

<p>기계 번역, 요약, 문장 자동 생성이 화제다. 컴퓨터가 사람 말을 알아듣고 사람처럼 을 쓸 수 있다는 사실에 각계에서 주목하고 있다. 대규모 말뭉치로 잘 학습된 딥러닝 모델은 긴 문서를 잘 요약하고 그럴듯한 문장을 만들어낸다.</p>
<p></p>

<p>하지만 컴퓨터는 어디까지나 빠르고 효율적인 ‘계산기’일 뿐이다. 한마디로 컴퓨터는 인간이 사용하는 자연어를 있는 그대로 이해하는 것이 아니라 숫자(로 변형된 말이나 글)을 계산한다는 이야기다. 기계의 자연어 이해와 생성은 연산(computation)이나 처(processing)의 영역이다.</p>
<p></p>

<p>그렇다면 제기할 수 있는 질문이 몇 가지 있다. 표현력이 무한한 언어를 컴퓨터가 연할 수 있는 숫자로 바꿀 수는 있는 걸까? 만약 그럴 수 있다면 말과 글을 숫자로 변할 때 어떤 정보를 함축시킬 것인가? 정보 압축 과정에서 손실이 발생하지는 않을까? 그 손실은 어떻게 줄일 수 있을까?</p>
<p></p>

<p>자연어 처리 분야에서 임베딩(embedding)이란, 사람이 쓰는 자연어를 기계가 이해할  있는 숫자의 나열인 벡터로 바꾼 결과 혹은 그 일련의 과정 전체를 의미한다. 단어 문장 각각을 벡터로 변환해 벡터 공간으로 ‘끼워 넣는다(embed)’는 의미에서 임베딩이라는 이름이 붙었다.</p>
<p></p>

<p>임베딩이라는 개념은 자연어 처리 분야에서 꽤 오래전부터 사용한 것으로 보인다. 하만 본격적으로 통용되기 시작한 것은 딥러닝의 대부 요슈아 벤지오 연구 팀이 A Neural Probablistic Language Model(2003)을 발표하고 나서부터다.</p>
<p></p>

<p>우리가 상상할 수 있는 가장 간단한 형태의 임베딩은 단어의 빈도를 그대로 벡터로 사용하는 것이다. 다음은 소설가 현진건이 1924년 발표한 &lt;운수 좋은 날&gt;, 주요섭의 1935년 작품 &lt;사랑 손님과 어머니&gt;, 이효석의 1936년 작품 &lt;메밀꽃 필 무렵&gt;, 황석영의 1973년 작품 &lt;삼포 가는 길&gt; 등 단편소설들의 단어별 빈도표다.</p>
<p><br></br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><center>구분</center></th>
<th style="text-align:center"><center>메밀꽃 필 무렵</center></th>
<th style="text-align:center"><center>운수 좋은 날</center></th>
<th style="text-align:center"><center>사랑 손님과 어머니</center></th>
<th style="text-align:center"><center>삼포 가는 길</center></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>기차</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">10</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center"><strong>막걸리</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"><strong>선술집</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p><br></br></p>
<p>위 표와 같은 빈도표를 단어-문서 행렬(Term-Document Matrix)이라고 부른다. 행은 단어, 열은 문서(여기서는 작품)에 대응한다. 참고로 위의 표를 만들 때 형태소 분석기 오픈소스인 은전한닢(Mecab)을 사용해 명사를 추출해 계산했다. 단어-문서 행렬을 축하는 방법은 4장에서 설명할 예정이다.</p>
<p></p>

<p>표에서 보면 운수 좋은 날이라는 문서의 임베딩은 [2, 1, 1]이다. 막걸리라는 단어의 임베딩은 [0, 1, 0, 0]이다. 단어-문서 행렬을 보면 사랑 손님과 어머니, 삼포 가는 이 사용하는 단어 목록이 상대적으로 많이 겹치고 있는 것을 알 수 있다. 이를 바탕로 우리는 사랑 손님과 어머니는 삼포 가는 길과 기차라는 소재를 공유한다는 점에서 비슷한 작품일 것이라는 추정을 해볼 수 있다. 또 막걸리라는 단어와 선술집이라는 어가 운수 좋은 날이라는 작품에만 등장한 것을 알 수 있다. 이를 바탕으로 막걸리-술집 간 의미 차이가 막걸리-기차보다 작을 것이라고 추정해볼 수 있다.</p>
<p><br></br><br></p>
<h4 id="단어의-의미"><a href="#단어의-의미" class="headerlink" title="단어의 의미"></a>단어의 의미</h4><p>우리의 말은 ‘문자’로 구성되며, 말의 의미는 ‘단어’로 구성된다. 단어는 말하자면 의미의 최소 단위인 셈이다. 그래서 자연어를 컴퓨터에게 이해시키는 데는 무엇보다 ‘단어의 의미’를 이해시키는 게 중요하다. 이번 장의 주제는 컴퓨터에게 ‘단어의 의미’ 해시키기이다. 더 정확히 말하면 ‘단어의 의미’를 잘 파악하는 표현 방법에 관해 생해본다. 구체적으로 이번 장과 다음 장에서 다음의 세 가지 기법을 살펴보겠다.</p>
<p></p>

<ul>
<li>시소러스를 활용한 기법</li>
<li>통계 기반 기법</li>
<li>추론 기반 기법(Word2Vec)</li>
</ul>
<p></p>

<p>가장 먼저, 사람의 손으로 만든 시소러스(유의어 사전)을 이용하는 방법을 간단히 살펴보자. 그런 다음 통계 정보로부터 단어를 표현하는 ‘통계 기반 기법’을 설명한다. 여기까지가 이번 장에서 배우는 내용으로, 그 뒤를 이어 다음 장에서는 신경망을 활요한 ‘추론 기반’ 기법(구체적으로는 Word2Vec)을 다룬다.</p>
<p><br><br></p>
<h4 id="시소러스"><a href="#시소러스" class="headerlink" title="시소러스"></a>시소러스</h4><p>‘단어의 의미’를 나타내는 방법으로는 먼저 사람이 직접 단어의 의미를 정의하는 방식을 생각할 수 있다. 그중 한 방법으로 표준국어대사전처럼 각각의 단어에 그 의미를 설명해 넣을 수 있을 것이다. 예컨대 표준국어대사전에서 자동차라는 단어를 찾으면 원동기를 장치하여 그 동력으로 바퀴를 굴려서 철길이나 가설된 선에 의하지 아니하고 땅 위를 움직이도록 맍든 차라는 설명이 나온다. 이런 식으로 단어들을 정의해두면 컴퓨터도 단어의 의미를 이해할 수 있을지 모른다.</p>
<p></p>

<p>자연어 처리의 역사를 되돌아보면 단어의 의미를 인력을 동원해 정의하려는 시도는 수없이 있어왔다. 단, 표준국어대사전 같이 사람이 이용하는 일반적인 사전이 아니라 시소러스 형태의 사전을 애용했다. 시소러스란 (기본적으로는) 유의어 사전으로, ‘뜻이 같은 단어(동의어)’나 ‘뜻이 비슷한 단어(유의어)’가 한 그룹으로 분류되어 있다.</p>
<p></p>

<p>또한 자연어 처리에 이용되는 시소러스에서는 단어 사이의 ‘상위와 하위’ 혹은 ‘전체와 부분’ 등, 더 세세한 관계까지 정의해둔 경우가 있다. 아래의 예처럼 각 단어의 관계를 그래프 구조로 정의한다.</p>
<p></p>

<p><img src="/image/fnlp1.jpeg" alt="fnlp1"></p>
<p></p>

<p>위 그림에서는 car의 상위 개념으로 motor vehicle이라는 단어가 존재한다. 한편 car의 하위 개념으로는 SUV, compact, hatch-back 등 더 구체적인 차종이 있음을 알려준다. 이처럼 모든 단어에 대한 유의어 집합을 만든 다음, 단어들의 관계를 그래프로 표현하여 단어 사이의 연결을 정의할 수 있다. 그러면 이 ‘단어 네트워크’를 이용하여 컴퓨터에게 단어 사이의 관계를 가르칠 수 있다. 이 정도면 컴퓨터에게 단어의 의미를 (간접적으로라도) 이해시켰다고 주장할 수 있을 것이다. 그리고 그 지식을 이용하면 우리에게 유용한 일들을 컴퓨터가 수행하도록 할 수 있을 것이다.</p>
<p></p>

<p>시소러스를 어떻게 사용하는가는 자연어 처리 애플리케이션에 따라 다르다. 검색 엔진을 예로 생각해보면 automobile과 car가 유의어임을 알고 있으면 car의 검색 결과에 automobile의 검색 결과도 포함시켜주면 좋을 것이다.</p>
<p><br><br></p>
<h4 id="WordNet"><a href="#WordNet" class="headerlink" title="WordNet"></a>WordNet</h4><p>자연어 처리 분야에서 가장 유명한 시소러스는 WordNet이다. 이를 사용하면 유의어를 얻거나 ‘단어 네트워크’를 이용할 수 있다. 또한 단어 네트워크를 사용해 단어 사이의 유사도를 구할 수도 있다. 이 포스팅에서는 WordNet을 자세히 설명하지는 않겠다.</p>
<p><br></br></p>
<h4 id="시소러스의-문제점"><a href="#시소러스의-문제점" class="headerlink" title="시소러스의 문제점"></a>시소러스의 문제점</h4><p>WordNet과 같은 시소러스에는 수많은 단어에 대한 동의어와 계층 구조 등의 관계가 정의돼있다. 그리고 이 지식을 이용하면 ‘단어의 의미’를 (간접적으로라도) 컴퓨터에 전달할 수 있다. 하지만 이처럼 사람이 수작업으로 레이블링하는 방식에는 크나큰 결점이 존재한다. 다음은 시소러스 방식의 대표적인 문제점들이다.</p>
<ul>
<li>시대 변화에 대응하기 어렵다.</li>
<li>사람을 쓰는 비용은 크다.</li>
<li>단어의 미묘한 차이를 표현할 수 없다.</li>
</ul>
<p>이처럼 시소러스를 사용하는 기법(단어의 의미를 사람이 정의하는 기법)에는 커다란 문제가 있다. 이 문제를 피하기 위해, 곧이어 ‘통계 기반 기법’과 신경망을 사용한 ‘추론 기반 기법’을 알아볼 것이다. 이 두 기법에서는 대량의 텍스트 데이터로부터 ‘단어의 의미’를 자동적으로 추출한다. 그 덕분에 사람은 손수 단어를 연결짓는 중노동에서 해방되는 것이다.</p>
<p><br><br></p>
<h4 id="통계-기반-기법"><a href="#통계-기반-기법" class="headerlink" title="통계 기반 기법"></a>통계 기반 기법</h4><p>이제부터 통계 기반 기법을 살펴보면서 우리는 말뭉치(corpus)를 이용할 것이다. 말뭉치란 간단히 말하면 대량의 텍스트 데이터이다. 다만 맹목적으로 수집된 텍스트 데이터가 아닌 자연어 처리 연구가 애플리케이션을 염두에 두고 수집된 텍스트 데이터를 일반적으로 말뭉치라고 한다.</p>
<p></p>

<p>결국 말뭉치란 텍스트 데이터에 지나지 않다. 그 안에 담긴 문장들은 사람이 쓴 글이다. 다른 시각에서 생각해보면, 말뭉치에는 자연어에 대한 사람의 ‘지식’이 충분히 담겨 있다고 볼 수 있다. 문장을 쓰는 방법, 단어를 선택하는 방법, 단어의 의미 등 사람이 알고 있는 자연어에 대한 지식이 포함되어 있는 것이다. 통계 기반 기법의 목표는 이처럼 사람의 지식으로 가득한 말뭉치에사 자동으로, 그리고 효율적으로 그 핵심을 추출하는 것이다.</p>
<p></p>

<p>자연어 처리에 사용되는 말뭉치에는 텍스트 데이터에 대한 추가 정보가 포함되는 경우가 있다. 예컨대 텍스트 데이터의 단어 각각에 ‘품사’가 레이블링 될 수 있다. 이럴 경우 말뭉치는 컴퓨터가 다루기 쉬운 형태(트리 구조 등)로 가공되어 주어지는 것이 일반적이다. 본 포스팅에서는 이러한 추가 레이블을 이용하지 않고, 단순한 텍스트 데이터(하나의 큰 텍스트 파일)로 주어졌다고 가정한다.</p>
<p><br><br></p>
<h4 id="파이썬으로-말뭉치-전처리하기"><a href="#파이썬으로-말뭉치-전처리하기" class="headerlink" title="파이썬으로 말뭉치 전처리하기"></a>파이썬으로 말뭉치 전처리하기</h4><p>자연어 처리에는 다양한 말뭉치가 사용된다. 유명한 것으로는 위키백과와 구글 뉴스 등의 텍스트 데이터를 들 수 있다. 또한 셰익스피어나 나쓰메 소세키 같은 대문호의 작품들도 말뭉치로 이용된다. 이번 장에서는 우선 문장 하나로 이뤄진 단순한 텍스트를 사용한다. 그런 후에 더 실용적인 말뭉치도 다뤄보겠다.</p>
<p></p>

<p>그러면 파이썬을 이용하여 매우 작은 텍스트 데이터(말뭉치)에 전처리를 해보자. 여기서 말하는 전처리란 텍스트 데이터를 단어로 분할하고 그 분할된 단어들을 단어 ID 목록으로 변환하는 일이다.</p>
<p></p>

<p>그럼 하나씩 확인하면서 단계별로 진행해보자. 이번 절에서는 이처럼 문장 하나로 이뤄진 텍스트를 말뭉치로 이용한다. 실전이라면 이 text에 수천, 수만 개가 넘는 문장이 (연이어) 담겨 있을 것이다. 하지만 지금은 쉽게 설명하기 위해 이 작은 텍스트 데이터만으로 전처리를 수행하겠다. 그럼 이 text를 단어 단위로 분할하자.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">"You say goodbye and I say hello."</span></span><br><span class="line"></span><br><span class="line">text = text.lower()</span><br><span class="line">text = text.replace(<span class="string">'.'</span>, <span class="string">' .'</span>)</span><br><span class="line">print(text)</span><br><span class="line"></span><br><span class="line">words = text.split(<span class="string">' '</span>)</span><br><span class="line">print(words)</span><br></pre></td></tr></table></figure>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line">you say goodbye <span class="keyword">and</span> i say hello .</span><br><span class="line">[<span class="string">'you'</span>, <span class="string">'say'</span>, <span class="string">'goodbye'</span>, <span class="string">'and'</span>, <span class="string">'i'</span>, <span class="string">'say'</span>, <span class="string">'hello'</span>, <span class="string">'.'</span>]</span><br></pre></td></tr></table></figure>
<p></p>

<p>가장 먼저 lower() 메서드를 사용해 모든 문자를 소문자로 변환한다. 문장 첫머리의 대문자로 시작하는 단어도 소문자 단어와 똑같이 취급하기 위한 조치이다. 그리고 split(‘ ‘)메서드를 호출해 공백을 기준으로 분할한다. 다만 여기에서는 문장 끝의 마침표(.)를 고려해 마침표 앞에 공백을 삽입한 다음 분할을 수행하였다.</p>
<p></p>

<p>여기에서 단어를 분할할 때 마침효 앞에 공백을 넣는 임시변통을 적용했지만, 더 현명하고 범용적인 방법이 있다. 바로 정규표현식을 이용하는 방법이다. 예를 들어 정규표현식 모듈인 re를 임포트하고 re.split(‘(\W+)?’.text)라고 호출하면 단어 단위로 분할할 수 있다.</p>
<p></p>

<p>이제 원래의 문장을 단어 목록 형태로 이용할 수 있게 되었다. 단어 단위로 분할되어 다루기가 쉬워진 것을 사실이지만, 단어를 텍스트 그대로 조작하기란 여러 면에서 불편하다. 그래서 단어에 ID를 부여하고, ID의 리스트로 이용할 수 있도록 한 번 더 손질한다. 이를 위한 사전 준비로, 파이썬의 딕셔너리를 이용하여 단어 ID와 단어를 짝지어주는 대응표를 작성한다.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">word_to_id = &#123;&#125;</span><br><span class="line">id_to_word = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> word_to_id:</span><br><span class="line">        new_id = len(word_to_id)</span><br><span class="line">        word_to_id[word] = new_id</span><br><span class="line">        id_to_word[new_id] = word</span><br><span class="line"></span><br><span class="line">print(word_to_id)</span><br><span class="line">print(id_to_word)</span><br></pre></td></tr></table></figure>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">'you'</span>: <span class="number">0</span>, <span class="string">'say'</span>: <span class="number">1</span>, <span class="string">'goodbye'</span>: <span class="number">2</span>, <span class="string">'and'</span>: <span class="number">3</span>, <span class="string">'i'</span>: <span class="number">4</span>, <span class="string">'hello'</span>: <span class="number">5</span>, <span class="string">'.'</span>: <span class="number">6</span>&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'you'</span>, <span class="number">1</span>: <span class="string">'say'</span>, <span class="number">2</span>: <span class="string">'goodbye'</span>, <span class="number">3</span>: <span class="string">'and'</span>, <span class="number">4</span>: <span class="string">'i'</span>, <span class="number">5</span>: <span class="string">'hello'</span>, <span class="number">6</span>: <span class="string">'.'</span>&#125;</span><br></pre></td></tr></table></figure>
<p></p>

<p>단어 ID에서 단어로의 변환은 id_to_word가 담당하며(키가 단어 ID, 값이 단어), 단어에서 단어 ID로의 변환은 word_to_id가 담당한다. 앞의 코드는 단어 단위로 분할된 words의 각 원소를 처음부터 하나씩 살펴보면서, 단어가 word_to_id에 들어 있지 않으면 word_to_id와 id_to_word 각각에 새로운 ID와 단어를 추가한다. 또한 추가 시점의 딕셔너리 길이가 새로운 단어의 ID로 설정되기 때문에 단어 ID는 0, 1, 2, … 식으로 증가한다. 이처럼 딕셔너리를 사용하면 단어를 가지고 단어 ID를 검색하거나, 반대로 단어 ID를 가지고 단어를 검색할 수 있다.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(id_to_word[<span class="number">5</span>])</span><br><span class="line">print(word_to_id[<span class="string">'hello'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line">hello</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p></p>

<p>그럼 마지막으로 ‘단어 목록’을 ‘단어 ID 목록’으로 변경해보자. 다음 코드에서는 파이썬의 comprehension 표기를 사용하여 단어 목록에서 단어 ID 목록으로 변환한 다음, 다시 넘파이 배열로 변환하였다.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ids = []</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    ids.append(word_to_id[word])</span><br><span class="line">print(ids)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">corpus = [word_to_id[word] <span class="keyword">for</span> word <span class="keyword">in</span> words]</span><br><span class="line">print(corpus)</span><br><span class="line">corpus = np.array(corpus)</span><br><span class="line">print(corpus)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">5</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p></p>

<p>이것으로 말뭉치를 이용하기 위한 사전 준비를 마쳤다. 이상의 처리를 한 데 모아 preprocess()라는 함수로 구현해보자.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess</span><span class="params">(text)</span>:</span></span><br><span class="line">    text = text.lower()</span><br><span class="line">    text = text.replace(<span class="string">'.'</span>, <span class="string">' .'</span>)</span><br><span class="line">    words = text.split(<span class="string">' '</span>)</span><br><span class="line">    word_to_id = &#123;&#125;</span><br><span class="line">    id_to_word = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> word_to_id:</span><br><span class="line">            new_id = len(word_to_id)</span><br><span class="line">            word_to_id[word] = new_id</span><br><span class="line">            id_to_word[new_id] = word</span><br><span class="line">    corpus = np.array(word_to_id[word] <span class="keyword">for</span> word <span class="keyword">in</span> words)</span><br><span class="line">    <span class="keyword">return</span> corpus, word_to_id, id_to_word</span><br><span class="line"></span><br><span class="line">test = <span class="string">'I love you so much.'</span></span><br><span class="line">corpus, word_to_id, id_to_word = preprocess(test)</span><br><span class="line">print(corpus, word_to_id, id_to_word)</span><br></pre></td></tr></table></figure>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line">&lt;generator object preprocess.&lt;locals&gt;.&lt;genexpr&gt; at <span class="number">0x7fde7022a468</span>&gt;</span><br><span class="line">&#123;<span class="string">'i'</span>: <span class="number">0</span>, <span class="string">'love'</span>: <span class="number">1</span>, <span class="string">'you'</span>: <span class="number">2</span>, <span class="string">'so'</span>: <span class="number">3</span>, <span class="string">'much'</span>: <span class="number">4</span>, <span class="string">'.'</span>: <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'i'</span>, <span class="number">1</span>: <span class="string">'love'</span>, <span class="number">2</span>: <span class="string">'you'</span>, <span class="number">3</span>: <span class="string">'so'</span>, <span class="number">4</span>: <span class="string">'much'</span>, <span class="number">5</span>: <span class="string">'.'</span>&#125;</span><br></pre></td></tr></table></figure>
<p></p>

<p>이것으로 말뭉치 전처리가 끝났다. corpus는 단어 ID 목록, word_to_id는 단어에서 단어 ID로의 딕셔너리, id_to_word는 단어 ID에서 단어로 딕셔너리를 뜻한다. 이상으로 말뭉치를 다룰 준비를 마쳤다. 다음 목표는 말뭉치를 사용해 ‘단어의 의미’를 추출하는 것이다. 그 한 방법으로, 이번 절에서는 ‘통계 기반 기법’을 살펴보자. 이 기법을 사용해 우리는 단어를 벡터로 표현할 수 있게 될 것이다.</p>
<p><br></br><br></p>
<h4 id="단어의-분산-표현"><a href="#단어의-분산-표현" class="headerlink" title="단어의 분산 표현"></a>단어의 분산 표현</h4><p>뜬금없게 드릴겠지만, 세상은 다채로운 ‘색’으로 가득하다. 이러한 색들에는 ‘코발트블루’나 ‘싱크레드’ 같은 고유한 이름을 붙일 수도 있다. 한편, RGB라는 세 가지 성분이 어떤 비율로 섞여 있느냐로 표현하는 방법도 있다. 전자는 색의 가짓수만큼의 이름을 부여하는 한편, 후자는 색을 3차원의 벡터로 표현한다.</p>
<p></p>

<p>여기서 주목하고 싶은 점은 RGB 같은 벡터 표현이 색을 더 정확하게 명시할 수 있다는 사실이다. 게다가 모든 색을 단 3개의 성분으로 간결하게 표현할 수 있고, (많은 경우) 어떤 색인지 짐작하기도 쉽다. 예컨대 비색이라고 하면 어떤 색인지 몰라도, (R, G, B) = (170, 33, 22)라고 하면 빨강 계열의 색임을 알 수 있다. 또한 색끼리의 관련성(비슷한 색인지 여부 등)도 벡터 표현 쪽이 더 쉽게 판단할 수 있고, 정량화하기도 쉽다.</p>
<p></p>

<p>그러면 색을 벡터로 표현하듯 단어도 벡터로 표현할 수 있을까? (조금 어렵긴 하지만) 더 정확하게 말하자면, 간결하고 이치에 맞는 벡터 표현을 단어라는 영역에서도 구축할 수 있을까? 이제부터 우리가 원하는 것은 단어의 의미를 정확하게 파악할 수 있는 벡터 표현이다. 이를 자연어 처리 분야에서는 단어의 분산 표현(distributed representation)이라고 한다.</p>
<p></p>

<p>단어의 분산 표현은 단어를 고정 길이의 밀집벡터(dense vector)로 표현한다. 밀집벡터라 함은 대부분의 원소가 0이 아닌 실수인 벡터를 말한다. 예컨대 3차원의 분산 표현은 [0.21, -0.45, 0.83]과 같은 모습이 된다. 이러한 단어의 분산 표현을 어떻게 구축할 것인가가 앞으로 살펴볼 중요한 주제이다.</p>
<p><br></br><br></p>
<h4 id="분포-가설"><a href="#분포-가설" class="headerlink" title="분포 가설"></a>분포 가설</h4><p>자연어 처리의 역사에서 단어를 벡터로 표현하는 연구는 수없이 이뤄져 왔다. 그 연구들을 살펴보면, 중요한 기법의 거의 모두가 단 하나의 간단한 아이디어에 뿌리를 두고 있음을 알 수 있다. 그 아이디어는 바로 ‘단어의 의미는 주변 단어에 의해 형성된다’라는 것이다. 이를 분포 가설(distributional hypothesis)이라 하며, 단어를 벡터로 표현하는 최근 연구도 대부분 이 가설에 기초한다.</p>
<p></p>

<p>분포 가설이 말하고자 하는 바는 매우 간단하다. 단어 자체에는 의미가 없고, 그 단어가 사용된 맥락(context)이 의미를 형성한다는 것이다. 물론 의미가 같은 단어들은 같은 맥락에서 더 많이 등장한다. 예컨대 I drink beer와 We drink wine 처럼 drink 주변에는 음료가 등장하기 쉬울 것이다. 또 I guzzle beer와 We guzzle wine이라는 문장이 있다면, guzzle은 drink와 같은 맥락에서 사용됨을 알 수 있다. 그리고 guzzle과 drink는 가까운 의미의 단어라는 것도 알 수 있다.</p>
<p></p>

<p>앞으로는 맥락이라는 말을 자주 사용할 것이다. 이번 장에서 맥락이라 하면 (주목하는 단어) 주변에 놓인 단어를 가리킨다. 예컨대 아래 그림에서는 좌우의 각 두 단어씩이 맥락에 해당한다.</p>
<p></p>

<p><img src="/image/fnlp2.jpeg" alt="fnlp2"></p>
<p></p>

<p>위 그림처럼 ‘맥락’이란 특정 단어를 중심에 둔 그 주변 단어를 말한다. 그리고 맥락의 크기(주변 단어를 몇 개나 포함할지)를 ‘윈도우 크기(window size)’라고 한다. 윈도우 크기가 1이면 좌주 한 단어씩이, 윈도우 크기가 2이면 좌우 두 단어씩이 맥락에 포함된다.</p>
<p></p>

<p>여기에서는 좌우로 똑같은 수의 단어를 맥락으로 사용했다. 하지만 상황에 따라서는 왼쪽 단어만 또는 오른쪽 단어만을 사용하기도 하며, 문장의 시작과 끝을 고려할 수도 있다. 본 포스팅에서는 문장 구분은 고려하지 않고 좌우 동수인 맥락만을 취급한다.</p>
<p><br></br><br></p>
<h4 id="동시발생-행렬"><a href="#동시발생-행렬" class="headerlink" title="동시발생 행렬"></a>동시발생 행렬</h4><p>그러면 분포 가설에 기초해 단어를 벡터로 나타내는 방법을 생각해봅시다. 주변 단어를 ‘세어보는’ 방법이 자연스럽게 떠오를 것입니다. 무슨 말인고 하니, 어떤 단어에 주목했을 때, 그 주변에 어떤 단어가 몇 번이나 등장하는지를 세어 집계하는 방법이다. 이 책에서는 이를 통계기반 기법이라고 한다. 먼저 위에서 살펴보았던 파이썬으로 말뭉치 전처리하기 절에서 봤던 preprocess() 함수를 사용해 전처리하는 일부터 시작하자.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'..'</span>)</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> preprocess</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">text = <span class="string">'You say goodbye and I say hello.'</span></span><br><span class="line">corpus, word_to_id, id_to_word = preprocess(text)</span><br><span class="line"></span><br><span class="line">print(corpus)</span><br><span class="line"><span class="comment"># [0 1 2 3 4 1 5 6]</span></span><br><span class="line"></span><br><span class="line">print(id_to_word)</span><br><span class="line"><span class="comment"># &#123;0: 'you', 1: 'say', 2: 'goodbye', 3: 'and', 4: 'i', 5: 'hello', 6: '.'&#125;</span></span><br></pre></td></tr></table></figure>
<p></p>

<p>결과를 보면 단어 수가 총 7개임을 알 수 있다. 다음으로는 각 단어의 맥락에 해당하는 단어의 빈도를 세어보겠다. 윈도우 크기는 1로 하고, 단어 ID가 0인 you부터 시작해보자. you의 맥락은 say라는 단어 하나뿐이다. 단어 you의 맥락으로써 동시에 발생(등장)하는 단어의 빈도를 바탕으로 you라는 단어를 벡터로 표현하면 [0, 1, 0, 0, 0, 0, 0]와 같다. 계속해서 ID가 1인 say에 대해서도 같은 작업을 수행한다. 그 결과로부터 say라는 단어는 벡터 [1, 0, 1, 0, 1, 1, 0]으로 표현할 수 있다. 이상의 작업을 모든 단어(이번 예에서는 총 7개의 단어)에 대해서 수행한 결과가 아래와 같다.</p>
<p></p>

<p><img src="/image/fnlp3.jpeg" alt="fnlp3"></p>
<p></p>

<p>위 그림은 모든 단어에 대해 동시발생하는 단어를 표에 정리한 것이다. 이 표의 각 행은 해당 단어를 표현한 벡터가 된다. 참고로 이 표가 행렬의 형태를 띤다는 뜻에서 동시발생 행렬(co-occurrence matrix)라고 한다. 그럼 파이썬에서 그림 그대로를 손으로 입력해보겠다.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C = np.array([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">], dtype=np.int32)</span><br><span class="line"></span><br><span class="line">print(C[<span class="number">0</span>])  <span class="comment"># ID가 0인 단어의 벡터 표현</span></span><br><span class="line">print(C[<span class="number">4</span>])  <span class="comment"># ID가 4인 단어의 벡터 표현</span></span><br><span class="line">print(C[word_to_id[<span class="string">'goodbye'</span>]])  <span class="comment"># 'goodbye'의 벡터 표현</span></span><br></pre></td></tr></table></figure>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p></p>

<p>이와 같이 동시발생 행렬을 활용하면 단어를 벡터로 나타낼 수 있다. 이번에는 동시발생 행렬을 수동으로 만들었지만, 당연히 자동화할 수 있다. 그러면 말뭉치로부터 동시발생 행렬을 만들어주는 함수를 구현해보자. 함수 이름은 create_co_matrix(corpus, vocab_size, window_size=1)로 하자. 인수들은 차례로 단어 ID의 리스트, 어휘 수, 윈도우 크기를 나타낸다.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_co_matrix</span><span class="params">(corpus, vocab_size, window_size=<span class="number">1</span>)</span>:</span></span><br><span class="line">    corpus_size = len(corpus)  <span class="comment"># 문장길이</span></span><br><span class="line">    co_matrix = np.zeros((vocab_size, vocab_size), dtype=np.int32)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, word_id <span class="keyword">in</span> enumerate(corpus):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, window_size + <span class="number">1</span>):</span><br><span class="line">            left_idx = idx - <span class="number">1</span></span><br><span class="line">            right_idx = idx + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left_idx &gt;= <span class="number">0</span>:</span><br><span class="line">                co_matrix[word_id][corpus[left_idx]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right_idx &lt; corpus_size:</span><br><span class="line">                co_matrix[word_id][corpus[right_idx]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> co_matrix</span><br></pre></td></tr></table></figure>
<p><br></br><br></p>
<h4 id="벡터-간-유사도"><a href="#벡터-간-유사도" class="headerlink" title="벡터 간 유사도"></a>벡터 간 유사도</h4><p>앞에서 동시발생 행렬을 활용해 단어를 벡터로 표현하는 방법을 알아봤다. 그럼 계속해서 벡터 사이의 유사도를 측정하는 방법을 살펴보자. 벡터 사이의 유사도를 측정하는 방법은 다양하다. 대표적으로는 벡터의 내적이나 유클리드 거리 등을 꼽을 수 있다. 그 외에도 다양하지만, 단어 벡터의 유사도를 나타낼 때는 코사인 유사도를 자주 이용한다. 두 벡터 $\vec{x}\mathit{=(x_1, x_2, …, x_n)}$과 $\vec{y}\mathit{=(y_1, y_2, …, y_n)}$이 있다면, 코사인 유사도는 다음 식으로 정의됩니다.</p>
<p></p>

<script type="math/tex; mode=display">similarity( \vec{x}, \vec{y}) = {\vec{x} \cdot \vec{y}} \over {||\vec{x} ||\vec{y}||}</script><p></p>

<p>위 식의 분자에는 벡터의 내적이, 분모에는 각 벡터의 노름(norm)이 등장한다. 노름은 벡터의 크기를 나타낸 것으로, 여기에서는 벡터의 각 원소를 제곱해 더한 후 다시 제곱근을 구해 계산하는 L2 노름을 구한다. 이 식의 핵심은 벡터를 정규화하고 내적을 구하는 것이다. 코사인 유사도를 직관적으로 풀어보자면 두 벡터가 가리키는 방향이 얼마나 비슷한가이다. 두 벡터의 방향이 완전히 같다면 코사인 유사도가 1이 되며, 완전히 반대라면 -1이 된다.</p>
<p></p>

<p>이제 코사인 유사도를 파이썬 함수로 구현해보자.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cos_similarity</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    nx = x / np.sqrt(np.sum(x**<span class="number">2</span>))  <span class="comment"># x의 정규화</span></span><br><span class="line">    ny = y / np.sqrt(np.sum(y**<span class="number">2</span>))  <span class="comment"># y의 정규화</span></span><br><span class="line">    <span class="keyword">return</span> np.dot(nx, ny)</span><br></pre></td></tr></table></figure>
<p></p>

<p>이 코드에서 인수 x와 y는 넘파이 배열이라고 가정하자. 이 함수는 먼저 벡터 x와 y를 정규화한 후 두 벡터의 내적을 구했다. 이렇게만 해도 코사인 유사도를 구할 수 있지만, 사실 이 구현에는 문제가 하나 있다. 인수로 제로 벡터(원소가 모두 0인 벡터)가 들어오면 0으로 나누기 오류가 발생한다. 이 문제를 해결하는 전통적인 방법은 나눌 때 분모에 작은 값을 더해주는 것이다. 작은 값을 뜻하는 eps를 인수로 받도록 하고, 이 인수의 값을 지정하지 않으면 기본값으로 1e-8(0.00000001)이 설정되도록 수정하겠다. 이제 개선된 코드를 보자.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cos_similarity</span><span class="params">(x, y, eps=<span class="number">1e-8</span>)</span>:</span></span><br><span class="line">    nx = x / np.sqrt(np.sum(x**<span class="number">2</span>) + eps)  <span class="comment"># x의 정규화</span></span><br><span class="line">    ny = y / np.sqrt(np.sum(y**<span class="number">2</span>) + eps)  <span class="comment"># y의 정규화</span></span><br><span class="line">    <span class="keyword">return</span> np.dot(nx, ny)</span><br></pre></td></tr></table></figure>
<p></p>

<p>여기에서는 작은 값으로 1e-8을 사용했는데, 이 정도 작은 값이면 일반적으로 부동소수점 계산 시 반올림되어 다른 값에 흡수된다. 앞의 구현에서는 이 값이 벡터의 노름에 흡수되기 때문에 대부분의 경우 eps를 더한다고 해서 최종 계산 결과에는 영향을 주지 않는다. 한편 벡터의 노름이 0일 때는 이 작은 값이 그대로 유지되어 0으로 나누기 오류가 나는 사태를 막아준다.</p>
<p></p>

<p>이 함수를 사용하면 단어 벡터의 유사도를 다음과 같이 구할 수 있다. 다음은 you와 i의 유사도를 구하는 코드이다.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T = create_co_matrix(corpus, vocab_size)</span><br><span class="line"></span><br><span class="line">t0 = T[word_to_id[<span class="string">'you'</span>]]  <span class="comment"># you의 단어 벡터</span></span><br><span class="line">t1 = T[word_to_id[<span class="string">'i'</span>]]  <span class="comment"># i의 단어 벡터</span></span><br><span class="line"></span><br><span class="line">print(cos_similarity(t0, t1))</span><br><span class="line"><span class="comment"># 0.7071067758832467</span></span><br></pre></td></tr></table></figure>
<p></p>

<p>실행 결과 you와 i의 코사인 유사도는 0.70…으로 나왔다. 코사인 유사도 값은 -1에서 1 사이므로, 이 값은 비교적 높다(유사성이 크다)고 말할 수 있다.</p>
<p><br></br><br></p>
<h4 id="유사-단어의-랭킹-표시"><a href="#유사-단어의-랭킹-표시" class="headerlink" title="유사 단어의 랭킹 표시"></a>유사 단어의 랭킹 표시</h4><p>코사인 유사도까지 구현했으니 이 함수를 활용해 또 다른 유용한 기능을 구현해보고 싶다. 어떤 단어가 검색어로 주어지면, 그 검색어와 비슷한 단어를 유사도 순으로 출력하는 함수는 어떨까? 그 함수 이름은 most_similar()로 하고, 다음 인수들을 입력받도록 구현해보자.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">most_similar(query, word_to_id, id_to_word, word_matrix, top=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p></p>

<ul>
<li>query : 검색어(단어)</li>
<li>word_to_id : 단어에서 단어 ID로의 딕셔너리</li>
<li>id_to_word : 단어 ID에서 단어로의 딕셔너리</li>
<li>word_matrix : 단어 벡터들을 한데 모은 행렬. 각 행에는 대응하는 단어의 벡터가 저장되어 있다고 가정한다.</li>
<li>top : 상위 몇 개까지 출력할지 설정</li>
</ul>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">most_similar</span><span class="params">(query, word_to_id, id_to_word, word_matrix, top=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="comment"># (1) 검색어를 꺼낸다.</span></span><br><span class="line">    <span class="keyword">if</span> query <span class="keyword">not</span> <span class="keyword">in</span> word_to_id:</span><br><span class="line">        print(<span class="string">'%s(을)를 찾을 수 없습니다.'</span> % query)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\n[query] '</span> + query)</span><br><span class="line">    query_id = word_to_id[query]</span><br><span class="line">    query_vec = word_matrix[query_id]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (2) 코사인 유사도 계산</span></span><br><span class="line">    vocab_size = len(id_to_word)</span><br><span class="line">    similarity = np.zeros(vocab_size)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(vocab_size):</span><br><span class="line">        similarity[i] = cos_similarity(word_matrix[i], query_vec)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (3) 코사인 유사도를 기준으로 내림차순으로 출력</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">-1</span> * similarity).argsort():</span><br><span class="line">        <span class="keyword">if</span> id_to_word[i] == query:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">'%s: %s'</span> %(id_to_word[i], similarity[i]))</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &gt;= top:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p><br></br></p>
<p>이 코드는 다음 순서로 동작한다.</p>
<ol>
<li>검색어의 단어 벡터를 꺼낸다.</li>
<li>검색어의 단어 벡터와 다른 모든 단어 벡터와의 코사인 유사도를 각각 구한다.</li>
<li>계산한 코사인 유사도 결과를 기준으로 값이 높은 순서대로 출력한다.</li>
</ol>
<p><br></br></p>
<p>3번의 코드에 관해서만 설명을 덧붙이겠다. 여기서는 similarity 배열에 담긴 원소의 인덱스를 내림차순으로 정렬한 후 상위 원소들을 출력한다.이때 배열 인덱스의 정렬을 바꾸는데 사용한 argsort() 메서드는 너마이 배열의 원소를 오름차순으로 정렬한다((단, 반환값은 배열의 인덱스). 예를 하나 보자.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">100</span>, <span class="number">-20</span>, <span class="number">2</span>])</span><br><span class="line">print(x.argsort())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p></p>

<p>이 짤막한 코드는 [100, -20, 2]라는 넘파이 배열의 원소들을 오름차순으로 정렬했다. 이때 반환된 배열에 담긴 원소들은 원래 배열의 인덱스에 해당한다. 즉, 앞의 결과는 인덱스가 1인 원소(-20), 2인 원소(2), 0인 원소(100) 순으로 정렬된 것이다. 여기서 우리의 목적은 단어의 유사도가 ‘큰’ 순서로 정렬하는 것이었다. 따라서 넘파이 배열의 각 원소에 마이너스를 곱한 후 argsort() 메서드를 호출하면 원하는 결과를 얻을 수 있다. 앞의 예에 적용해보면 다음과 같이 된다.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print((-x).argsort())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p></p>

<p>이처럼 argsort()를 사용하면 단어의 유사도가 높은 순서로 출력할 수 있다. 이제 이 함수를 사용해볼 차례이다. you를 검색어로 지정해 유사한 단어들을 출력해보자.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> preprocess, create_co_matrix, most_similar</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">100</span>, <span class="number">-20</span>, <span class="number">2</span>])</span><br><span class="line">print(x.argsort())</span><br><span class="line">print((-x).argsort())</span><br><span class="line"></span><br><span class="line">text = <span class="string">'You say goodbye and I say hello.'</span></span><br><span class="line">corpus, word_to_id, id_to_word = preprocess(text)</span><br><span class="line">vocab_size = len(word_to_id)</span><br><span class="line">C = create_co_matrix(corpus, vocab_size)</span><br><span class="line"></span><br><span class="line">most_similar(<span class="string">'you'</span>, word_to_id, id_to_word, C, top=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line"></span><br><span class="line">[query] you</span><br><span class="line">goodbye: <span class="number">0.7071067758832467</span></span><br><span class="line">i: <span class="number">0.7071067758832467</span></span><br><span class="line">hello: <span class="number">0.7071067758832467</span></span><br><span class="line">say: <span class="number">0.0</span></span><br><span class="line"><span class="keyword">and</span>: <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p></p>

<p>이 결과는 검색어 you와 유사한 단어를 상위 5개만 출력한 것이다. 코사인 유사도는 해당 단어의 오른쪽에서 볼 수 있다. 앞의 결과를 보면 you에 가장 가까운 단어는 총 3개인데, 차례로 goodbye, i, hello이다. 확실히 i와 you 모두 인칭대명사이므로 둘이 비슷하다는 건 납득이 된다. 하지만 goodbye와 hello의 코사인 유사도가 높다는 것은 우리의 직관과는 거리가 멀다. 물론 지금은 말뭉치의 크기가 너무 작다는 것이 원인이다. 나중에 더 큰 말뭉치를 사용하여 똑같은 실험을 해볼 테니 조금만 기다려 주자.</p>
<p></p>

<p>자, 지금까지 본 것처럼 동시발생 행렬을 이용하면 단어를 벡터로 표혀날 수 있다. 이것으로 통계 기반 기법의 기본을 끝마치겠다. 지금까지가 기본인 만큼, 아직 이야기할 주제는 얼마든지 남아 있다. 다음 절에서는 지금의 방법을 한층 개선하는 아이디어를 설명하고 실제로 구현해볼 것이다.</p>
<p><br></br><br></p>
<h4 id="통계-기반-기법-개선하기"><a href="#통계-기반-기법-개선하기" class="headerlink" title="통계 기반 기법 개선하기"></a>통계 기반 기법 개선하기</h4><p>앞 절에서는 단어의 동시발생 행렬을 만들었다. 이를 이용해 단어를 벡터로 표현하는 데는 성공했는데, 사실 동시발생 행렬에는 아직 개선할 점이 있다. 이번 절에서는 이 개선 작업을 해볼까 한다. 그리고 개선을 완료한 다음에는 좀 더 실용적인 말뭉치를 사용하여 ‘진짜’ 단어의 분산 표현을 손에 넣어보겠다.</p>
<p><br></br></p>
<h4 id="상호정보량"><a href="#상호정보량" class="headerlink" title="상호정보량"></a>상호정보량</h4><p>앞 절에서 본 동시발생 행렬의 원소는 두 단어가 동시에 발생한 횟수를 나타낸다. 그러나 이 ‘발생’ 횟수라는 것은 사실 그리 좋은 특징이 아니다. 고빈도 단어(많이 출현하는 단어)로 눈을 돌려보면 바로 그 이유를 알 수 있다.</p>
<p></p>

<p>예컨대 말뭉치에서 the와 car의 동시발생을 생각해보자. 분명 “…the car…”라는 문구가 자주 보일 것이다. 따라서 두 단어의 동시발생 횟수는 아주 많을 것이다. 한편 car와 drive는 확실히 관련이 깊다. 하지만 단순히 등장 횟수만 본다면 car는 drive보다는 the와의 관련성이 훨씬 강하다고 나올 것이다. the가 고빈도 단어라서 car와 강한 관련성을 갖는다고 평가되기 때문이다.</p>
<p></p>

<p>이 문제를 해결하기 위해 점별 상호정보량(Pointwise Mutual Information, PMI)이라는 척도를 사용한다. PMI는 확률 변수 $\mathit{x}, \mathit{y}$에 대해 다음 식으로 정의된다.</p>
<p></p>

<script type="math/tex; mode=display">PMI(x, y) = log_2 {P(x, y)} \over {P(x) P(y)}</script><p></p>

<p>위 식에서 $\mathit{P(x)}$는 $\mathit{x}$가 일어날 확률, $\mathit{P(y)}$는 $\mathit{y}$가 일어날 확률, $\mathit{P(x, y)}$는 $\mathit{x}, \mathit{y}$가 동시에 일어날 확률을 뜻한다. 이 PMI 값이 높을수록 관련성이 높다는 의미이다.</p>
<p></p>

<p>이 식을 앞의 자연어 예에 적용하면 10,000개의 단어로 이뤄진 말뭉치에서 the가 100번 등장한다면 $\mathit{P(“the”)=0.01}$이 된다. 마찬가지로 the와 car가 10번 동시발생했다면 $\mathit{P(“the”, “car”)=0.001}$이 되는 것이다.</p>
<p></p>

<p>그럼 동시발생 행렬(각 원소는 동시발생한 단어의 횟수)을 사용하여 위의 식을 다시 써보자. $\mathit{C}$는 동시발생 행렬, $\mathit{C(x, y)}$는 단어 $\mathit{x, y}$가 동시발생하는 횟수, $\mathit{C(x), C(y)}$는 각 단어의 등장 횟수이다. 이때 말뭉치에 포함된 단어 수를 $\mathit{N}$이라 하면, 다음과 같이 변한다.</p>
<p></p>

<script type="math/tex; mode=display">PMI(x, y) = log_2 \left{P(x)P(y)}{P(x, y)} \right = log_2 \left{ \left{N}{C(x)} \right \left{N}{C(y)} \right}{ \left{N}{C(x, y)}\right = log_2 \left{C(x) C(y)}{C(x, y) N} \right</script><p></p>

<p>위 식에 따라 동시발생 행렬로부터 PMI를 구할 수 있다. 그러면 위 식대로 구체적인 계산을 해보자. 말뭉치의 단어 수를 10,000이라 하고, the와 car와 drive가 각각 1,000번, 20번, 10번 등장했다고 해보자. 그리고 the와 car의 동시발생 수는 10회, car와 drive의 동시발생 수는 5회라고 가정하자. 이 조건이라면, 동시발생 횟수 관점에서는 car는 drive보다 the와 관련이 깊다고 나온다. 그렇다면 PMI 관점에서는 어떨까?</p>
<p></p>

<script type="math/tex; mode=display">PMI("the", "car") \approx 2.32</script><script type="math/tex; mode=display">PMI("drive", "car") \approx 7.97</script><p></p>

<p>이 결과에서 알 수 있듯이 PMI를 이용하면 car와 the 보다 drive와의 관련성이 강해진다. 우리가 원하던 결과다. 이러한 결과가 나온 이유는 단어가 단독으로 출현하는 횟수가 고려되었기 때문이다. 이 예에서는 the가 자주 출현했으므로 PMI 점수가 낮아진 것이다. 이제 PMI라는 멋진 척도를 얻었지만, 이 PMI에도 한 가지 문제가 있다. 바로 두 단어의 동시발생 횟수가 0이면 음의 무한대가 된다는 점이다. 이 문제를 피하기 위해 실제로 구현할 때는 양의 상호정보량(Positive PMI)를 사용한다.</p>
<p></p>

<script type="math/tex; mode=display">PPMI(x, y) = max(0, PMI(x, y))</script><p></p>

<p>이 식에 따라 PMI가 음수일 때는 0으로 취급한다. 이제 단어 사이의 관련성을 0 이상의 실수로 나타낼 수 있다. 그러면 동시발생 행렬을 PPMI 행렬로 변환하는 함수를 구현해보자.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ppmi</span><span class="params">(C, verbose=False, eps=<span class="number">1e-8</span>)</span>:</span></span><br><span class="line">    M = np.zeros_like(C, dtype=np.float32)</span><br><span class="line">    N = np.sum(C)</span><br><span class="line">    S = np.sum(C, axis=<span class="number">0</span>)</span><br><span class="line">    total = C.shape[<span class="number">0</span>] * C.shape[<span class="number">1</span>]</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(C.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(C.shape[<span class="number">1</span>]):</span><br><span class="line">            pmi = np.log2(C[i, j] * N / (S[j]*S[i]) + eps)</span><br><span class="line">            M[i, j] = max(<span class="number">0</span>, pmi)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> verbose:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt % (total//<span class="number">100</span>) == <span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">'%.1f%% 완료'</span> % (<span class="number">100</span>*cnt/total))</span><br><span class="line">    <span class="keyword">return</span> M</span><br></pre></td></tr></table></figure>
<p></p>

<p>여기에서 인수 C는 동시발생 행렬, verbose는 진행상황 출력 여부를 결정하는 플래그이다. 큰 말뭉치를 다룰 때 verbose=True로 설정하면 중간중간 진행 상황을 알려준다. 참고로, 이 코드는 동시발생 행렬에 대해서만 PPMI 행렬을 구할 수 있도록 하고자 단순화해 구현했다. 구체적으로 말하면 $C(x) = \sum_i C(i, x), C(y) = \sum_i C(i, y), N = \sum_i \sum_j C(i, j)$가 되도록 (즉, 근사값을 구하도록) 구현했다. 한 가지 더, 이 코드에서는 np.log2(0)이 음의 무한대(-inf)가 되는 사태를 피하기 위해 eps라는 작은 값을 사용했다.</p>
<p></p>

<p>그럼, 동시발생 행렬을 PPMI 행렬로 변환해보자. 이는 다음처럼 구현할 수 있다.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'..'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> preprocess, create_co_matrix, cos_similarity, ppmi</span><br><span class="line"></span><br><span class="line">text = <span class="string">'You say goodbye and I say hello.'</span></span><br><span class="line">corpus, word_to_id, id_to_word = preprocess(text)</span><br><span class="line">vocab_size = len(word_to_id)</span><br><span class="line">C = create_co_matrix(corpus, vocab_size)</span><br><span class="line">W = ppmi(C)</span><br><span class="line"></span><br><span class="line">np.set_printoptions(precision=<span class="number">3</span>)  <span class="comment"># 유효 자릿수를 세 자리로 표시</span></span><br><span class="line">print(<span class="string">'동시발생 행렬'</span>)</span><br><span class="line">print(C)</span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">50</span>)</span><br><span class="line">print(<span class="string">'PPMI'</span>)</span><br><span class="line">print(W)</span><br></pre></td></tr></table></figure>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line"></span><br><span class="line">동시발생 행렬</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]]</span><br><span class="line">--------------------------------------------------</span><br><span class="line">PPMI</span><br><span class="line">[[<span class="number">0.</span>    <span class="number">1.807</span> <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>   ]</span><br><span class="line"> [<span class="number">1.807</span> <span class="number">0.</span>    <span class="number">0.807</span> <span class="number">0.</span>    <span class="number">0.807</span> <span class="number">0.807</span> <span class="number">0.</span>   ]</span><br><span class="line"> [<span class="number">0.</span>    <span class="number">0.807</span> <span class="number">0.</span>    <span class="number">1.807</span> <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>   ]</span><br><span class="line"> [<span class="number">0.</span>    <span class="number">0.</span>    <span class="number">1.807</span> <span class="number">0.</span>    <span class="number">1.807</span> <span class="number">0.</span>    <span class="number">0.</span>   ]</span><br><span class="line"> [<span class="number">0.</span>    <span class="number">0.807</span> <span class="number">0.</span>    <span class="number">1.807</span> <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>   ]</span><br><span class="line"> [<span class="number">0.</span>    <span class="number">0.807</span> <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">2.807</span>]</span><br><span class="line"> [<span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">2.807</span> <span class="number">0.</span>   ]]</span><br></pre></td></tr></table></figure>
<p></p>

<p>이것으로 동시발생 행렬을 PPMI 행렬로 변환하는 법을 알아봤다. 이때 PPMI 행렬의 각 원소는 0 이상의 실수이다. 이제 우리는 더 좋은 척도로 이뤄진 행렬(더 좋은 단어 벡터)을 손에 쥐었다. 그러나 PPMI 행렬에도 여전히 큰 문제가 있다! 말뭉치의 어휘 수가 증가함에 따라 각 단어 벡터의 차원 수도 증가한다는 문제다. 예를 들어 말뭉치의 어휘 수가 10만 개라면 그 벡터의 차원 수도 똑같이 10만이 된다. 10만 차원의 벡터를 다룬다는 것은 그다지 현실적이지 않다.</p>
<p></p>

<p>또한, 이 행렬의 내용을 들여다보면 원소 대부분이 0인 것을 알 수 있다. 벡터의 원소 대부분이 중요하지 않다는 뜻이다. 다르게 표현하면 각 원소의 중요도가 낮다는 뜻이다. 더구나 이런 벡터는 노이즈에 약하고 견고하지 못하다는 약점도 있다. 이 문제에 대처하고자 자주 수행하는 기법이 바로 벡터의 차원 감소이다.</p>
<p><br></br><br></p>
<h4 id="차원-감소"><a href="#차원-감소" class="headerlink" title="차원 감소"></a>차원 감소</h4><p>차원 감소는 문자 그대로 벡터의 차원을 줄이는 방법을 말한다. 그러나 단순히 줄이기만 하는 게 아니라, ‘중요한 정보’는 최대한 유지하면서 줄이는 게 핵심이다. 직관적인 예로, 아래 그림처럼 데이터의 분포를 고려해 중요한 ‘축’을 찾는 일을 수행한다.</p>
<p></p>

<p><img src="/image/fnlp4.jpeg" alt="fnlp4"></p>
<p></p>

<p>위 그림에서 왼쪽은 데이터점들을 2차원 좌표에 표시한 모습이다. 그리고 오른쪽은 새로운 축을 도입하여 똑같은 데이터를 좌표축 하나만으로 표시했다(새로운 축을 찾을 때는 데이터가 넓게 분포되도록 고려해야 한다). 이때 각 데이터점의 값은 새로운 축으로 사영된 값으로 변한다. 여기서 중요한 것은 가장 적합한 축을 찾아내는 일로, 1차원 값만으로도 데이터의 본질적인 차이를 구별할 수 있어야 한다. 이와 같은 작업은 다차원 데이터에 대해서도 수행할 수 있다.</p>
<p></p>

<p>원소 대부분이 0인 행렬 또는 벡터를 희소행렬 또는 희소벡터라 한다. 차원 감소의 핵심은 희소벡터에서 중요한 축을 찾아내어 더 적은 차원으로 다시 표현하는 것인데, 차원 감소의 결과로 원래으 희소벡터는 원소 대부분이 0이 아닌 값으로 구성된 밀집벡터로 변환된다. 이 조밀한 벡터야말로 우리가 원하는 단어의 분산 표현이다.</p>
<p></p>

<p>차원을 감소시키는 방법은 여러 가지가 있지만, 우리는 특잇값분해(Singular Value Decomposition, SVD)를 이용하겠다. SVD는 임의의 행렬을 세 행렬의 곱으로 분해하며, 수식으로는 다음과 같다.</p>
<p></p>

<script type="math/tex; mode=display">X = USV^T</script><p></p>

<p>위의 식과 같이 SVD는 임의의 행렬 $\vec{X}$를 $\vec{U, S, V}$라는 세 행렬의 곱으로 분해한다. 여기서 $\vec{U, V}$는 직교행렬이고, 그 열벡터는 서로 직교한다. 또한 $\vec{S}$는 대각행렬(대각성분 외에는 모두 0인 행렬)이다. 이 수식을 시각적으로 표현하면 아래와 같다.</p>
<p></p>

<p><img src="/image/fnlp5.jpeg" alt="fnlp5"></p>
<p></p>

<p>자, $\vec{U}$는 직교행렬이다. 그리고 이 직교행렬은 어떠한 공간의 축(기저)을 형성한다. 지금 우리의 맥락에서는 이 $\vec{U}$ 행렬을 ‘단어 공간’으로 취급할 수 있다. 또한 $\vec{S}$는 대각행렬로, 그 대각성분에는 ‘특잇값(singular value)’이 큰 순서로 나열되어 있다. 특잇값이란, 쉽게 말해 ‘해당 축’의 중요도라고 간주할 수 있다. 그래서 아래 그림과 같이 중요도가 낮은 원소(특잇값이 작은 원소)를 깎아내는 방법을 생각할 수 있다.</p>
<p></p>

<p><img src="/image/fnlp6.jpeg" alt="fnlp6"></p>
<p></p>

<p>위 그림을 잘 보면서 다음 설명을 따라가보자. 행렬 $\vec(S)$에서 특잇값이 작다면 중요도가 낮다는 뜻이므로, 행렬 $\vec(U)$에서 여분의 열벡터를 깎아내어 원래의 행렬을 근사할 수 있다. 이를 우리 문제로 가져와서 ‘단어의 PPMI 행렬’에 적용해볼까? 그러면 행렬 $\vec{X}$의 각 행에는 해당 단어 ID의 단어 벡터가 저장되어 있으며, 그 단어 벡터가 행렬 $\vec{U’}$라는 차원 감소된 벡터로 표현되는 것이다.</p>
<p><br></br><br></p>
<h4 id="SVD에-의한-차원-감소"><a href="#SVD에-의한-차원-감소" class="headerlink" title="SVD에 의한 차원 감소"></a>SVD에 의한 차원 감소</h4><p>이제 SVD를 파이썬 코드로 살펴보자. SVD는 넘파이의 linalg 모듈이 제공하는 svd 메서드로 실행할 수 있다. 그럼 동시발생 행렬을 만들어 PPMI 행렬로 변환한 다음 SVD를 적용해보자.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SVD</span></span><br><span class="line">U, S, V = np.linalg.svd(W)</span><br><span class="line"></span><br><span class="line">print(C[<span class="number">0</span>])  <span class="comment"># 동시발생 행렬</span></span><br><span class="line">print(W[<span class="number">0</span>])  <span class="comment"># PPMI 행렬</span></span><br><span class="line">print(U[<span class="number">0</span>])  <span class="comment"># SVD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0.</span>    <span class="number">1.807</span> <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>   ]</span><br><span class="line">[ <span class="number">3.409e-01</span>  <span class="number">0.000e+00</span> <span class="number">-1.205e-01</span> <span class="number">-3.886e-16</span> <span class="number">-9.323e-01</span> <span class="number">-1.110e-16</span></span><br><span class="line"> <span class="number">-2.426e-17</span>]</span><br></pre></td></tr></table></figure>
<p></p>

<p>이제 SVD를 수행해 보면 위 코드에서 SVD에 의해 변환된 밀집벡터 표현은 변수 U에 저장된다. 단어 ID가 0인 단어 벡터를 보면 원래는 희소벡터인 W[0]가 SVD에 의해서 U[0]로 변했다. 그리고 이 밀집벡터의 차원을 감소시키려면, 예컨대 2차원 벡터로 줄이려면 단순히 처음의 두 원소를 꺼내면 된다.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(U[<span class="number">0</span>, :<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line">[<span class="number">0.341</span> <span class="number">0.</span>   ]</span><br></pre></td></tr></table></figure>
<p></p>

<p>이것으로 차원 감소도 다 알아봤다. 그러면 각 단어를 2차원 벡터로 표현한 후 그래프로 그려보자. 다음 코드를 추가하면 된다.</p>
<p></p>

<p><img src="/image/myplot.png" alt="myplot"></p>
<p></p>

<p>위 그림을 보면 goodbye와 hello, you와 i가 제법 가까이 있음을 알 수 있다. 우리의 직관과 비교적 비슷하다. 하지만 지금 사용한 말뭉치가 아주 작아서 이 결과를 그대로 받아들이기에는 솔직히 석연치 않다. 그러면 계속해서 PTB 데이터셋이라는 더 큰 말뭉치를 사용하여 똑같은 실험을 수행해보자.</p>
<p><br></br><br></p>
<h4 id="PBT-데이터셋"><a href="#PBT-데이터셋" class="headerlink" title="PBT 데이터셋"></a>PBT 데이터셋</h4><p>지금까지는 아주 작은 텍스트 데이터를 말뭉치로 사용했다. 그래서 이번 절에서는 본격적인 말뭉치(그렇다고 너무 크지는 않고 적당한 말뭉치)를 이용해보겠다. 그 주인공은 바로 펜 트리뱅크(Penn Treebank, PTB)이다. PTB 말뭉치는 주어진 기법의 품질을 측정하는 벤치마크로 자주 이용된다. 우리가 이용할 PTB 말뭉치는 word2vec 발명자인 토마스 마콜로프의 웹 페이지에서 받을 수 있다. 이 PTB 말뭉치는 텍스트 파일로 제공되며, 원래의 PTB 문장에 몇 가지 전처리를 해두었다. 예컨대 희소한 단어를 <unk>라는 특수 문자로 치환한다거나, 구체적인 숫자를 ‘N’으로 대체하는 등의 작업이 적용되었다. 또한 PTB 말뭉치에서는 한 문장이 하나의 줄로 저장되어 있다. 이 책에서는 각 문장을 연결한 ‘하나의 큰 시계열 데이터’로 취급한다. 이때 각 문장 끝에 <eos>라는 특수 문자를 삽입한다. </p>
<p></p>

<p>이 책에서는 PTB 데이터셋을 쉽게 이용할 수 있도록 전용 파이썬 코드를 준비했다. 다음은 ptb.py를 사용하는 예이다.</p>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'..'</span>)</span><br><span class="line"><span class="keyword">import</span> ptb</span><br><span class="line"></span><br><span class="line">corpus, word_to_id, id_to_word = ptb.load_data(<span class="string">'train'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'말뭉치 크기:'</span>, len(corpus))</span><br><span class="line">print(<span class="string">'corpus[:30]:'</span>, corpus[:<span class="number">30</span>])</span><br><span class="line">print()</span><br><span class="line">print(<span class="string">'id_to_word[0]:'</span>, id_to_word[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">'id_to_word[0]:'</span>, id_to_word[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'id_to_word[0]:'</span>, id_to_word[<span class="number">2</span>])</span><br><span class="line">print()</span><br><span class="line">print(<span class="string">'word_to_id["car"]:'</span>, word_to_id[<span class="string">"car"</span>])</span><br><span class="line">print(<span class="string">'word_to_id["happy"]:'</span>, word_to_id[<span class="string">"happy"</span>])</span><br><span class="line">print(<span class="string">'word_to_id["lexus"]:'</span>, word_to_id[<span class="string">"lexus"</span>])</span><br></pre></td></tr></table></figure>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line"></span><br><span class="line">말뭉치 크기: <span class="number">929589</span></span><br><span class="line">corpus[:<span class="number">30</span>]: [ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span></span><br><span class="line"> <span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">29</span>]</span><br><span class="line"></span><br><span class="line">id_to_word[<span class="number">0</span>]: aer</span><br><span class="line">id_to_word[<span class="number">0</span>]: banknote</span><br><span class="line">id_to_word[<span class="number">0</span>]: berlitz</span><br><span class="line"></span><br><span class="line">word_to_id[<span class="string">"car"</span>]: <span class="number">3856</span></span><br><span class="line">word_to_id[<span class="string">"happy"</span>]: <span class="number">4428</span></span><br><span class="line">word_to_id[<span class="string">"lexus"</span>]: <span class="number">7426</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">말뭉치를 다루는 방법은 지금까지와 같다. 앞의 코드에서 ptb.load_data()는 데이터를 읽어 들인다. 이때 인수로는 <span class="string">'train'</span>, <span class="string">'test'</span>, <span class="string">'valid'</span> 중 하나를 지정할 수 있는데, 차례대로 훈련용, 테스트용, 검증용 데이터를 가리킨다. 이상으로 ptb 사용법에 관한 설명을 마친다.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;&lt;/br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#### PTB 데이터셋 평가</span></span><br><span class="line"></span><br><span class="line">PTB 데이터셋에 통계 기반 기법을 적용해보자. 이번에는 큰 행렬에 SVD를 적용해야 하므로 고속 SVD를 이용할 것을 추천한다. 구속 SVD를 이용하려면 sklearn 모듈을 설치해야 한다.</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'..'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> most_similar, create_co_matrix, ppmi</span><br><span class="line"><span class="keyword">import</span> ptb</span><br><span class="line"></span><br><span class="line">window_size = <span class="number">2</span></span><br><span class="line">wordvec_size = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">corpus, word_to_id, id_to_word = ptb.load_data(<span class="string">'train'</span>)</span><br><span class="line">vocab_size = len(word_to_id)</span><br><span class="line">print(<span class="string">'동시발생 수 계산 ...'</span>)</span><br><span class="line">C = create_co_matrix(corpus, vocab_size, window_size)</span><br><span class="line">print(<span class="string">'PPMI 계산 ...'</span>)</span><br><span class="line">W = ppmi(C, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'SVD 계산 ...'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># truncated SVD (빠르다!)</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.utils.extmath <span class="keyword">import</span> randomized_svd</span><br><span class="line">    U, S, V = randomized_svd(W, n_components=wordvec_size, n_iter=<span class="number">5</span>,</span><br><span class="line">                             random_state=<span class="literal">None</span>)</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="comment"># SVD (느리다)</span></span><br><span class="line">    U, S, V = np.linalg.svd(W)</span><br><span class="line"></span><br><span class="line">word_vecs = U[:, :wordvec_size]</span><br><span class="line"></span><br><span class="line">querys = [<span class="string">'you'</span>, <span class="string">'year'</span>, <span class="string">'car'</span>, <span class="string">'toyota'</span>]</span><br><span class="line"><span class="keyword">for</span> query <span class="keyword">in</span> querys:</span><br><span class="line">    most_similar(query, word_to_id, id_to_word, word_vecs, top=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p></p>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line"></span><br><span class="line">말뭉치 크기: <span class="number">929589</span></span><br><span class="line">corpus[:<span class="number">30</span>]: [ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span></span><br><span class="line"> <span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">29</span>]</span><br><span class="line"></span><br><span class="line">id_to_word[<span class="number">0</span>]: aer</span><br><span class="line">id_to_word[<span class="number">0</span>]: banknote</span><br><span class="line">id_to_word[<span class="number">0</span>]: berlitz</span><br><span class="line"></span><br><span class="line">word_to_id[<span class="string">"car"</span>]: <span class="number">3856</span></span><br><span class="line">word_to_id[<span class="string">"happy"</span>]: <span class="number">4428</span></span><br><span class="line">word_to_id[<span class="string">"lexus"</span>]: <span class="number">7426</span></span><br></pre></td></tr></table></figure>
<p></p>

<p>위 코드는 SVD를 수행하는데 sklearn_randomized_svd() 메서드를 이용했다. 이 메서드는 무작위 수를 사용한 Truncated SVD로, 특잇값이 큰 것들만 계산하여 기본적인 SVD보다 훨씬 빠르다. 나머지 부분은 앞서 작은 말뭉치를 사용한 코드와 거의 같다. 위 코드를 실행결과를 보면, 우선 you라는 검색어에서는 인칭대명사인 i와 we가 상위를 차지했음을 알 수 있다. 영어 문장에서 관용적으로 자주 같이 나오는 단어들이기 때문이다. 또 year의 연관어로는 month와 quarter가, car의 연관어로는 auto와 vehicle 등이 뽑혔다. 그리고 toyota와 관련된 단어로는 nissan, honda, lexus 등 자동차 제조업체나 브랜드가 뽑힌 것도 확인할 수 있다. 이처럼 단어의 의미 혹은 문법적인 관점에서 비슷한 단어들이 가까운 벡터로 나타났다. 우리의 직관과 비슷한 결과라고 할 수 있다.</p>
<p></p>

<p>마침내 단어이 의미를 벡터로 잘 인코딩하는데 성공했다. 말뭉치를 사용해 맥락에 속한 단어의 등장 횟수를 센 후 PPMI 행렬로 변환하고, 다시 SVD를 이용해 차원을 감소시킴으로써 더 좋은 단어 벡터를 얻어냈다. 이것이 단어의 분산 표현이고, 각 단어는 고정 길이의 밀집벡터로 표현되었다.</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/25/SEM-%EC%B8%A1%EC%A0%95%EB%AA%A8%ED%98%95%EC%9D%98-%ED%99%95%EC%9E%A5/">
                [SEM] 측정모형의 확장
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-25</span>
            
            
            
                <span class="category">
                    <a href="/categories/structural-equation-modeling/">structural equation modeling</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="측정모형의-확장"><a href="#측정모형의-확장" class="headerlink" title="측정모형의 확장"></a>측정모형의 확장</h1><h6 id="본-포스팅은-lt-구조방정식-모형의-기본과-확장-gt-을-바탕으로-진행합니다"><a href="#본-포스팅은-lt-구조방정식-모형의-기본과-확장-gt-을-바탕으로-진행합니다" class="headerlink" title="본 포스팅은 &lt;구조방정식 모형의 기본과 확장&gt;을 바탕으로 진행합니다."></a>본 포스팅은 &lt;구조방정식 모형의 기본과 확장&gt;을 바탕으로 진행합니다.</h6><p><br></br></p>
<h3 id="다집단요인분석과-MIMIC-모형"><a href="#다집단요인분석과-MIMIC-모형" class="headerlink" title="다집단요인분석과 MIMIC 모형"></a>다집단요인분석과 MIMIC 모형</h3><p>다집단 요인분석(multiple-group factor analysis)은 여러 맥락에서 상당히 자주 사용되는 분석 방법인데, 이를 실행할 때 측정불변성(measurement invariance) 또는 측정동일성(measurement equivalence)을 확인하는 작업이 매우 중요하다. 측정불변성이란 여러 집단(성별, 인종, 문화집단 등)에 걸쳐 동일한 요인구조가 나타나고 있는지를 가리키는 용어다. 이는 모형에서 설정된 잠재변수와 지표변수 사이의 관계에 대하여 집단변수가 조절효과(moderation effect)를 가지고 있느냐로 표현할 수도 있다. 집단 간에 다른 구조가 나타나고 있다면 조절효과가 있다고 이야기한다. 통계에서 말하는 상호작용 효과(interaction effect)와도 통하는 개념이다. 측정불변성은 사실 여러 집단뿐만 아니라 여러 시점에 걸쳐서 같은 요인구조가 나타나는지를 확인하는 경우도 있다. 이런 경우 종단 측정불변성(longitudinal measurement invariance)이라고 한다. 여러 집단에 걸쳐 나타나든 또는 여러 시점에 걸쳐 나타나든 간에 측정불변성이 확보되지 못한 경우에는 측정된 자료의 해석이 제한받을 수 있기 때문에 유의하여야 한다. 다집단 요인분석에서 집단 간 잠재평균의 차이를 확인하고자 하는 것이 목적일 때 MIMIC) 모형의 사용이 유용할 수 있다. 다집단 요인분석을 자세하게 다룬 후에 다집단 요인분석의 대안으로서의 MIMIC 모형을 살펴본다.</p>
<p><br></br></p>
<h4 id="측정불변성-소개"><a href="#측정불변성-소개" class="headerlink" title="[측정불변성 소개]"></a>[측정불변성 소개]</h4><p>요인모형에서 측정불변성을 확인하는 세부적인 이유와 목적은 여러 가지가 있을 수 있다. 예를 들어, 집단 간에 잠재변수의 평균이 같은지를 비교하기 위하여, 또 여러 집단에 걸쳐 구인 타당도가 동일하게 확보되는지를 알아보기 위하여 측정불변성을 확인할 수도 있고, 여러 시점에 걸쳐 회귀 효과를 볼 때 각 시점에서의 요인구조가 같은지를 보기 위하여 측정불변성을 확인할 수도 있으며, 구조방정식 모형의 경로 동일성을 확인하기 위한 전 단계로 측정불변성을 확인할 수도 있다. 구조방정식 모형에서 집단 간 경로의 동일성을 확인하기 위해서는 측정모형 부분에서 측정불변성이 확보되어야 하는데, 이 확인 과정은 측정모형에서 할 수도 있고 구조방정식 모형에서 할 수도 있다. 이후에 더 자세한 설명이 예와 함께 주어질 것이다. 이런 여러 가지 목적으로 사용되는 다집단 요인분석을 통한 측정불변성의 확인은 특히 잠재변수(요인)과 지표변수 간의 관계라는 맥락에서 적절한 단어라고 할 수 있다. 간단히 말해서 만약 지표변수들과 잠재변수들 사이의 구조, 즉 관계가 여러 집단이나 시점에 걸쳐 다르지 않다면 측정불변성이 있다고 이야기한다. 예를 들어, 여러 관찰변수에 의해서 측정되는 우울 구인이 남녀 집단 중 어디에서 더 심한지를 확인하기를 원한다면 일단 남녀 집단에서 각각 측정되는 우울이란 구인이 동일한 의미를 지니고 있는지를 확인해야 하는 것이다. 이제 아래 식에 있는 지표변수와 잠재변수의 관계 모형, 즉 측정모형을 통해 측정불변성에 대하여 알아보도록 하자.</p>
<p><br></br></p>
<script type="math/tex; mode=display">x_1 = \mu_1 + \lambda_{11}{f_1} + \lambda_{12}{f_2} + ... + \lambda_{1m}{f_m} + e_1</script><script type="math/tex; mode=display">x_2 = \mu_2 + {\lambda}_{21}{f_1} + {\lambda}_{22}{f_2} + ... + {\lambda}_{2m}{f_m} + e_2</script><script type="math/tex; mode=display">\vdots</script><script type="math/tex; mode=display">x_p = \mu_p + {\lambda}_{p1}{f_1} + {\lambda}_{p2}{f_2} + ... + {\lambda}_{pm}{f_m} + e_p</script><p><br></br></p>
<p>위의 식에서 $\mathit{x}$는 지표변수, $\mu$는 절편, $\lambda$는 요인부하, $\mathit{f}$는 요인(잠재변수), $\mathit{e}$는 측정오차다. 기본적으로 여러 집단 간의 측정불변성은 요인모형을 여러 단계에 걸쳐 이루어지는 모형 비교 검정을 통하여 확인하게 된다. 예를 들어, 집단 간에 요인의 종류는 동일한지, 그 요인들을 측정하는 지표변수들은 서로 동일한지, 집단 간에 요인모형의 요인부하($\lambda$)가 서로 동일한지, 절편은 동일한지, 측정오차의 분산은 동일한지 등을 검정하게 된다. 이러한 단계별 검정 과정에서 공분산 구조만 이용하느냐, 아니면 평균 구조까지 더하여 이용하느냐에 따라 과정은 조금 달라질 수 있다. 다시 말해, 측정동일성을 확인하는 데 있어서 $\mu_1$ ~ $\mu_p$를 사용하느냐 그렇지 않느냐를 결정해야 한다.</p>
<p>다집단 요인분석의 여러 목적 중에서 잠재평균의 비교를 위한 다집단 요인분석의 예를 보인다. 실제 요인(요인의 실제 점수)과 추정된 요인점수는 사실 같지 않다. 다시 말해, 요인점수는 기본적으로 이차(secondary) 추정으로 이루어지는 것이기 때문에 진정한 요인의 점수로부터 편향되어 있다. 추정된 요인점수는 다만 진정한 $\mathit{f}$의 지표변수 같은 것이다. 여기서는 설명을 쉽게 하기 위해서 요인점수라는 단어를 사용하였다. 한 가지 더 추가적으로 밝히면, 이런 이유 때문에 요인점수를 추정하여 이후 집단 간 평균비교를 하는 방식보다 요인모형 안에서 직접적으로 잠재평균 비교를 하는 것이 더 뛰어난 방법이다. 여기서는 공분산 행렬과 평균 벡터를 모두 이용할 것이며, 네 단계의 측정불변성 단계를 또한 모두 보여 줄 것이다. 이제 가장 첫 단계인 형태동일성 모형부터 추정하여 검정한다. 다집단 요인분석을 설명하는 데 있어서 실제 추정의 과정이 매우 중요하기 때문에 Mplus를 이용한 예제를 제공한다. </p>
<p><br></br></p>
<h4 id="측정불변성의-단계적-확인"><a href="#측정불변성의-단계적-확인" class="headerlink" title="측정불변성의 단계적 확인"></a>측정불변성의 단계적 확인</h4><p>형태동일성, 측정단위동일성, 절편동일성, 분산공분산동일성 등의 단계별 확인을 통하여 잠재평균의 집단 차이검정을 실시하고자 한다. 또한 각 단계에서 동일성 또는 불변성 확인이 실패한 경우 고려할 수 있는 부분측정동일성에 대하여 토론한다.</p>
<h6 id="형태동일성"><a href="#형태동일성" class="headerlink" title="형태동일성"></a>형태동일성</h6><p>동일유형불변성(equal form invariance) 또는 패턴불변성(pattern invariance)이라고도 불리는 형태동일성(configural invariance)은 집단 간에 같은 측정모형을 설정함으로써 측정불변성을 검정하는 가장 첫 번째 단계다. 이번 첫 단계에서 요인의 개수와 요인-지표변수 관계는 집단 간에 같아야 하고, 모수는 각각의 집단 내에서 다른 값으로 추정될 수 있다. 만약에 형태동일성 모형의 적합도에 문제가 있으면 측정불변성 검정의 다음 단계로 나아가지 못하며, 측정불변성 확보는 실패하게 된다. 즉, 형태동일성 모형은 측정불변성의 확인과 검정을 위한 기저모형이기 때문에 이 모형의 적합도가 좋지 않으면 다음 단계는 무의미하게 되고, 잠재평균의 비교나 구인 타당도의 확인이 원천적으로 가능하지 않게 된다. 이후에 자세히 다루겠지만, 측정단위동일성이나 절편동일성 등의 검정에 실패했을 때는 부분측정동일성(partial measurement invariance) 등을 통해 나름대로 피해 갈 수 있는 방법이 있다. 그러나 형태동일성에 문제가 생기면 아예 측정불변성 단계를 진행할 수 없게 되고, 이것은 연구자에게 있어서 큰 손실이다. 이제 Mplus를 이용하여 형태동일성 모형을 추정하도록 하자. 먼저 모형을 위한 input 부분이 아래에 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">TITLE: Multiple Group CFA</span><br><span class="line"></span><br><span class="line">DATA: FILE IS <span class="string">"interest_mplus.csv"</span>;</span><br><span class="line"></span><br><span class="line">VARIABLE: NAMES ARE GEN, EDUC, AGE, COG1-COG6 PER1-PER6 INT1-INT18;</span><br><span class="line">          USEVARIABLES ARE GEN, INT1-INT18;</span><br><span class="line">          GROUPING IS GEN (<span class="number">1</span>=male, <span class="number">2</span>=female);</span><br><span class="line"></span><br><span class="line">ANALYSIS: TYPE = General;</span><br><span class="line"></span><br><span class="line">MODEL: f1 BY INT1 INT2 INT12 INT18;</span><br><span class="line">       f2 BY INT3 INT6 INT8 INT9 INT10 INT13 INT15 INT16 INT17;</span><br><span class="line">       f3 BY INT4 INT5;</span><br><span class="line">       f4 BY INT7 INT11 INT14;</span><br><span class="line">       [INT1-INT18];</span><br><span class="line">       [f1-f4@<span class="number">0</span>];</span><br><span class="line">       INT1-INT18;</span><br><span class="line"></span><br><span class="line">MODEL female: </span><br><span class="line">       f1 BY INT1@<span class="number">1</span> INT2 INT12 INT18;</span><br><span class="line">       f2 BY INT3@<span class="number">1</span> INT6 INT8 INT9 INT10 INT13 INT15 INT16 INT17;</span><br><span class="line">       f3 BY INT4@<span class="number">1</span> INT5;</span><br><span class="line">       f4 BY INT7@<span class="number">1</span> INT11 INT14;</span><br><span class="line">       [INT1-INT18];</span><br><span class="line">       [f1-f4@<span class="number">0</span>];</span><br><span class="line">       INT1-INT18;</span><br></pre></td></tr></table></figure>
<p>형태동일성 모형의 적합도가 문제인 경우에 대해 Meade와 Kroustalis(2006)의 견해는 실용적으로 매우 가치가 있기 때문에 다음과 같이 소개하고자 한다. 형태동일성 모형의 적합도가 좋지 않은 경우 두 가지 매우 다른 원인을 생각해 볼 수 있다. 첫째는 자료 등의 문제(예: 신뢰도가 낮은 많은 수의 지표변수를 사용하는 경우)로 인해 여러 집단에서 공통적으로 좋지 않은 모형의 적합도가 발생하는 경우이고, 둘째는 정말로 집단 간 요인의 구조가 달라서 좋지 않은 모형의 적합도가 발생하는 경우다. 예를 들어, $\mathit{f_1}$을 측정하는 지표변수의 세트가 집단1과 집단2 간에 서로 다른 것이다. Meade와 Kroustalis(2006)는 만약 모형의 적합도 문제가 첫 번째 이유로 발생한 경우 측정불변성의 검정 단계를 진행할 수 있다고 하였다. 실제 여러 학문 분야에서 종종 많은 연구자가 신뢰도나 타당도가 정밀하게 확인되지 않은 심리 척도를 사용한다. 이때 측정치는 이상적이지 못하게 되고, 모든 집단에서 공통적으로 약점을 드러내어 전체적인 형태동일성 모형의 적합도를 떨어뜨릴 수 있다. 이런 경우 모형의 적합도가 좋지 않음에도 불구하고 측정불변성을 보일 수 있다고 그들은 주장한다.</p>
<p>Meade와 Kroustalis(2006)는 개별적인 문항들을 사용하여 요인모형을 추정한 결과 모형의 적합도가 좋지 않게 드러났을 때 그 이유를 확인하기 위하여 여러 집단에 걸쳐 따로 CFA 모형이나 EFA 모형을 추정하여 그 결과를 확인할 것을 제안하였다. 예를 들어, 집단 간에 따로 CFA 모형이나 EFA 모형을 추정하였는데 한 집단에서는 적합도가 매우 좋고 다른 집단에서는 매우 좋지 않다면 측정불변성 확인을 멈추고, 반면 둘이 서로 비슷하게 좋지 않다면 다음 단계로 가는 것을 고려해 보는 것이다. 또한 추가적으로 만약 EFA 모형의 추정 결과 요인구조가 집단 간에 매우 다르다면 측정불변성 확인 단계를 완전히 멈추고, 반면 만약에 비슷한 요인구조가 나타난다면 형태동일성 모형의 좋지 않은 모형 적합도에도 불구하고 측정불변성 확인 단계를 진행하게 되는 것이다.</p>
<p>이쯤에서 잠재변수의 평균이라는 것을 잠깐 고민해 보자. 잠재변수란 보이지 않는 질적이고 추상적인 개념을 양적으로 형성한 것이다. 이때 양적으로 형성된 잠재변수의 절대값에 특정한 의미가 있는 것은 아님을 이해할 필요가 있다. 예를 들어, 오늘날 사람들이 지능을 측정하기 위해 사용하는 IQ의 평균 100을 중심으로 표준편차 15를 가지도록 설계된 것인데, 만약 IQ의 평균이 1,000이고 표준편차가 150을 가지도록 설계했다면 무슨 문제 될 것이 있을까? 만약 평균을 0으로 하고 표준편차를 1이 되도록 설계했다면 이는 또 무슨 다른 점이 있을까? 지능은 상대적인 것이고 IQ 또한 그 상대성을 반영하는 것이기 때문에 통계적으로나 수학적으로 아무런 차이가 없다. 100을 주심으로 변동성을 가지는 것이 IQ라면 다만 평균적인 지능을 가진 사람의 IQ는 100이 될 것이고, 0을 중심으로 변동성을 가지는 것이 IQ라면 평균적인 지능을 가진 사람의 IQ는 0이 될 뿐이다. 이와 같은 부분은 집단간에 잠재변수의 평균을 추정하는 기술적인 상황에서도 상당히 중요하다. 두 집단에서 각 두 개의 잠재평균을 추정하려고 하면 총 네 개의 추가적인 모수를 추정하는 것이 아니라, 한 집단의 잠재평균들을 모두 0으로 고정하고 다른 집단의 잠재평균이 0 대비 더 큰지 작은지만 추정하여 확인하면 된다. 예를 들어, 남자 집단의 잠재평슌 두 개를 0으로 고정하고 여자 집단의 잠재평균 두 개만 추정하면 된다. 또 한 가지 더, 형태동일성 모형에서 부분측정단위동일성 모형, 이어서 부분절편동일성 모형의 단계는 모형이 점점 단순해지는 과정이지만, 부분절편동일성 모형을 기반으로 잠재평균의 차이를 검정하는 모형은 더 복잡해진 모형이다. 이는 부분절편동일성 모형에서 잠재평균 비교 모형이 모수에 대한 제약을 함으로써 더 진행한 것이 아니고, 두 개의 잠재평균 모수를 더 추정하는 단계이기 때문이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TITLE: Multiple Group CFA <span class="keyword">with</span> strong invariance</span><br><span class="line"></span><br><span class="line">DATA: FILE IS <span class="string">"interest_mplus.csv"</span>;</span><br><span class="line"></span><br><span class="line">VARIABLE: NAMES ARE GEN, EDUC, AGE, COG1-COG6 PER1-PER6 INT1-INT18;</span><br><span class="line">          USEVARIABLES ARE GEN, INT1-INT18;</span><br><span class="line">          GROUPING IS GEN (<span class="number">1</span>=male, <span class="number">2</span>=female);</span><br><span class="line"></span><br><span class="line">ANALYSIS: TYPE = General;</span><br><span class="line"></span><br><span class="line">MODEL: f1 BY INT1 INT2 INT12 INT18;</span><br><span class="line">       f2 BY INT3 INT6 INT8 INT9 INT10 INT13 INT15 INT16 INT17;</span><br><span class="line">       f3 BY INT4 INT5;</span><br><span class="line">       f4 BY INT7 INT11 INT14;</span><br><span class="line">       [INT1-INT18];</span><br><span class="line">       [f1-f4@<span class="number">0</span>];</span><br><span class="line">       INT1-INT18;</span><br><span class="line"></span><br><span class="line">MODEL female:</span><br><span class="line">       [INT11, INT7, INT12]; </span><br><span class="line">       [f1-f4];</span><br><span class="line">       INT1-INT18;</span><br></pre></td></tr></table></figure>
<p>위에서 MODEL female 커맨드를 보면 [f1-f4@0];가 [f1-f4];로 바뀐 것을 확인할 수 있다. 이에 반해 MODEL 커맨드의 [f1-f4@0];는 바뀌지 않았다. 즉, 전체 집단의 모든 잠재평균을 0으로 고정한 상태에서 여자 집단의 두 잠재평균만 자유롭게 추정되도록 설정한 것이다. 이렇게 함으로써 남자 집단의 두 잠재평균은 모두 0인 상태에서 여자 집단의 두 잠재평균 추정치가 상대적으로 어떤 값을 가지게 되느냐를 확인할 수 있다. 만약 여자 집단의 추정치가 양수가 된다면 이는 남자의 잠재평균보다 더 높다는 의미고, 만약 음수가 나온다면 남자의 잠재평균보다 더 낮다는 의미가 된다.</p>
<p><br></br></p>
<h4 id="MIMIC-모형을-이용한-집단-차이-검정"><a href="#MIMIC-모형을-이용한-집단-차이-검정" class="headerlink" title="MIMIC 모형을 이용한 집단 차이 검정"></a>MIMIC 모형을 이용한 집단 차이 검정</h4><p>MIMIC(multiple indicators multiple causes) 모형은 확인적 요인분석모형에 공변수(covariate)가 더해진 모형이다. MIMIC 모형은 잠재변수에 대한 연속형 또는 범주형(특히 이분형) 공변수의 효과를 확인하려고 하는 모형이다. 요인분석모형의 간단한 확장이기 때문에 긴 설명이 필요 없을 만큼 단순한 모형이다. 사실 요인분석모형에 요인을 설명하는 공변수를 더하게 되면 요인분석모형이라기보다는 구조방정식 모형에 더 가까워진다.</p>
<p><br></br></p>
<p><img src="/image/MIMIC.jpeg" alt="MIMIC"></p>
<p><br></br></p>
<p>위 그림에 두 개의 요인과 각 세 개의 지표변수 그리고 하나의 공변수(실제로는 여러 개도 상관없다)가 있는 MIMIC 모형의 경로도가 제공되어 있다. 경로도에 제공된 모형과 MIMIC 모형의 이름을 비교해 보면 multiple indicators는 요인 측정을 위한 여러 개의 지표변수를 가리키며, multiple causes는 요인을 설명하는 여러 개의 공변수를 가리킨다. 위의 경로도에서는 설명오차간 상관을 허락하였는데, 이는 설정할 수도 있고 그렇지 않을 수도 있다. MIMIC 모형은 한편으로는 요인의 구조를 확인하고, 또 한편으로는 공변수의 요인에 대한 영향력을 검정한다. 공변수의 요인에 대한 영향력은 구조모형 또는 회귀모형 부분이다. 즉, 연속형이든 이분형이든 공변수에서 요인들로 향하는 경로는 회귀분석 모형의 기울기 부분이다. 반드시 그렇지는 않지만 일반적으로 MIMIC 모형에서는 공변수가 집단변수인 경우가 흔하다. 이런 경우 공변수의 효과라는 것은 결국 집단 간에 잠재평균의 차이가 있느냐를 의미한다.    </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/21/Python-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/">
                [Python] 추상클래스
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/python/">python</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="예제로-배우는-추상클래스"><a href="#예제로-배우는-추상클래스" class="headerlink" title="예제로 배우는 추상클래스"></a>예제로 배우는 추상클래스</h1><p>파이썬에서 추상클래스를 어떻게 사용하는지에 대해 구글링을 해보다 문득 Java의 정석 책이 생각이 났다.<br>다시금 추상클래스가 무엇인지 짚고 넘어가고 싶어 그 내용을 정리해보았다.</p>
<p><br></br></p>
<h4 id="추상클래스-abstract-class-란"><a href="#추상클래스-abstract-class-란" class="headerlink" title="추상클래스(abstract class)란?"></a>추상클래스(abstract class)란?</h4><p>클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도에 비유할 수 있다. 미완성 설계도란, 단어의 뜻 그대로 완성되지 못한 채로 남겨진 설계도를 말한다. 클래스가 미완성이라는 것은 멤버의 개수에 관계된 것이 아니라, 단지 미완성 메서드(추상메서드)를 포함하고 있다는 의미이다. 미완성 설계도로 완성된 제품을 만들 수 없듯이 추상클래스로 인스턴스는 생성할 수 없다. 추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.</p>
<p>추상클래스 자체로는 클래스로서의 역할을 다 못하지만, 새로운 클래스를 작성하는데 있어서 바탕이 되는 조상클래스로서 중요한 의미를 갖는다. 새로운 클래스를 작성할 때 아무 것도 없는 상태에서 시작하는 것보다는 완전하지는 못하더라도 어느 정도 틀을 갖춘 상태에서 시작하는 것이 나을 것이다.</p>
<p>다시 파이썬으로 돌아와 아래 예제 코드를 살펴보자.</p>
<p><br></br></p>
<h4 id="Character-py"><a href="#Character-py" class="headerlink" title="Character.py"></a>Character.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line">    name = <span class="string">'이름'</span></span><br><span class="line">    hp = <span class="string">'체력'</span></span><br><span class="line">    attack_power = <span class="string">'공격력'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 상대 객체 공격력에 의해 체력 감소</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_damaged</span><span class="params">(self, attack_power)</span>:</span></span><br><span class="line">        self.hp -= attack_power</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 상대 객체를 자신의 공격력만큼 공격하기       </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        other.get_damaged(self.attack_power)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125;의 공격력은 &#123;&#125;, 체력은 &#123;&#125;입니다."</span>.format(self.name, self.attack_power, self.hp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 강화 횟수에 따라 캐릭터 강화하기</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upgrade</span><span class="params">(self, cnt)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>파이썬에서 추상 클래스(abstract class)라는 기능을 제공하는데, 추상 클래스는 앞서 언급했듯이 메서드의 목록만 가진 클래스이며 상속받는 클래스에서 메서드 구현을 강제하기 위해 사용한다. 먼저 추상 클래스를 만들려면 import로 abc 모듈을 가져와야 하며, 글래스의 괄호 안에 metaclass=ABCMeta를 지정하고, 메서드를 만들 때 위에 @abstractmethod를 붙여서 추상메서드를 지정한다. 물론 이와 같이 구현하는 방법도 중요하겠지만, 도대체 위의 코드에서 어떠한 의도로 왜 추상클래스를 사용하게 된 것인지 생각해보자.</p>
<p>위의 예시코드는 사용자가 몬스터와 대결하는 간단한 게임을 구현하기 위한 것이다. 게임에 존재하는 캐릭터는 체력, 공격력, 이를 이용하는 공격하기, 공격받으면 데미지를 입는 등의 공통적으로 지니는 특성들이 존재한다. 따라서 게임의 모든 캐릭터가 가진 공통 속성을 정의하는 Character 클래스를 추상클래스로 정의한다. 이를 통해 추상클래스의 자식 클래스인 사용자 캐릭터와 몬스터 캐릭터를 아래와 같이 구현할 수 있다.</p>
<p><br></br></p>
<h4 id="Player-py"><a href="#Player-py" class="headerlink" title="Player.py"></a>Player.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> character <span class="keyword">import</span> Character</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">(Character)</span>:</span> <span class="comment"># 캐릭터클래스 상속</span></span><br><span class="line">    <span class="comment"># 이름 입력받고 속성 초기화하기</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.hp = <span class="number">2000</span></span><br><span class="line">        self.attack_power = <span class="number">500</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 강화 횟수에 따라 사용자 속성 강화하기</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upgrade</span><span class="params">(self, cnt)</span>:</span></span><br><span class="line">        self.hp += cnt*<span class="number">1000</span></span><br><span class="line">        self.attack_power += cnt*<span class="number">500</span></span><br></pre></td></tr></table></figure>
<h4 id="Bossmon-py"><a href="#Bossmon-py" class="headerlink" title="Bossmon.py"></a>Bossmon.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> character <span class="keyword">import</span> Character</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BossMon</span><span class="params">(Character)</span>:</span> <span class="comment"># 캐릭터클래스 상속</span></span><br><span class="line">    <span class="comment"># 보스 속성 초기화하기</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'보스'</span></span><br><span class="line">        self.hp = <span class="number">5000</span></span><br><span class="line">        self.attack_power = <span class="number">1500</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 강화 횟수에 따라 보스 속성 강화하기</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upgrade</span><span class="params">(self, cnt)</span>:</span></span><br><span class="line">        self.hp += cnt * <span class="number">300</span></span><br></pre></td></tr></table></figure>
<p>위의 코드에서 알 수 있듯이 upgrade 메서드만 사용자 캐릭터와 몬스터 캐릭터에 차이가 있고, 나머지 기능을 동일한 것을 알 수 있다. 그래서 캐릭터 추상클래스에서 upgrade 메서드에 데코레이터를 지정하여 추상메서드로 사용한 것이다. 즉, 동일한 메서드이지만 미완성 메서드로 정의함으로써 캐릭터 클래스를 상속받아 사용할 때 서로 다르게 동작할 수 있도록 한 것이다. 여기서 알 수 있듯 게임 속 캐릭터들의 공통적인 동작에 관한 코드는 추상클래스에 정의되어 있으므로 코드의 중복을 줄일 수 있으며, 동일한 upgrade 기능에 대해서 생성되는 각기 다른 캐릭터마다 서로 다르게 동작할 수 있도록 미완성 메서드로 남겨둔 것을 알 수 있다. 이제 위의 캐릭터들이 실제 동작하는 본 무대를 살펴보자.</p>
<p><br></br></p>
<h4 id="Main-py"><a href="#Main-py" class="headerlink" title="Main.py"></a>Main.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> player <span class="keyword">import</span> Player</span><br><span class="line"><span class="keyword">from</span> bossmon <span class="keyword">import</span> BossMon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 사용자가 캐릭터의 이름을 입력하여 캐릭터를 생성하기</span></span><br><span class="line">player = Player(input(<span class="string">'캐릭터 이름을 지어주세요! '</span>))</span><br><span class="line">bossmon = BossMon()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 사용자로부터 강화 횟수를 입력 받기</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cnt = int(input(<span class="string">'강화를 몇 번 하시겠습니까? '</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        print(<span class="string">'숫자를 입력해주세요...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 강화 횟수에 따라 캐릭터 강화하고 캐릭터 속성 출력하기</span></span><br><span class="line">player.upgrade(cnt)</span><br><span class="line">bossmon.upgrade(cnt)</span><br><span class="line">print()</span><br><span class="line">print(player.__str__())</span><br><span class="line">print(bossmon.__str__())</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 사용자가 보스와 대결하기</span></span><br><span class="line">turn = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    turn += <span class="number">1</span></span><br><span class="line">    player.attack(bossmon)</span><br><span class="line">    print(<span class="string">'&#123;3&#125;. &#123;0&#125;가 &#123;1&#125;를 공격 -&gt; &#123;1&#125;의 체력: &#123;2&#125;'</span>.format(player.name, bossmon.name, bossmon.hp, turn))</span><br><span class="line">    <span class="keyword">if</span> bossmon.hp &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    turn += <span class="number">1</span></span><br><span class="line">    bossmon.attack(player)</span><br><span class="line">    print(<span class="string">'&#123;3&#125;. &#123;0&#125;가 &#123;1&#125;를 공격 -&gt; &#123;1&#125;의 체력: &#123;2&#125;'</span>.format(bossmon.name, player.name, player.hp, turn))</span><br><span class="line">    <span class="keyword">if</span> player.hp &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 대결 결과 출력하기</span></span><br><span class="line">print()</span><br><span class="line"><span class="keyword">if</span> player.hp &gt; bossmon.hp:</span><br><span class="line">     print(<span class="string">'&#123;0&#125;가 &#123;1&#125;턴만에 보스를 처치했습니다! &#123;0&#125;는 보스를 처치하고도 체력이 &#123;2&#125;이나 남아있군요!'</span>.format(player.name, turn, player.hp))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'보스를 처치할 수 없습니다.'</span>)</span><br></pre></td></tr></table></figure>
<p>잠시 위의 코드에서 알아두어야 할 부분을 간단히 설명하도록 하겠다. 추상클래스인 캐릭터 클래스부터 사용된 <strong>str</strong> 메서드는 스페셜 메서드라 한다. 이는 파이썬에 의해 호출되는(프로그래머가 그 이름을 직접 명시하여 호출하지 않는) 메서드이며, 객체 생성 시 자동으로 호출되는 메서드이다. 따라서 아래와 같은 형태의 함수 호출이 가능하며, 실제로는 위의 코드와 같은 형태의 메서드 호출로 이어지게 된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(str(player))</span><br><span class="line">print(str(bossmon))</span><br></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/21/Vuejs-%ED%95%84%EC%88%98%EA%B8%B0%EC%88%A0-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/">
                [Vuejs] 필수기술 살펴보기
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/vuejs/">vuejs</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Vue-js-입문하기"><a href="#Vue-js-입문하기" class="headerlink" title="Vue.js 입문하기"></a>Vue.js 입문하기</h1><h6 id="본-포스팅은-Do-it-Vue-js-입문을-바탕으로-합니다"><a href="#본-포스팅은-Do-it-Vue-js-입문을-바탕으로-합니다" class="headerlink" title="본 포스팅은 Do it! Vue.js 입문을 바탕으로 합니다."></a>본 포스팅은 <strong>Do it! Vue.js 입문</strong>을 바탕으로 합니다.</h6><p><br></br></p>
<h3 id="첫째마당-Vue-js-필수-기술-살펴보기"><a href="#첫째마당-Vue-js-필수-기술-살펴보기" class="headerlink" title="[첫째마당] Vue.js 필수 기술 살펴보기"></a>[첫째마당] Vue.js 필수 기술 살펴보기</h3><p>첫째마당의 목표는 Vue.js로 화면을 개발하기 위한 필수 요소를 학습하고, 간단한 웹 페이지부터 상용 애플리케이션까지 Vue.js로 애플리케이션을 개발하는 데 필요한 핵심 기술들을 익히는 것입니다.</p>
<p><br></br></p>
<h3 id="01-Vue-js-소개"><a href="#01-Vue-js-소개" class="headerlink" title="01. Vue.js 소개"></a>01. Vue.js 소개</h3><h5 id="1-Vue-js란-무엇인가"><a href="#1-Vue-js란-무엇인가" class="headerlink" title="(1) Vue.js란 무엇인가?"></a>(1) Vue.js란 무엇인가?</h5><p>Vue.js는웹 페이지 화면을 개발하기 위한 프런트앤드 프레임워크입니다. 기존 웹 개발자뿐만 아니라 HTML, CSS, 자바스크립트 기초만 아는 웹 개발 입문자 및 컴퓨터 비전공자들도 배우기 쉽게 만들어졌습니다. 뷰는 화면단 라이브러리이자 프레임워크라고도 볼 수 있습니다. 프레임워크란 개발자들의 개발 생산성을 높이기 위해 일정한 틀과 규칙에 따라 개발하도록 미리 구조를 정의해 놓은 도구이며, 라이브러리란 자주 사용되는 기능들을 모아 재활용할 수 있도록 정리한 기술 모음집입니다. </p>
<p><br></br></p>
<p><img src="/image/VUE1.png" alt="VUE1"></p>
<p><br></br></p>
<p>위 그림은 뷰의 창시자인 에반 유(Evan You)가 2017년 Vue.js 컨퍼런스에서 발표한 프레젠테이션에서 사용한 그림입니다. 뷰 코어 라이브러리는 화면단 데이터 표현에 관한 기능들을 중점적으로 지원하지만 프레임워크의 기능인 라우터, 상태 관리, 테스팅 등을 쉽게 결합할 수 있는 형태로도 제공됩니다. 즉, 라이브러리 역할뿐만 아니라 프레임워크 역할도 할 수 있다는 의미입니다. 그래서 공식 사이트에서도 뷰를 점진적인 프레임워크(progressive framework)라고 부르고 있습니다. 이후 설명부터는 헷갈리지 않게 일괄적으로 프레임워크라고 하겠습니다.</p>
<h6 id="프레임워크-시장-속에서-뷰의-위치와-성장성"><a href="#프레임워크-시장-속에서-뷰의-위치와-성장성" class="headerlink" title="프레임워크 시장 속에서 뷰의 위치와 성장성"></a>프레임워크 시장 속에서 뷰의 위치와 성장성</h6><p>최근 프론트엔드 프레임워크 시장은 리액트와 앵귤러가 높은 점유율을 차지하고 있습니다. 리액트와 앵귤러가 상대적으로 오래된 프레임워크이기도 하고, 이미 많은 기업에서 시스템을 해당 프레임워크로 구축해 서비스하고 있기 때문이죠.</p>
<p>뷰의 창시자인 에반도 구글에서 일할 당시 브라우저 상에서 많은 프로토타이핑 작업을 앵귤러로 구현하였습니다. 에반은 앵귤러의 데이터 바인딩 방식과 돔(DOM)에 직접 접근하지 않고도 데이터를 표현하는 방식에 흥미를 느꼈습니다. 돔이란 HTML 문서에 들어가는 요소의 정보를 담고 있는 데이터 트리이다. 하지만 앵귤러를 이해하기 위해서는 방대한 크기의 프레임워크 구조를 이해해야 했기에 부담을 느꼈죠. 그래서 에반은 앵귤러의 명시적 데이터 바인딩과 같은 필수적인 요소들만 가지고 화면을 구현하기 시작했고, 오픈 소스화하면서 많은 사람들이 참여하여 프레임워크의 기능을 붙여 나가기 시작했습니다. 그리하여 뷰가 탄생했습니다. </p>
<h6 id="뷰의-장점"><a href="#뷰의-장점" class="headerlink" title="뷰의 장점"></a>뷰의 장점</h6><p>빠르게 변화하는 프런트엔드 시장에서 뷰는 해결사 같은 존재입니다. 일단 첫째, 배우기가 쉽습니다. HTML, CSS, 자바스크립트의 기초만 아는 입문자라도 하루 안에 배울 수 있고, 익숙한 실무 개발자라면 몇 시간 이내에 배울 수 있습니다. 둘째, 리액트와 앵귤러에 비해 성능이 우수하고 빠릅니다. 뷰 제작팀에서 리액트와 앵귤러를 가지고 같은 테스트 케이스에서 성능을 비교한 결과 뷰가 가장 빠른 것으로 나타났습니다. 셋째, 리액트의 장점과 앵귤러의 장점을 갖고 있습니다. 앞 에서 보았듯이 뷰는 구글에서 일하던 직원이 앵귤러를 더 가볍게 쓰고 싶어서 만든 프레임워크입니다. 앵귤러의 데이터 바인딩 특성과 리액트의 가상 돔(Virtual DOM) 기반 랜더링 특징을 모두 가지고 있습니다.</p>
<p>데이터 바인딩(data binding)은 뷰와 모델을 하나로 연결하는 것을 의미합니다. 구조화된 웹 어플리케이션을 구축하기 위해서는 뷰와 모델의 분리가 필수적입니다. 하지만 뷰와 모델이 유기적으로 동작하여야 하기 때문에 데이터 바인딩이 이러한 모순을 해결해줍니다. 가상 돔(Virtual DOM)은 간단히 브라우저를 위한 버퍼정도로 생각됩니다.<br>이처럼 다른 프레임워크들에 비해 성능이 우수할 뿐만 아니라 가볍고 빠르며, 무엇보다도 누구나 쉽게 배울 수 있다는 점이 앞으로 더 많은 사용자들의 흥미와 학습 욕구를 유발하는 결정적인 원인이 될 것입니다.  </p>
<p><br></br></p>
<h3 id="Vue-js의-특징"><a href="#Vue-js의-특징" class="headerlink" title="Vue.js의 특징"></a>Vue.js의 특징</h3><p>이제 뷰의 특징을 함께 살펴보겠습니다.</p>
<h6 id="UI-화면단-라이브러리"><a href="#UI-화면단-라이브러리" class="headerlink" title="UI 화면단 라이브러리"></a>UI 화면단 라이브러리</h6><p>뷰는 UI 화면 개발 방법 중 하나인 MVVM 패턴의 뷰 모델에 해당하는 화면단 라이브러리입니다. 위키피디아에 의하면 MVVM(Model - View - ViewModel) 패턴을 다음과 같이 정의하고 있습니다. 마크업 언어나 GUI 코드를 비지니스 로직 또는 백엔드 로직과 분리하여 개발하는 소프트웨어 디자인 패턴이라고 합니다. 이 정의를 다시 정리해 보면, ‘화면 앞단(프런트엔드)의 화면 동작과 관련된 로직과 화면 뒷단(백엔드)의 데이터베이스 데이터 처리 로직을 분리하여 깔끔하게 코드를 구성한다’는 것입니다. </p>
<p>참고로 웹 초창기에는 프런트엔드 영역이라는 구분이 따로 없었습니다. 화면 요소를 꾸미는 HTML, CSS 코드와 데이터베이스에서 데이터를 가져와 제어하는 Java 코드가 한 파일에 섞이면서 가독성이 현저하게 떨어졌습니다. 이러한 코드 때문에 작성자뿐만 아니라 협업자들도 소스 코드를 읽는데 애를 먹었습니다. 그래서 이러한 문제점을 해결하기 위한 일환으로 MVVM 패턴을 사용하기 시작한 것이죠. MVVM 패턴은 뷰뿐만 아니라 최신 프런트엔드 프레임워크인 리액트에도 적용되어 있을 정도로 요즘에는 대중적인 화면 개발 패턴으로 자리매김했습니다.</p>
<p><br></br></p>
<p><img src="/image/VUE2.png" alt="VUE2"></p>
<p><br></br></p>
<p>위 그림에서 볼 수 있듯이 MVVM 패턴이란 화면을 모델 - 뷰 - 뷰 모델로 구조화하여 개발하는 방식을 의미합니다. 이러한 방식으로 개발하는 이유는 화면의 요소들을 제어하는 코드와 데이터 제어 로직을 분리하여 코드를 더 직관적으로 이해할 수 있고, 추후 유지 보수가 편해지기 때문입니다.<br>좀 더 쉽게 이해하기 위해 위 구조도의 용어를 하나하나 살펴보겠습니다.</p>
<p><br></br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><center>용어</center></th>
<th style="text-align:center"><center>설명</center></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>뷰(view)</strong></td>
<td style="text-align:center">사용자에게 보이는 화면</td>
</tr>
<tr>
<td style="text-align:left"><strong>돔(DOM)</strong></td>
<td style="text-align:center">HTML 문서에 들어가는 요소(태그, 클래스, 속성 등)의 정보를 담고 있는 데이터 트리</td>
</tr>
<tr>
<td style="text-align:left"><strong>돔 리스너(DOM Listener)</strong></td>
<td style="text-align:center">돔의 변경 내역에 대해 즉각적으로 반응하여 특정 로직을 수행하는 장치</td>
</tr>
<tr>
<td style="text-align:left"><strong>모델(Model)</strong></td>
<td style="text-align:center">데이터를 담는 용기, 보통은 서버에서 가져온 데이터를 자바스크립트 객체 형태로 저장</td>
</tr>
<tr>
<td style="text-align:left"><strong>데이터 바인딩(Data Binding)</strong></td>
<td style="text-align:center">뷰(View)에 표시되는 내용과 모델의 데이터를 동기화</td>
</tr>
<tr>
<td style="text-align:left"><strong>뷰 모델(ViewModel)</strong></td>
<td style="text-align:center">뷰와 모델의 중간 영역, 돔 리스너와 데이터 바인딩을 제공하는 영역</td>
</tr>
</tbody>
</table>
</div>
<p><br></br></p>
<h6 id="MVVM-구조의-처리-흐름"><a href="#MVVM-구조의-처리-흐름" class="headerlink" title="MVVM 구조의 처리 흐름"></a>MVVM 구조의 처리 흐름</h6><p>앞 구조도의 처리 흐름을 이해하기 위해 구글 사이트에서 검색어를 입력하여 살펴보겠습니다. 사이트에 접속하여 검색 창에 검색어를 입력하고 [Google 검색] 버튼을 클릭합니다. 여기서 뷰(View)는 사용자에게 비춰지는 구글 검색 화면 전체를 의미합니다. 그리고 돔(DOM)은 구글 로고, 검색 창, 키보드와 마이크 아이콘, 버튼 등 화면에 나타나는 HTML 문서 상의 모든 요소를 의미하죠. 검색 버튼을 클릭하면 어떤 일이 일어날까요? 검색 결과가 나타나겠죠. 검색 버튼을 클릭했을 때 돔 리스너에서 버튼의 클릭을 감지합니다. 그리고 버튼이 동작하면 검색 결과를 보여주는 로직이 처리되겠죠. 여기서 로직이란, 특정 기능을 구현하기 위한 처리 흐름을 말합니다. 이 처리 과정에서 데이터 바인딩이 관여하는데, 검색 결과에 해당하는 데이터를 모델에서 가져와 화면에 나타내 줍니다. 다른 단어를 검색해도 처리 과정은 같습니다.</p>
<p>이처럼 뷰는 화면의 요소가 변경되거나 조작이 일어날 때 즉각적으로 반응하여 화면의 데이터를 갱신하여 보여 주는 역할을 합니다. 화면의 표현에 주로 관여하는 라이브러리이기 때문에 화면단 라이브러리라고도 합니다.</p>
<p><br></br></p>
<h6 id="컴포넌트-기반-프레임워크"><a href="#컴포넌트-기반-프레임워크" class="headerlink" title="컴포넌트 기반 프레임워크"></a>컴포넌트 기반 프레임워크</h6><p>뷰가 가지는 또 하나의 큰 특징은 바로 컴포넌트(Component) 기반 프레임워크라는 점입니다. </p>
<p><br></br></p>
<p><img src="/image/VUE3.png" alt="VUE3"></p>
<p><br></br></p>
<p>컴포넌트란 마치 레고 블록과 같습니다. 레고 블록을 잘 조합해서 쌓으면 원하는 모형을 만들 수 있듯이 뷰의 컴포넌트를 조합하여 화면을 구성할 수 있습니다. 위 그림의 왼쪽 화면은 각 영역을 컴포넌트로 지정하여 구분한 것이고, 오른쪽 그림은 왼쪽 화면의 각 컴포넌트 간의 관계를 나타낸 것입니다. </p>
<p>최신 프런트엔드 프레임워크인 리액트, 앵귤러 모두 컴포넌트 기반의 개발 방식을 추구하고 있습니다. 컴포넌트 기반 방식으로 개발하는 이유는 코드를 재사용하기가 쉽기 때문입니다. 그리고 뷰의 경우 컴포넌트를 썼을 때 HTML 코드에서 화면의 구조를 직관적으로 파악할 수 있습니다. 따라서 프레임워크 자체에서 컴포넌트 방식을 추구하면 모두가 정해진 방식대로 컴포넌트를 활용하므로 빠르게 구현할 수 있을 뿐만 아니라 남이 작성한 코드를 볼 때도 수월해집니다.</p>
<p><br></br></p>
<h3 id="02-개발-환경-설정-및-첫-번째-프로젝트"><a href="#02-개발-환경-설정-및-첫-번째-프로젝트" class="headerlink" title="02. 개발 환경 설정 및 첫 번째 프로젝트"></a>02. 개발 환경 설정 및 첫 번째 프로젝트</h3><h5 id="2-Hello-Vue-js-프로젝트-만들기"><a href="#2-Hello-Vue-js-프로젝트-만들기" class="headerlink" title="(2) Hello Vue.js! 프로젝트 만들기"></a>(2) Hello Vue.js! 프로젝트 만들기</h5><h6 id="뷰-시작하기"><a href="#뷰-시작하기" class="headerlink" title="뷰 시작하기"></a>뷰 시작하기</h6><p>개발 환경을 구성했다면 이제 뷰를 사용하여 간단한 메시지를 출력해 보겠습니다. 뷰를 사용하는 방법이 얼마나 쉽고 간편한지 직접 확인할 수 있을 것입니다. 작업 순서는 아래와 같습니다.</p>
<p><br></br></p>
<p><img src="/image/VUE4.png" alt="VUE4"></p>
<p><br></br></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">dir</span>=<span class="string">"ltr"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Sample<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &lt;&lt;div id="app"&gt;</span><br><span class="line">      &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">          message: <span class="string">'Hello Vue.js!'</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>위 코드는 html 기본 구조에 <div> 태그를 하나 추가하고, 뷰 라이브러리를 로딩한 후 뷰로 Hello Vue.js!라는 간단한 메시지를 출력하는 코드입니다. 뷰 인스턴스를 만들고 인스턴스에 정의된 데이터 객체의 메시지 프로퍼티(property)를 화면에 출력하죠. 무슨 소린지 모르겠다고요? 괜찮습니다. 곧 상세히 알아보겠습니다.</p>
<p>이 실습 예제에서 중요한 건 이렇게 HTML 문서에서 코드 몇 줄로 뷰를 바로 실행할 수 있다는 사실입니다. 이 때문에 웹 개발자 커뮤니티에서 종종 ‘뷰가 제이쿼리보다 적용하기 쉽다’는 말이 나옵니다. 제이쿼리는 HTML 문서의 돔 요소에 쉽게 접근하도록 유용한 기능을 제공하는 자바스크립트 라이브러리입니다. 자, 그럼 위 코드를 실행하기 위해 크롬 브라우저를 엽니다. 그럼 화면에 정상적으로 Hello Vue.js!라고 보일 것입니다.</p>
<p><br></br></p>
<h6 id="크롬-개발자-도구로-코드-확인하기"><a href="#크롬-개발자-도구로-코드-확인하기" class="headerlink" title="크롬 개발자 도구로 코드 확인하기"></a>크롬 개발자 도구로 코드 확인하기</h6><p>그럼 앞에서 실행한 예제가 뷰 라이브러리를 정상적으로 로딩하였는지 확인하기 위해 크롬 개발자 도구의 Console 패널을 살펴보겠습니다. </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Download the Vue Devtools extension for a better development experience:</span><br><span class="line">https://github.com/vuejs/vue-devtools</span><br><span class="line"></span><br><span class="line">vue.js:8237 You are running Vue in development mode.</span><br><span class="line">Make sure to turn on production mode when deploying for production.</span><br><span class="line">See more tips at https://vuejs.org/guide/deployment.html</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"> 위 로그를 통해 뷰 라이브러리가 정상적으로 로딩이 되었고, 현재 개발자 모드로 뷰가 실행되고 있다는 것도 파악하였습니다. </span><br><span class="line"></span><br><span class="line">![VUE5](/image/VUE5.png)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">### 03. 화면을 개발하기 위한 필수 단위 - 인스턴스 &amp; 컴포넌트</span><br><span class="line"></span><br><span class="line">##### (1) 뷰 인스턴스</span><br><span class="line"></span><br><span class="line">###### 뷰 인스턴스의 정의와 속성</span><br><span class="line"></span><br><span class="line">뷰 인스턴스는 뷰로 화면을 개발하기 위해 필수적으로 생성해야 하는 기본 단위입니다. 앞 장에서 'Hello Vue.js!' 텍스트가 화면에 표시된 것은 인스턴스가 있었기 때문에 가능한 것이죠. 이처럼 인스턴스는 뷰로 화면을 개발하기 위해 빠트릴 수 없는 필수 조건입니다. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">뷰 인스턴스를 사용하기 위해 아래와 같은 형식으로 뷰 인스턴스를 생성합니다.</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">new Vue(&#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>그럼 ‘Hello Vue.js!’ 샘플 코드에서 인스턴스와 관계된 부분을 다시 한 번 살펴보겠습니다. 먼저 ‘Hello Vue.js!’ 텍스트를 화면에 표시하기 위해 new Vue()로 뷰 인스턴스를 생성하였습니다. 그럼 ‘Hello Vue.js!’ 샘플 코드에서 인스턴스와 관계된 부분을 다시 한 번 살펴보겠습니다. 그리고 인스턴스 안에 el 속성으로 뷰 인스턴스가 그려질 지점을 지정하고, data 속성에 message 값을 정의하여 화면의 에 연결하였습니다. 그럼 각 요소에 대해 자세히 알아봅시다.</p>
<p><br></br></p>
<h6 id="뷰-인스턴스-생성자"><a href="#뷰-인스턴스-생성자" class="headerlink" title="뷰 인스턴스 생성자"></a>뷰 인스턴스 생성자</h6><p>new Vue()로 인스턴스를 생성할 때 Vue를 생성자라고 합니다. Vue 생성자는 뷰 라이브러리를 로딩하고 나면 접근할 수 있습니다. 생성자를 사용하는 이유는 뷰로 개발할 때 필요한 기능들을 생성자에 미리 정의해 놓고 사용자가 그 기능을 재정의하여 편리하게 사용하도록 하기 위해서입니다. 생성자란 객체를 새로 생성할 때 자주 사용하는 옵션과 기능들을 미리 특정 객체에 저장해 놓고, 새로 객체를 생성할 때 기존에 포함된 기능과 더불어 기존 기능을 쉽게 확장하여 사용하는 기법입니다. 일반적으로 객체지향 프로그래밍에서 사용하는 객체 정의 방식으로 미리 정의된 속성과 메서드를 재활용하기 위해 사용합니다.</p>
<p><br></br></p>
<h6 id="뷰-인스턴스-옵션-속성"><a href="#뷰-인스턴스-옵션-속성" class="headerlink" title="뷰 인스턴스 옵션 속성"></a>뷰 인스턴스 옵션 속성</h6><p>뷰 인스턴스 옵션 속성은 인스턴스를 생성할 때 재정의할 data, el, template 등의 속성을 의미합니다. 예를 들어, Hello Vue.js! 예제에서는 data라는 미리 정의되어 있는 속성을 사용하였습니다. 우리는 그 안에 message라는 새로운 속성을 추가하고 Hello Vue.js!라는 값을 주었을 뿐이죠. el 속성 역시 미리 정의되어 있으며 뷰로 만든 화면이 그려지는 시작점을 의미합니다. 뷰 인스턴스로 화면을 렌더링할 때 화면이 그려질 위치의 돔 요소를 지정해 주어야 합니다.</p>
<p>여기서 #app 값은 화면의 돔 요소 중 app이라는 아이디를 가진 요소를 의미합니다. 여기서 사용한 # 선택자는 CSS 선택자 규칙과 같습니다. 이는 해당 아이디를 가진 돔 요소를 검색할 때 사용하며, 선택자는 해당 클래스를 가진 돔 요소를 검색할 때 사용합니다. </p>
<p>이 외에도 template, methods, created 등 미리 정의되어 있는 속성을 사용할 수 있습니다.</p>
<p><br></br></p>
<p>new Vue()로 인스턴스를 생성할 때 Vue를 생성자라고 합니다. Vue 생성자는 뷰 라이브러리를 로딩하고 나면 접근할 수 있습니다. 생성자를 사용하는 이유는 뷰로 개발할 때 필요한 기능들을 생성자에 미리 정의해 놓고 사용자가 그 기능을 재정의하여 편리하게 사용하도록 하기 위해서입니다. 생성자는 객체를 새로 생성할 때 자주 사용하는 옵션과 기능들을 미리 특정 객체에 저장해 놓고, 새로 객체를 생성할 때 기존에 포함된 기능과 더불어 기존 기능을 쉽게 확장하여 사용하는 기법입니다. 일반적으로 객체 지향 프로그래밍에서 사용하는 객체 정의 방식으로 미리 정의된 속성과 메서드를 재활용하기 위해 사용합니다.</p>
<p><br></br></p>
<h6 id="뷰-인스턴스-옵션-속성-1"><a href="#뷰-인스턴스-옵션-속성-1" class="headerlink" title="뷰 인스턴스 옵션 속성"></a>뷰 인스턴스 옵션 속성</h6><p>뷰 인스턴스 옵션 속성은 인스턴스를 생성할 때 재정의할 data, el, template 등의 속성을 의미합니다. 예를 들어, Hello Vue.js! 예제에서는 data라는 미리 정의되어 있는 속성을 사용하였습니다. 우리는 그 안에 message라는 새로운 속성을 추가하고 Hello Vue.js!라는 값을 주었을 뿐이죠. el 속성 역시 미리 정의되어 있으며 뷰로 만든 화면이 그려지는 시작점을 의미합니다. 뷰 인스턴스 화면을 랜더링할 때 화면이 그려질 위치의 돔 요소를 지정해 주어야 합니다. 여기서 #app 값은 화면의 돔 요소 중 app이라는 아이디를 가진 요소를 의미합니다. 여기서 사용한 # 선택자는 CSS 선택자 규칙과 같습니다. CSS 선택자 중 # 선택자는 해당 아이디를 가진 돔 요소를 검색할 때 사용합니다. 그리고 선택자는 해당 클래스를 가진 돔 요소를 검색할 때 사용합니다. </p>
<p><br></br></p>
<h6 id="뷰-인스턴스의-유효-범위"><a href="#뷰-인스턴스의-유효-범위" class="headerlink" title="뷰 인스턴스의 유효 범위"></a>뷰 인스턴스의 유효 범위</h6><p>뷰 인스턴스를 생성하면 HTML의 특정 범위 안에서만 옵션 속성들이 적용되어 나타납니다. 이를 인스턴스의 유효 범위라고 합니다. 다음 절에서 다루는 지역 컴포넌트와 전역 컴포넌트의 차이점을 이해하기 위해서도 꼭 알아야 하는 개념이며, 인스턴스의 유효 범위는 el 속성과 밀접한 관계가 있습니다.</p>
<p>인스턴스의 유효 범위를 이해하려면 인스턴스가 생성된 후 화면에 어떻게 적용되는지 알아야 합니다. new Vue()로 인스턴스를 생성하고 나서 화면에 인스턴스 옵션 속성을 적용하는 과정은 다음과 같습니다.</p>
<p><br></br></p>
<h6 id="뷰-인스턴스의-유효-범위-1"><a href="#뷰-인스턴스의-유효-범위-1" class="headerlink" title="뷰 인스턴스의 유효 범위"></a>뷰 인스턴스의 유효 범위</h6><p>뷰 인스턴스를 생성하면 HTML의 특정 범위 안에서만 옵션 속성들이 적용되어 나타납니다. 이를 인스턴스의 유효 범위라고 합니다. 다음 절에서 다루는 지역 컴포넌트와 전역 컴포넌트의 차이점을 이해하기 위해서도 꼭 알아야 하는 개념이며, 인스턴스의 유효 범위는 el 속성과 밀접한 관계가 있습니다.</p>
<p>인스턴스의 유효 범위를 이해하려면 인스턴스가 생성된 후 화면에 어떻게 적용되는지 알아야 합니다. new Vue()로 인스턴스를 생성하고 나서 화면에 인스턴스 옵션 속성을 적용하는 과정은 다음과 같습니다.</p>
<p><br></br></p>
<p><img src="/image/VUE6.png" alt="VUE6"></p>
<p><br></br></p>
<p>이 과정을 이해하기 위해 Hello Vue.js 샘플 코드의 인스턴스 정의 부분을 자세히 살펴보겠습니다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: '#app',</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: 'Hello Vue.js!'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>먼저 자바스크립트 코드 상에서 인스턴스 옵션 속성 el과 data를 인스턴스에 정의하고 new Vue()로 인스턴스를 생성합니다. 그리고 브라우저에서 위 샘플 코드를 실행하면 아래와 같이 el 속성에 지정한 화면 요소(돔)에 인스턴스가 부착됩니다.</p>
<p><br></br></p>
<p><img src="/image/VUE7.png" alt="VUE7"></p>
<p><br></br></p>
<p>el 속성에 인스턴스가 부착되고 나면 인스턴스에 정의한 옵션 객체의 내용(data 속성)이 el 속성에 지정한 화면 요소와 그 이하 레벨의 화면 요소에 적용되어 값이 치환됩니다.</p>
<p><br></br></p>
<p><img src="/image/VUE8.png" alt="VUE8"></p>
<p><br></br></p>
<p>data 속성의 message 값 Hello Vue.js!가 와 치환됩니다.</p>
<p><br></br></p>
<p><img src="/image/VUE9.png" alt="VUE9"></p>
<p><br></br></p>
<h6 id="인스턴스의-유효-범위-확인"><a href="#인스턴스의-유효-범위-확인" class="headerlink" title="인스턴스의 유효 범위 확인"></a>인스턴스의 유효 범위 확인</h6><p>그런데 만약 인스턴스의 유효 범위를 벗어나면 어떻게 될까요? 앞에서 살펴본 코드를 살짝 변경해보겠습니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 인스턴스의 유효 범위를 벗어나 선언한 message</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>이 코드의 실행 결과는 화면에 가 보이게 됩니다. 즉, message 속성의 값이 Hello Vue.js!로 바뀌지 않고 그대로 출력되는 이유는 인스턴스의 유효 범위 때문입니다. 현재 코드에서 유효 범위는 el 속성으로 지정한 <div id="app"> 태그 아래에 오는 요소들로 제한됩니다. 따라서 <div> 태그 바깥에 있는 는 뷰에서 인식하지 못 하기 때문에 Hello Vue.js!로 바뀌지 않고  그대로 출력됩니다.</p>
<p><br></br></p>
<h6 id="뷰-인스턴스-라이프-사이클"><a href="#뷰-인스턴스-라이프-사이클" class="headerlink" title="뷰 인스턴스 라이프 사이클"></a>뷰 인스턴스 라이프 사이클</h6><p>앞에서 살펴본 인스턴스의 속성 중 created를 기억하나요? 인스턴스가 생성되었을 때 호출할 동작을 정의하는 속성이라고 설명했습니다. 이처럼 인스턴스의 상태에 따라 호출할 수 있는 속성들을 라이프 사이클(life cycle) 속성이라고 합니다. 그리고 각 라이프 사이클 속성에서 실행되는 커스텀 로직을 라이프 사이클 훅(hook)이라고 합니다. 여기서 커스텀 로직은 개발자가 임의로 작성한 추가 로직을 말합니다. 라이프 사이클 속성에는 created, beforeCreate, beforeMount, mounted 등 인스턴스의 생성, 변경, 소멸과 관련되어 총 8개가 있습니다.</p>
<p>라이프 사이클 단계를 크게 나누면 인스턴스의 생성, 생성된 인스턴스를 화면에 부착, 화면에 부착된 인스턴스의 내용이 갱신, 인스턴스가 제거되는 소멸의 4단계로 아루어집니다. 그리고 각 단계 사이에 라이프 사이클 속성 created, mounted, updated 등이 실행됩니다. 그럼 각 라이프 사이클 속성을 좀 더 자세히 살펴보겠습니다.</p>
<p><br></br></p>
<h6 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h6><p>인스턴스가 생성되고 나서 가장 처음으로 실행되는 라이프 사이클 단계입니다. 이 단계에서는 data 속성과 methods 속성이 아직 인스턴스에 정의되어 있지 않고, 돔과 같은 화면 요소에도 접근할 수 없습니다.</p>
<p><br></br></p>
<h6 id="created"><a href="#created" class="headerlink" title="created"></a>created</h6><p>beforeCreate 라이프 사이클 단계 다음에 실행되는 단계입니다. data 속성과 methods 속성이 정의되었기 때문에 this.data 또는 this.fetchData() 와 같은 로직들을 이용하여 data 속성과 methods 속성에 정의된 값에 접근하여 로직을 실행할 수 있습니다. 다만, 아직 인스턴스가 화면 요소에 부착되기 전이기 때문에 template 속성에 정의된 돔 요소로 접근할 수 없습니다.</p>
<p>그리고 data 속성과 methods 속성에 접근할 수 있는 가장 첫 라이프 사이클 단계이자 컴포넌트가 생성되고 나서 실행되는 단계이기 때문에 서버에 데이터를 요청하여 받아오는 로직을 수행하기 좋습니다. 서버에 데이터를 요청하는 HTTP 통신 방법은 다른 포스팅에서 자세히 다루겠습니다.</p>
<p><br></br></p>
<h6 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h6><p>create 단계 이후 template 속성에 지정한 마크업 속성을 render() 함수로 변환한 후 el 속성에 지정한 화면 요소(돔)에 인스턴스를 부착하기 전에 호출되는 단계입니다. render() 함수가 호출되기 직전의 로직을 추가하기 좋습니다. 여기서 render()는 자바스크립트로 화면의 돔을 그리는 함수입니다.</p>
<p><br></br></p>
<h6 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h6><p>el 속성에서 지정한 화면 요소에 인스턴스가 부착되고 나면 호출되는 단계로, template 속성에 정의한 화면 요소(돔)에 접근할 수 있어 화면 요소를 제어하는 로직을 수행하기 좋은 단계입니다. 다만, 돔에 인스턴스가 부착되자마자 바로 호출되기 때문에 하위 컴포넌트나 외부 라이브러리에 의해 추가된 화면 요소들이 최종 HTML 코드로 변환되는 시점과 다를 수 있습니다. 변환되는 시점이 다를 경우 $nextTick() API를 활용하여 HTML 코드로 최종 파싱(변환)될 때까지 기다린 후 돔 제어 로직을 추가합니다.</p>
<p><br></br></p>
<h6 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h6><p>el 속성에서 지정한 화면 요소에 인스턴스가 부착되고 나면 인스턴스에 정의한 속성들이 화면에 치환됩니다. 치환된 값은 뷰의 반응성(Reactivity)을 제공하기 위해 $watch 속성으로 감시합니다. 이를 데이터 관찰이라고 합니다. 여기서 뷰의 반응성이란 뷰의 특징 중 하나로, 코드의 변화에 따라 화면이 반사적으로 반응하여 빠르게 화면을 갱신하는 것을 의미합니다.</p>
<p>또한 beforeUpdate는 관찰하고 있는 데이터가 변경되면 가상 돔으로 화면을 다시 그리기 전에 호출되는 단계이며, 변경 예정인 새 데이터에 접근할 수 있어 변경 예정 데이터의 값과 관련된 로직을 미리 넣을 수 있습니다. 만약 여기에 값을 변경하는 로직을 넣더라도 화면이 다시 그려지지는 않습니다.</p>
<p><br></br></p>
<h6 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h6><p>데이터가 변경되고 나서 가상 돔으로 다시 화면을 그리고 나면 실행되는 단계입니다. 데이터 변경으로 인한 화면 요소 변경까지 완료된 시점이므로, 데이터 변경 후 화면 요소 제어와 관련된 로직을 추가하기 좋은 단계입니다. 이 단계에서 데이터 값을 변경하면 무한 루프에 빠질 수 있기 때문에 값을 변경하려면 computed, watch와 같은 속성을 사용해야 합니다. 따라서 데이터 값을 갱신하는 로직은 가급적이면 beforeUpdate에 추가하고, updated에서는 변경 데이터의 화면 요소(돔)와 관련된 로직을 추가하는 것이 좋습니다. mounted 단계와 마찬가지로 하위 컴포넌트의 화면 요소와 외부 라이브러리에 의해 주입된 요소의 최종 변환 시점이 다를 수 있습니다. $nextTick()을 사용하여 변환이 완료될 때까지 기다렸다가 변환을 시도합니다.</p>
<p><br></br></p>
<h6 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h6><p>뷰 인스턴스가 파괴되기 직전에 호출되는 단계입니다. 이 단계에서는 아직 인스턴스에 접근할 수 있습니다. 따라서 뷰 인스턴스의 데이터를 삭제하기 좋은 단계입니다.</p>
<p><br></br></p>
<h6 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h6><p>뷰 인스턴스가 파괴되고 나서 호출되는 단계입니다. 뷰 인스턴스에 정의한 모든 속성이 제거되고 하위에 선언한 인스턴스들 또한 모두 파괴됩니다. 자, 그럼 지금까지 설명한 라이프 사이클 훅이 실제로 어떻게 동작하는지 확인하기 위해 예제를 통해 실습해 보겠습니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">dir</span>=<span class="string">"ltr"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Sample<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">          message: <span class="string">'Hello Vue.js!'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        beforeCreate: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"beforeCreate"</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        created: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"created"</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        mounted: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"mounted"</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        updated: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"updated"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>위 코드는 뷰 시작하기 샘플 코드에서 라이프 사이클의 4개 속성인 beforeCreate, created, mounted, updated를 추가하고 각각 로그를 출력해 보는 예제입니다. 브라우저에서 코드를 실행하고 개발자 도구 ‘Console’ 패널을 확인하여 로그를 보면 뷰 라이프 사이클 도해의 흐름대로 표시되었지만, 다만 한 가지 의아한 부분이 updated 속성 함수는 호출되지 않았다는 것입니다. 왜 그럴까요? 그 이유는 updated 라이프 사이클 혹은 뷰 인스턴스에서 데이터 변경이 일어나 화면이 다시 그려졌을 때 호출되는 로직이기 때문입니다. 그럼 updated의 앞 단계인 mounted 단계에서 기존에 정의된 data 속성의 message 값을 변경해 보겠습니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">dir</span>=<span class="string">"ltr"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Sample<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">          message: <span class="string">'Hello Vue.js!'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        beforeCreate: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"beforeCreate"</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        created: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"created"</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        mounted: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"mounted"</span>);</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.message = <span class="string">'Hello Vue!'</span>;</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        updated: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"updated"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>mounted 단계에서 데이터를 변경했기 때문에 beforeUpdate, updated 단계에 정의한 로직이 모두 동작합니다. 다만, 여기서는 updated 단계에서만 ‘updated’라는 로그를 출력하는 커스텀 로직을 정의했기 때문에 beforeUpdate 단계에서는 아무런 동작을 하지 않습니다. 추후 뷰의 반응성과 data의 연관성에 대해서는 별도로 설명할 것이므로 여기서는 일단 message 값이 변경됨에 따라 화면의 내용도 자연스럽게 갱신된 것이라고 이해하고 넘어가시길 바랍니다. 위 코드를 실행하면 다음과 같은 로그가 출력됩니다.</p>
<p><br></br></p>
<p><img src="/image/VUE11.png" alt="VUE11"></p>
<p><br></br></p>
<p>아까는 보이지 않던 updated 로그가 출력되었습니다. 그 이유는 message의 값이 변경됨에 따라 화면에 표시되는 message 값이 갱신되었고, 이에 따라 updated 속성에 정의한 로직이 실행되었기 때문입니다. 여기서 중요한 것은 인스턴스의 데이터가 갱신되면서 라이프 사이클 단계가 boforeUpdate, updated 단계로 진입했다는 점입니다. 이처럼 각 인스턴스 라이프 사이클에 맞춰 원하는 로직을 추가하여 원하는 시점에 실행할 수 있습니다.</p>
<p>뷰를 제대로 사용하려면 지금까지 배운 뷰 인스턴스 라이프 사이클을 잘 익혀두어야 합니다. 실습한 내용이 완전히 이해되지 않았다면 앞에서 설명한 뷰 인스턴스 라이프 사이클을 다시 한 번 살펴보고 다음으로 넘어가는 것이 좋습니다.</p>
<p><br></br></p>
<h4 id="2-뷰-컴포넌트"><a href="#2-뷰-컴포넌트" class="headerlink" title="(2) 뷰 컴포넌트"></a>(2) 뷰 컴포넌트</h4><p>컴포넌트(Component)란 조합하여 화면을 구성할 수 있는 블록(화면의 특정 영역)을 의미합니다. 컴포넌트를 활용하면 화면을 빠르게 구조화하여 일괄적인 패턴으로 개발할 수 있습니다. 이렇게 화면의 영역을 컴포넌트로 쪼개서 재활용할 수 있는 형태로 관리하면 나중에 코드를 다시 사용하기가 훨씬 편리합니다. 또한 모든 사람들이 정해진 방식대로 컴포넌트를 등록하거나 사용하게 되므로 남이 작성한 코드를 직관적으로 이해할 수 있습니다.</p>
<p>뷰에서는 웹 화면을 구성할 때 흔히 사용하는 내비게이션 바(navigation bar), 테이블(table), 리스트(list), 인풋 박스(input box) 등과 같은 화면 구성 요소들을 잘게 쪼개어 컴포넌트로 관리합니다. 다음 그림에서 왼쪽은 웹 페이지 한 화면의 영역을 각각 역할별로 분할한 그림이고, 오른쪽은 각각 분할된 영역 간의 관계를 도식화한 그림입니다. 여기서 각각 분할된 영역은 컴포넌트를 의미합니다. </p>
<p><br></br></p>
<p><img src="/image/VUE12.jpeg" alt="VUE12"></p>
<p><br></br></p>
<p>위의 왼쪽 그림은 화면 전체를 Header, Content, Footer로 분할하였고, Content 영역을 Aside, List 영역으로 분할하였습니다. 이는 화면 전체를 3개의 컴포넌트로 분할한 후 분할된 1개의 컴포넌트에서 다시 2개의 하위 컴포넌트로 분할한 것입니다. 그리고 오른쪽 그림은 각 컴포넌트 간의 관계를 나타냅니다. 이러한 컴포넌트 간의 관계는 뷰에서 화면을 구성하는 데 매우 중요한 역할을 하며, 웹 페이지 화면을 설계할 때도 이와 같은 골격을 유지하면서 설계를 해야 합니다. 참고로 컴포넌트 간의 관계는 자료구조의 트리(Tree) 모양과 유사합니다. 트리란 컴퓨터 자료구조 중 하나로, 노드끼리의 연결이 부모 - 자식의 구조를 따릅니다. 트리는 윈도우 파일 시스템 체계를 비롯하여 각종 데이터베이스에 활용되고 있고 뷰에서도 컴포넌트를 이해할 때 필요한 개념입니다.</p>
<p><br></br></p>
<h6 id="컴포넌트-등록하기"><a href="#컴포넌트-등록하기" class="headerlink" title="컴포넌트 등록하기"></a>컴포넌트 등록하기</h6><p>컴포넌트를 등록하는 방법은 전역과 지역의 두 가지가 있습니다. 지역(Local) 컴포넌트는 특정 인스턴스에만 유효한 범위를 갖고, 전역(Global) 컴포넌트는 여러 인스턴스에서 공통으로 사용할 수 있습니다. 더 쉽게 말하자면 지역은 특정 범위 내에서만 사용할 수 있고, 전역은 뷰로 접근 가능한 모든 범위에서 사용할 수 있다는 거죠. 그럼 두 가지 방법에 대해 알아봅시다.</p>
<p><br></br></p>
<h6 id="전역-컴포넌트-등록"><a href="#전역-컴포넌트-등록" class="headerlink" title="[전역 컴포넌트 등록]"></a>[전역 컴포넌트 등록]</h6><p>전역 컴포넌트는 뷰 라이브러리를 로딩하고 나면 접근 가능한 Vue 변수를 이용하여 등록합니다. 전역 컴포넌트를 모든 인스턴스에 등록하려면 Vue 생성자에서 .component()를 호출하여 수행하면 됩니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component('컴포넌트 이름', &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>전역 컴포넌트 등록 형식에는 컴포넌트 이름과 컴포넌트 내요잉 있습니다. 컴포넌트 이름은 template 속성에서 사용할 HTML 사용자 정의 태그(custom tag) 이름을 의미합니다. 사용자 정의 태그란 HTML 표준 태그들 이외에도 웹 개발자가 직접 정의하여 사용할 수 있는 태그이다. 태그 이름의 명명 규칙은 HTML 사용자 정의 태그 스펙에서 강제하는 ‘모두 소문자’와 ‘케밥 기법’을 따르지 않아도 됩니다. 여기서 케밥 기법은 변수가 단어의 조합으로 이루어져 있을 때, 단어와 단어 사이를 -로 잇는 변수 명명 방식을 말합니다.</p>
<p>그리고 컴포넌트 태그가 실제 화면의 HTML 요소로 변환될 때 표시될 속성들을 컴포넌트 내용에 작성합니다. 컴포넌트 내용에는 template, data, methods 등 인스턴스 옵션 속성을 정의할 수 있습니다. 그럼 Vue.component()로 전역 컴포넌트를 1개 등록하고 화면에 그리는 예제를 살펴보겠습니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Component Registration<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>컴포넌트 등록<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      Vue.component(<span class="string">'my-component'</span>, &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>전역 컴포넌트가 등록되었습니다!<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span></span></span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>위 예제를 실행하면 아래와 같은 결과 화면이 나타납니다.</p>
<p><br></br></p>
<p><img src="/image/VUE13.png" alt="VUE13"></p>
<p><br></br></p>
<p>이 코드가 실행되어 화면에 나타나기까지의 과정을 살펴보면 다음과 같습니다. 앞에서 살펴본 인스턴스가 화면에 적용되는 과정에 컴포넌트 등록 부분과 변환 부분을 추가하였습니다. [뷰 라이브러리 파일 로딩] $\rightarrow$ [뷰 생성자로 컴포넌트 등록; Vue.compoment()] $\rightarrow$ [인스턴스 객체 생성] $\rightarrow$ [인스턴스 객체 생성 (옵션 속성 포함)] $\rightarrow$ [특정 화면 요소에 인스턴스 부착] $\rightarrow$ [인스턴스 내용 변환 (등록된 컴포넌트 내용도 변환: my-component가 <div>로 변환됨] $\rightarrow$ [변환된 화면 요소를 사용자가 최종 확인]</p>
<p>이처럼 전역 컴포넌트가 화면에 나타나기까지의 처리 과정을 확인하였는데, 여기서 인스턴스가 생성되고, 인스턴스의 내용이 화면 요소로 변환될 때 컴포넌트 태그도 함께 변환됩니다. 따라서 컴포넌트 태그에 정의한 컴포넌트 내용은 사용자가 볼 수 있는 형태의 화면 요소로 최종 변환되겠죠.</p>
<p>전역 컴포넌트를 등록하려면 HTML에서 사용할 태그 이름을 컴포넌트 이름으로 작성하고, 중괄호 {} 안에는 HTML 태그가 실제로 화면에서 그려질 때 표시될 내용(컴포넌트 내용)을 작성해야 합니다. 이 예제에서는 컴포넌트의 이름을 my-component로 지정했고, 컴포넌트 내용으로는 template 속성을 정의하고 ‘전역 컴포넌트가 등록되었습니다!’라는 div 태그를 작성했습니다. 따라서 이 컴포넌트를 HTML에 추가하면 최종적으로 컴포넌트가 등록됩니다. 그리고 등록된 my-component 컴포넌트는 실제로 화면에 전역 컴포넌트가 등록되었습니다!로 그려집니다.</p>
<p><br></br></p>
<h6 id="지역-컴포넌트-등록"><a href="#지역-컴포넌트-등록" class="headerlink" title="지역 컴포넌트 등록"></a>지역 컴포넌트 등록</h6><p>지역 컴포넌트 등록은 전역 컴포넌트 등록과는 다르게 인스턴스에 components 속성을 추가하고 등록할 컴포넌트 이름과 내용을 정의하면 됩니다. 지역 컴포넌트 등록 형식은 아래와 같습니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        '컴포넌트 이름': 컴포넌트 내용</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>컴포넌트 이름은 전역 컴포넌트와 마찬가지로 HTML에 등록할 사용자 정의 태그를 의미하고, 컴포넌트 내용은 컴포넌트 태그가 실제 화면 요소로 변환될 때의 내용을 의미합니다. 그럼, 지역 컴포넌트를 등록하는 방법을 다음 예제를 통해 살펴보겠습니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Component Registration<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>컴포넌트 등록<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-local-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-local-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> cmp = &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 컴포넌트 내용</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>지역 컴포넌트가 등록되었습니다.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        components: &#123;</span><br><span class="line"><span class="actionscript">          <span class="string">'my-local-component'</span>: cmp</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>변수 cmp에는 화면에 나타낼 컴포넌트의 내용을 정의했습니다. 컴포넌트의 내용에 template, data, methods 등 여러 가지 속성이 들어갈 수 있지만 여기서는 간단히 컴포넌트를 등록하는 코드만 보여주기 위해 template 속성만 사용하였습니다. 그리고 template 속성에 <div> 태그 1개만 설정합니다. 아래 뷰 인스턴스에 components 속성을 추가하고 컴포넌트 이름에는 my-local-component를, 컴포넌트 내용에는 앞에서 컴포넌트 내용을 정의한 변수 cmp를 지정합니다. 그리고 HTML에 my-local-component 태그를 추가하여 컴포넌트를 화면에 나타냅니다.</p>
<p>지금까지 지역 컴포넌트 등록과 전역 컴포넌트 등록에 대해 알아보았습니다. 그런데 아직 웹 페이지 상으로 드러나는 결과만으로는 전역 컴포넌트와 지역 컴포넌트의 차이점을 찾기가 어렵습니다. 앞에서 배운 인스턴스 유효 범위를 이용해서 전역 컴포넌트, 지역 컴포넌트 간에는 어떤 차이점이 있는지 살펴보겠습니다. </p>
<p><br></br></p>
<h6 id="지역-컴포넌트와-전역-컴포넌트의-차이"><a href="#지역-컴포넌트와-전역-컴포넌트의-차이" class="headerlink" title="지역 컴포넌트와 전역 컴포넌트의 차이"></a>지역 컴포넌트와 전역 컴포넌트의 차이</h6><p>지역 컴포넌트와 전역 컴포넌트의 차이점을 이해하기 위해서는 앞에서 배운 인스턴스의 유효 범위를 이해해야 합니다. 인스턴스의 유효 범위란 HTML의 특정 범위 안에서만 인스턴스의 내용이 유효한 것이라고 했는데, 그럼 다음 코드를 살펴볼까요?</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Component Registration<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line">      &lt;&lt;h3&gt;첫 번째 인스턴스 영역&lt;/h3&gt;</span><br><span class="line">      <span class="tag">&lt;<span class="name">my-global-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-global-component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-local-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-local-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 전역 컴포넌트 등록</span></span></span><br><span class="line"><span class="actionscript">      Vue.component(<span class="string">'my-global-component'</span>, &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>전역 컴포넌트입니다.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> cmp = &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 컴포넌트 내용</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>지역 컴포넌트입니다.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 지역 컴포넌트 등록</span></span></span><br><span class="line">        components: &#123;</span><br><span class="line"><span class="actionscript">          <span class="string">'my-local-component'</span>: cmp</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>위 코드는 인스턴스를 하나 생성하여 my-global-component 전역 컴포넌트와 my-local-component 지역 컴포넌트를 등록하고 화면에 나타내는 예제입니다. 여기까지는 앞에서 배운 내용으로 충분히 이해할 수 있을 겁니다. 그럼 이번에는 인스턴스를 하나 더 생성하고 해당 인스턴스에서 지역, 전역 컴포넌트를 모두 표시해 보겠습니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Component Registration<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>첫 번째 인스턴스 영역<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-global-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-global-component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-local-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-local-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"app2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>두 번째 인스턴스 영역<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-global-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-global-component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-local-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-local-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 전역 컴포넌트 등록</span></span></span><br><span class="line"><span class="actionscript">      Vue.component(<span class="string">'my-global-component'</span>, &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>전역 컴포넌트입니다.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="actionscript">      <span class="comment">// 지역 컴포넌트 내용</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> cmp = &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 컴포넌트 내용</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>지역 컴포넌트입니다.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 지역 컴포넌트 등록</span></span></span><br><span class="line">        components: &#123;</span><br><span class="line"><span class="actionscript">          <span class="string">'my-local-component'</span>: cmp</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"><span class="actionscript">      <span class="comment">// 두 번째 인스턴스</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app2'</span></span></span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>HTML에 div id=”app2” 태그를 하나 더 추가하고, 인스턴스도 하나 더 추가하였습니다. 그리고 div id = “app2” 태그에 전역, 지역 컴포넌트를 모두 등록하였습니다. 첫 번째 인스턴스 영역과 두 번째 인스턴스 영역을 구분하기 위해 구분선으로는 hr 태그를 사용하였습니다.</p>
<p><br></br></p>
<p><img src="/image/VUE14.png" alt="VUE14"></p>
<p><br></br></p>
<p>첫 번째 인스턴스 영역에는 전역, 지역 컴포넌트가 모두 정상적으로 나타났습니다. 하지만 구분선 밑에 두 번째 인스턴스 영역에는 전역 컴포넌트만 나타나고, 지역 컴포넌트는 나타나지 않았습니다. 왜 그럴까요? 전역 컴포넌트와 지역 컴포넌트의 유효 범위가 다르기 때문입니다. 전역 컴포넌트는 인스턴스를 새로 생성할 때마다 인스턴스에 components 속성으로 등록할 필요없이 한 번 등록하면 어느 인스턴스에서든지 사용할 수 있습니다. 반대로 지역 컴포넌트는 새 인스턴스를 생성할 때마다 등록해 줘야 합니다. 그리고 앞서 설명한 인스턴스의 범위도 여기에 적용됩니다. 첫 번째 인스턴스의 유효 범위는 첫 번째 인스턴스 영역으로 제한되기 때문에 div id=”app”에 지역 컴포넌트를 등록했어도 두 번째 인스턴스 영역인 div id=”app2”의 범위 안에서는 지역 컴포넌트가 인식되지 않아 my-local-component는 HTML 사용자 정의 태그로 인식합니다. my-local-component 태그는 두 번째 인스턴스의 유효 범위 안에 있더라도 이 컴포넌트가 등록된 첫 번째 유효범위를 벗어나기 때문에 브라우저에서는 HTML 사용자 정의 태그로 인식하고, 뷰에서는 해당 컴포넌트를 제대로 등록했는지 물어보는 오류를 표시합니다.</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/06/SEM-%EA%B5%AC%EC%A1%B0%EB%B0%A9%EC%A0%95%EC%8B%9D-%EB%AA%A8%ED%98%95%EC%9D%98-%EC%86%8C%EA%B0%9C/">
                [SEM] 구조방정식 모형의 소개
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-06</span>
            
            
            
                <span class="category">
                    <a href="/categories/structural-equation-modeling/">structural equation modeling</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="구조방정식-모형의-소개"><a href="#구조방정식-모형의-소개" class="headerlink" title="구조방정식 모형의 소개"></a>구조방정식 모형의 소개</h1><h6 id="본-포스팅은-lt-구조방정식-모형의-기본과-확장-gt-을-바탕으로-진행합니다"><a href="#본-포스팅은-lt-구조방정식-모형의-기본과-확장-gt-을-바탕으로-진행합니다" class="headerlink" title="본 포스팅은 &lt;구조방정식 모형의 기본과 확장&gt;을 바탕으로 진행합니다."></a>본 포스팅은 &lt;구조방정식 모형의 기본과 확장&gt;을 바탕으로 진행합니다.</h6><p><br></br></p>
<h3 id="구조방정식이란"><a href="#구조방정식이란" class="headerlink" title="구조방정식이란?"></a>구조방정식이란?</h3><p>구조방정식 모형(structural equation modeling 또는 structural equation model, SEM)이란 무엇인가?<br>하나의 문장으로 정의하고자 한 연구자들도 있어 왔지만, 한 문장으로 이루어진 정의가 SEM을 이해하고 이용하는 데 있어서 큰 도움을 줄 것 같지는 않다. 기본적으로 학계에서 SEM이라고 하면 이는 크게 두 가지 의미(좁은 의미와 넓은 의미)로 받아들여질 수 있다. 먼저 좁은 의미로는 잠재변수들(latent variables) 간의 구조적인 관계(회귀 관계)를 확인하는 하나의 통계모형이다. 예를 들어 성격, 인지능력, 직업흥미라는 추상적인 개념을 구체적인 수치를 가진 관찰변수(수집된 자료)를 이용하여 만들어 내고, 이렇게 만들어진 추상적인 변수(잠재변수)들 간에 서로 주고받는 영향을 구조방정식 모형을 통하여 추정하고 검정하게 된다. 이처럼 심리학 또는 교육학에서는 우울, 불안, 효능감, 능력 등의 수많은 개인수준의 잠재변수들이 만들어지고, 이 잠재변수들 간의 영향관계가 연구되는 것이 일반적이다.</p>
<p>반면 SEM을 넓은 의미로 보면, 이는 구조방정식의 수식이나 경로도 표현 방식으로 나타내어질 수 있는 모든 통계모형을 일컫거나 또는 그와 같은 표현 방식 자체, 즉 틀(framework)을 나타낸다. 예를 들어, 우리가 잘 알고 있는 회귀분석모형, 분산분석모형, 요인분석모형 등도 모두 SEM의 틀 안에서 추정 가능하며, 더욱 발전적인 기법들인 문항반응이론모형, 잠재계층분석, 다층모형 등도 크게 SEM의 틀 안에 있다고 볼 수 있다. 즉, SEM은 이미 존재하는 많은 통계 방법들과 현재 발전하고 있는 여러 고급기법들을 하나의 형식으로 일반화할수 있는 매우 강력한 틀이라고 할 수 있다. 이런 경우, 특히 잠재변수가 사용되는 모형들의 경우, SEM이라는 표현 대신 잠재변수모형이라는 단어를 사용하기도 한다.</p>
<p>정리하자면, SEM은 작은 의미로는 잠재변수 간의 구조관계를 연구하는 하나의 통계모형이며, 이때는 structural equation model이라는 표현과 상통한다. 또한 크게는 관찰변수나 잠재변수를 사용하고, 구조방정식 표현 방법으로 나타내어질 수 있는 모든 모형을 가리킨다고 볼 수 있는데, 이때는 structural equation modeling framework라는 표현과 맞닿아 있다.</p>
<p><br></br></p>
<h3 id="구조방정식-모형의-한계"><a href="#구조방정식-모형의-한계" class="headerlink" title="구조방정식 모형의 한계"></a>구조방정식 모형의 한계</h3><p>구조방정식을 소개하는 장에서 미리 구조방정식 모형의 한계를 논한다는 것이 성급한 면도 있지만, 여기서 밝힐 부분은 매우 중요하며 구조방정식을 공부하는 내내 마음속에 담아 두어야 할 내용이다. 여러 학문 분야의 많은 연구자들이 자신의 연구가설에 맞는 무형의 경로도를 설정하고, 즉 어떤 변수에서 다른 변수로 가는 화살표를 설정하고, 프로그램을 이용해 그 모형을 추정한 다음, 만약 여러 다양한 모형의 적합도(모형이 자료에 부합하는 정도) 지수가 두루 만족되었다면 마치 자신의 모형이 진정한 모형(true model)인 것처럼 과장해서 해석하는 경향이 있다. 즉, 모형의 적합도가 좋다면 연구자가 설정한 변수 간 화살표의 방향이 마치 본인이 추정한 모형에 의해서 증명되었다는 생각을 하는 경우가 많다. 결론적으로 말해서 이런 생각은 옳지 않으며, 앞으로 구조방정식을 사용함에 있어서 가장 주의해야 할 부분이라고 할 수 있다.</p>
<p>예를 들어, 한 연구팀이 우울, 면역기능, 질병 등 세 가지 변수 사이의 관계를 연구하려고 500명의 사람들로부터 여러 설문을 이용하여 세 변수에 대한 자료를 수집하였다고 가정하자. 한 연구원은 경로도와 같은 가설을 세워, 자신의 모형이 수집한 자료에 적합한지(적합도, goodness-of-fit)를 확인하고자 하였다. 연구자의 가설을 설명하자면, 우울이 면역기능에 좋지 않은 영향을 주고 차례대로 떨어진 면역기능이 질병을 일으킨다는 것이다.</p>
<p>또 한 명의 연구원은 면역기능이 떨어지면 질병이 발생하고, 질병이 생기면 우울이 심해진다는 가설을 세워 자신의 모형이 자료에 적합한지를 확인하고자 하였다. 자세한 구조방정식의 절차는 아직 배우지 않았으므로 생략하고, 결론적으로 위의 두 모형의 추정 결과를 확인하니 모형 1은 통계적인 적합도 검정을 통과하였고, 모형 2는 적합도 검정을 통과하지 못했다고 가정하자. 그렇다면 우리는 모형 1이 변수 간의 진정한 관계를 보여 주는 모형이라고 결론을 내릴 수 있을까? 다시 말해, 우울이 면역기능에 영향을 주고, 이어서 약해진 면역기능이 질병을 일으킨다고 결론 낼 수 있을까? 안타깝게도 통계모형으로서의 SEM은 이런 종류의 질문에 전혀 답을 할 수 없다. 여러 가지 이유를 말할 수 있겠지만, 다음의 예가 이러한 문제에 대한 이해를 돕는 데 도움을 줄 수 있을 것이다. 첫 번째와 두 번째 연구원 이외에 연구팀에 있는 또 다른 연구원은 모형 1과 2 모두 자신이 생각하기에는 옳지 않다고 판단하였고, 질병이 면역기능에 영향을 주고, 이어서 우울이 심해진다는 가설을 세웠다.</p>
<p>만약 세 번째 모형을 구조방정식 프로그램을 이용해 추정하면 반드시 통계적 적합도 검정을 통과하게 된다. 그 이유는 모형 3과 모형 1이 통계적 동치 관계이 있기 때문이다. 모형 3은 사실 모형 1에서 화살표의 방향을 모두 반대로 바꿔 놓은 모형이다. 이와 같이 모형 1과 모형 3은 변수 간의 인과관계는 전혀 다르게 설정되어 있을지라도 통계적 적합도 지수는 서로 일치하는 모형이다. 다시 말해, 모형 1이 적합도 검정을 통과하였으므로 모형 1과 통계적으로 동치인 모형 3 역시 적합도 검정을 통과하게 되는 것이다. 그렇다면 서로 완전히 똑같은 정도로 자료에 적합한 두 개의 모형 중 진정한 모형은 무엇인가? 이는 우리가 통계적으로 대답할 수 있는 질문이 아니다.</p>
<p>Bollen(1989)은 그의 책에서 SEM의 인과관계(causality)에 대하여 설명하고 경고한다. 우리는 다음의 질문으로 시작하여 좀 더 개념적으로 쉽게 접근하고자 한다. 통계적으로 SEM은 어디로부터 출발한 것인가?</p>
<p>무엇이 ‘시작’인가라는 통계 철학적인 질문으로 해석하면 답변이 곤란해질 수도 있다. 그저 이 질문에 기술적으로 대답을 해야 한다면, SEM은 상관(관계)으로부터 시작한 것이라고 볼 수 있다. 상관이란 변수 간의 관계를 말하는 것이고, 이는 일반적으로 공분산이나 상관계수를 이용해 측정한다. 공분산 또는 상관계수는 선형적인 관계를 보여주는 통계치이며, 해석상 몇 가지 제한이 있다. 그중 가장 중요한 것이 두 변수 사이에 서로 상관은 존재하지만 어느 변수가 어느 변수에 영향을 주는지에 대한 인과적인 설명은 전혀 다른 이야기라는 것이다. 상관은 인과관계를 위한 한 가지 필요조건일 뿐, 인과관계를 담보하는 충분조건은 아니다. </p>
<p>그렇다면 상관에 기반하여 더 발전한 모형인 회귀분석 모형에서는 인과관계를 논할 수 있을까? 회귀분석에서 우리는 종종 독립변수가 종속변수에 영향을 준다고 해석하는데, 이러한 해석은 사실 상당히 유의해야할 부분이다. 회귀분석 모형 자체는 영향, 즉 인과관계에 대하여 그 어떤 증거도 줄 수 없는 단지 상관에 기반한 통계모형일 뿐이다. 인과관계는 자료의 속성(예, 부모의 키로 자식의 키를 예측하는 자료) 또는 자료의 수집방법(예, 혼입변수가 통제된 실험에서 획득한 자료)에 기반하여 확보되는 것이지, 통계모형(예, 회귀분석)을 통해서 확보되는 것은 아니다. 회귀분석에서 독립변수와 종속변수의 관계는 인과율하에서 영향을 주는 변수와 영향을 받는 변수일 수도 있지만, 예측하는 변수와 예측받는 변수라고 보는 것이 더 일반적이다. 이처럼 상관에서 발전한 회귀분석 모형은 상관이 가지고 있는 한계, 즉 인과관계를 담보하지 못한다는 그 문제를 그대로 가지고 있다.</p>
<p>앞에서 보았던 세 개의 경로모형, 즉 구조방정식 모형은 회귀분석에서 더 발전된 형태라고 앞에서 서술하였다. 결국은 많은 사람들이 상관분석에서 회귀분석, 그리고 회귀분석에서 구조방정식 모형으로 발전을 해 온 것으로 생각한다. 이와 같은 발전관계를 통해서 구조방정식 모형은 상관계수와 마찬가지로 두 변수 사이의 인과관계를 담보하지 않는다는 사실을 쉽게 예상할 수 있다. 한 가지 오해를 방지하기 위해 덧붙이자면, 몇몇 분야에서 구조방정식 모형을 인과모형(causal modeling)이라고 부르는 경우가 종종 있는데 이는 과거 구조방정식을 일컫던 이름이기도 하다. 이는 Galton(1886)의 회귀모형이 부모의 키로부터 자식의 키를 예측하는 분석이었기 때문에 자연스럽게 회귀분석에서 인과관계가 담보되었던 것과 같은 이치다. 일반적으로는 수집된 자료에 적용된 어떤 통계모형이 그 아무리 모형의 적합도가 좋다고 해도 인과관계를 무조건 담보한다는 것은 성립하지 않는다. </p>
<p>그렇다면 구조방정식 모형을 이용함에 있어 모형의 적합도가 좋다 또는 나쁘다고 하는 것의 의미는 무엇인가? 모형의 적합도가 좋다는 것은 연구자가 설정한 모형이 자료에 잘 부합한다는 것이며, 이는 연구자의 모형이 진정한 모형일 가능성이 있다는 정도로 해석될 수 있다. Kline(2011)은 모형의 적합도가 좋을 때 그 모형이 그럴듯하다(plausible) 정도로만 해석할 수 있다고 표현하였다. 반대로 모형의 적합도가 나쁘다면, 그때는 연구자의 모형이 자료에 잘 부합하지 않는다고 결정할 수 있다. 그리고 모형이 자료에 부합하지 않으므로 그 모형이 진정한 모형일 가능성도 배제하게 되는 것이다.</p>
<p>구조방정식 모형의 적합도가 좋다고 하여도 인과관계를 담보할 수 없다는 지금까지의 설명에서 다시 말하지만, 연구자가 변수 사이에 화살표를 설정하고 전체 모형을 추정하여 모형의 적합도가 좋다고 하여도 그것이 인과관계를 담보하지는 않는다. 그렇다면 구조방정식 모형에서 인과관계가 존재하지 않는 변수들 사이에 화살표를 설정하는 것이 문제가 없는 것인가? 어차피 인과관계를 증명할 수 없으므로, 인과관계를 가지지 않는 변수들 사이에 화살표를 결정할 수 있는가라는 질문이다. 결론부터 말하자면 그렇지 않다. 모형의 설정 단계에서, 즉 변수들 사이에 화살표를 설정하는 단계에서 연구자는 변수 간 인과관계를 최대한 나타내는 모형을 설정해야 한다. </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/01/hello-world/">
                Welcome to QuantPsy World!
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-01</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h4 id="Welcome-to-my-git-blog"><a href="#Welcome-to-my-git-blog" class="headerlink" title="Welcome to my git blog!"></a><strong>Welcome to <a href="https://github.com/SungiCho" target="_blank" rel="noopener">my git blog</a>!</strong></h4><p><br></br></p>
<h6 id="I’m-a-person-who-is-really-interested-in-quantifying-the-qualitative-world"><a href="#I’m-a-person-who-is-really-interested-in-quantifying-the-qualitative-world" class="headerlink" title="I’m a person who is really interested in quantifying the qualitative world."></a><strong>I’m a person who is really interested in quantifying the qualitative world.</strong></h6><h6 id="If-you-want-to-contact-me-please-email-me-whtjdwl34-naver-com"><a href="#If-you-want-to-contact-me-please-email-me-whtjdwl34-naver-com" class="headerlink" title="If you want to contact me, please email me: whtjdwl34@naver.com"></a><strong>If you want to contact me, please email me: whtjdwl34@naver.com</strong></h6><p><br></br></p>
<h6 id="tag-Psychology-Statistics-Computer-Science"><a href="#tag-Psychology-Statistics-Computer-Science" class="headerlink" title="tag: Psychology, Statistics, Computer Science"></a><strong>tag: <u>Psychology</u>, <u>Statistics</u>, <u>Computer Science</u></strong></h6>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/11/29/Python-%ED%8F%AC%EC%BC%93%EB%AA%AC-%ED%81%B4%EB%9E%98%EC%8A%A4/">
                [Python] 포켓몬 클래스
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-11-29</span>
            
            
            
                <span class="category">
                    <a href="/categories/python/">python</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pokemon</span>:</span></span><br><span class="line">    POKEMON_LIST = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, type)</span>:</span></span><br><span class="line">        self.friends = []</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line">        self.__level = <span class="number">1</span>   <span class="comment"># 변수에 언더바 두 개를 붙여 외부로의 접근을 막음</span></span><br><span class="line">        Pokemon.POKEMON_LIST.append(self)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">level</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'inside the getter'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.__level</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @level.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">level</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        print(<span class="string">'inside the setter'</span>)</span><br><span class="line">        self.__level += n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">level_up</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.level = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_friend</span><span class="params">(self, pokemon)</span>:</span></span><br><span class="line">        self.friends.append(pokemon)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_friends</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = len(self.friends)</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>):</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                temp.append(self.friends[i].name)</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>의 친구들:'</span>, <span class="string">', '</span>.join(temp), <span class="string">f'(<span class="subst">&#123;n&#125;</span>마리)'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>에게는 친구가 없습니다....'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_total_pokemon</span><span class="params">(cls)</span>:</span></span><br><span class="line">        m = len(cls.POKEMON_LIST)</span><br><span class="line">        line = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            line.append(cls.POKEMON_LIST[i].name)</span><br><span class="line">        print(<span class="string">'전체 포켓몬:'</span>, <span class="string">', '</span>.join(line), <span class="string">f'(<span class="subst">&#123;m&#125;</span>마리)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    pikachu = Pokemon(name = <span class="string">'피카츄'</span>, type = <span class="string">'전기'</span>)</span><br><span class="line">    print(pikachu.level)</span><br><span class="line">    pikachu.level_up()</span><br><span class="line">    print(pikachu.level)</span><br><span class="line">    butterfree = Pokemon(name=<span class="string">'버터플'</span>, type=<span class="string">'벌레'</span>)</span><br><span class="line">    starmie = Pokemon(name=<span class="string">'아쿠스타'</span>, type=<span class="string">'물'</span>)</span><br><span class="line">    eevee = Pokemon(name=<span class="string">'이브이'</span>, type=<span class="string">'노멀'</span>)</span><br><span class="line">    pikachu.show_friends()</span><br><span class="line">    pikachu.add_friend(butterfree)</span><br><span class="line">    pikachu.add_friend(starmie)</span><br><span class="line">    pikachu.show_friends()</span><br><span class="line">    butterfree.show_friends()</span><br><span class="line">    Pokemon.show_total_pokemon()</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line">inside the getter</span><br><span class="line"><span class="number">1</span></span><br><span class="line">inside the setter</span><br><span class="line">inside the getter</span><br><span class="line"><span class="number">2</span></span><br><span class="line">피카츄에게는 친구가 없습니다....</span><br><span class="line">피카츄의 친구들: 버터플, 아쿠스타 (<span class="number">2</span>마리)</span><br><span class="line">버터플에게는 친구가 없습니다....</span><br><span class="line">전체 포켓몬: 피카츄, 버터플, 아쿠스타, 이브이 (<span class="number">4</span>마리)</span><br></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/11/27/Python-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A9%94%EC%86%8C%EB%93%9C%EC%99%80-static-%EB%A9%94%EC%86%8C%EB%93%9C/">
                [Python] 클래스 메소드와 static 메소드
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-11-27</span>
            
            
            
                <span class="category">
                    <a href="/categories/python/">python</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="클래스-메소드와-static-메소드란-무엇일까"><a href="#클래스-메소드와-static-메소드란-무엇일까" class="headerlink" title="클래스 메소드와 static 메소드란 무엇일까?"></a>클래스 메소드와 static 메소드란 무엇일까?</h1><h6 id="본-포스팅은-lt-윤성우의-열혈-파이썬-중급편-gt-과-lt-처음-시작하는-파이썬-gt-을-바탕으로-진행합니다"><a href="#본-포스팅은-lt-윤성우의-열혈-파이썬-중급편-gt-과-lt-처음-시작하는-파이썬-gt-을-바탕으로-진행합니다" class="headerlink" title="본 포스팅은 &lt;윤성우의 열혈 파이썬 중급편&gt;과 &lt;처음 시작하는 파이썬&gt;을 바탕으로 진행합니다."></a>본 포스팅은 &lt;윤성우의 열혈 파이썬 중급편&gt;과 &lt;처음 시작하는 파이썬&gt;을 바탕으로 진행합니다.</h6><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul>
<li>Story 33. 클래스 메소드와 static 메소드<ul>
<li>[클래스 변수에 대한 이해]</li>
<li>[static 메소드]</li>
<li>[class 메소드]</li>
<li>[static 메소드보다 class 메소드가 더 어울리는 경우]</li>
<li>[static 메소드보다 class 메소드가 완전 더 어울리는 경우]</li>
</ul>
</li>
</ul>
<p><br></br></p>
<h4 id="클래스-변수에-대한-이해"><a href="#클래스-변수에-대한-이해" class="headerlink" title="[클래스 변수에 대한 이해]"></a>[클래스 변수에 대한 이해]</h4><p>다음과 같이 첫 대입 연산에서 생성되는 변수를 가리켜 ‘인스턴스 변수’라 한다.<br>그리고 이는 각 객체별로 존재한다. 그러니까 ‘이는 객체에 속한 변수’이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.iv = <span class="number">10</span>   <span class="comment"># iv는 인스턴스 변수, 객체별로 존재하는 변수</span></span><br><span class="line"></span><br><span class="line">s = Simple()</span><br><span class="line">print(s.iv)    <span class="comment"># 10; 인스턴스 변수는 객체를 통해서 접근을 한다.</span></span><br></pre></td></tr></table></figure>
<p>그런데 다음과 같이 변수를 클래스 안에 둘 수도 있다.<br>그리고 이렇게 되면 이 변수는 클래스에 속하는 ‘클래스 변수’가 된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span>:</span></span><br><span class="line">    cv = <span class="number">20</span>    <span class="comment"># cv는 클래스 변수, 클래스 Simple에 속하는 변수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.iv = <span class="number">10</span>   <span class="comment"># iv는 인스턴스 변수, 객체별로 존재하는 변수</span></span><br><span class="line"></span><br><span class="line">print(Simple.cv)  <span class="comment"># 클래스 변수는 클래스 이름으로 접근 가능</span></span><br><span class="line">s = Simple()</span><br><span class="line">print(s.cv)       <span class="comment"># 클래스 변수는 객체를 통해서도 접근 가능</span></span><br><span class="line">print(s.iv)       <span class="comment"># 인스턴스 변수는 객체를 통해서 접근을 한다.</span></span><br></pre></td></tr></table></figure>
<p>위의 예제에서는 클래스 변수 cv가 선언되었다.<br>그러면 cv는 Simple 클래스에 속하는 변수가 된다. 즉 이는 Simple 객체에 존재하는 변수가 아니다.<br>때문에 이 변수는 다음과 같이 클래서 이름을 통해서 접근해야 한다.</p>
<p>그런데 위 예제에서도 보이듯이 클래스 변수는 객체를 통해서도 접근할 수 있다.<br>마치 인스턴스 변수에 접근하듯이 말이다. (접근하는 변수가 객체에 없으면 그 객체의 클래스에 찾아가서 그 변수를 찾기 때문이다.)</p>
<p>클래스 변수를 위와 같이 접근하면 이를 보고선 cv가 클래스 변수인지 인스턴스 변수인지 구분이 안된다는 단점이 있다. 그래서 가급적 클래스 변수는 클래스 이름을 통한 접근을 권한다. 그리고 클래스 변수는 객체 내에서도 접근할 수 있는데 그 방법은 다음 예제를 통해서 소개하겠다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span>:</span></span><br><span class="line">    count = <span class="number">0</span>   <span class="comment"># Simple의 클래스 변수, 생성된 객체 수를 저장하는 것이 목적</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Simple.count += <span class="number">1</span>   <span class="comment"># 클래스 변수 count 값 1 증가</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_count</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Simple.count <span class="comment"># 클래스 변수 count 값 반환</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    s1 = Simple()   <span class="comment"># 클래스 변수 count의 값은 1이 된다.</span></span><br><span class="line">    print(s1.get_count())   <span class="comment"># s1의 메소드 호출</span></span><br><span class="line">    s2 = Simple()   <span class="comment"># 클래스 변수 count의 값은 2가 된다.</span></span><br><span class="line">    print(s1.get_count())   <span class="comment"># 이번에도 s1의 메소드 호출</span></span><br><span class="line">    s3 = Simple()   <span class="comment"># 클래스 변수 count의 값은 3이 된다.</span></span><br><span class="line">    print(s1.get_count())   <span class="comment"># 마지막에도 s1의 메소드 호출</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>위 예제에서는 클래스 변수의 특성 대부분을 보여주고 있다. 이 예제를 통해 확인할 사항들은 다음과 같다.</p>
<p><br></br></p>
<h5 id="“클래스-내에서-클래스-변수에-접근하는-방법”"><a href="#“클래스-내에서-클래스-변수에-접근하는-방법”" class="headerlink" title="“클래스 내에서 클래스 변수에 접근하는 방법”"></a>“클래스 내에서 클래스 변수에 접근하는 방법”</h5><h5 id="“하나의-클래스-변수를-서로-다른-세-개의-객체를-통해서-접근하고-있는-상황”"><a href="#“하나의-클래스-변수를-서로-다른-세-개의-객체를-통해서-접근하고-있는-상황”" class="headerlink" title="“하나의 클래스 변수를 서로 다른 세 개의 객체를 통해서 접근하고 있는 상황”"></a>“하나의 클래스 변수를 서로 다른 세 개의 객체를 통해서 접근하고 있는 상황”</h5><p><br></br></p>
<p>그리고 위 예제에서는 s1을 대상으로만 get_count 메소드를 호출하고 있다. 어차피 이 메소드는 클래스 변수의 값을 반환하는 메소드이므로 어떤 객체를 대상으로 호출하건 그 결과는 같다. </p>
<p><br></br></p>
<h4 id="static-메소드"><a href="#static-메소드" class="headerlink" title="[static 메소드]"></a>[static 메소드]</h4><p>앞서 정의한 클래스를 대상으로, 생성된 객체의 수를 확인하기 위해서 get_count 메소드를 호출하고 싶다고 가정해보자. 여기서 안타까운 사실 하나는 get_count 메소드는 객체가 있어야 호출 가능하다는 점이다. 즉 현재 이 메소드를 호출하기 위해서는 다음 두 가지 중 한가지 방법을 선택해야 한다.</p>
<p><br></br></p>
<h5 id="“Simple-객체를-하나-생성하던가”"><a href="#“Simple-객체를-하나-생성하던가”" class="headerlink" title="“Simple 객체를 하나 생성하던가”"></a>“Simple 객체를 하나 생성하던가”</h5><h5 id="“아니면-어딘가에-있을-Simple-객체를-찾던가”"><a href="#“아니면-어딘가에-있을-Simple-객체를-찾던가”" class="headerlink" title="“아니면 어딘가에 있을 Simple 객체를 찾던가”"></a>“아니면 어딘가에 있을 Simple 객체를 찾던가”</h5><p><br></br></p>
<p>이는 불합리하게 느껴질 수밖에 없다. get_count 메소드 내에서 하는 일은 객체와 아무 관련이 없기 때문이다. (self를 가지고 무엇인가를 하는 일은 전혀 없다.) 그래서 이러한 상황에서 유용하게 사용하라고 존재하는 것이 바로 ‘static 메소드’이다. 이는 클래스 변수와 상당히 유사하다. 클래스 변수와 마찬가지로 객체에 속하지 않고 클래스에 속한다. 즉 클래스에 속하는 메소드이다. 그럼 이와 관련해서 다음 예를 보자.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sm</span><span class="params">()</span>:</span>   <span class="comment"># static 메소드는 첫 번째 인자로 self가 없다!</span></span><br><span class="line">        print(<span class="string">'static method!'</span>)</span><br><span class="line">    sm = staticmethod(sm)   <span class="comment"># sm 메소드를 static 메소드로 만드는 방법이다.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    Simple.sm()   <span class="comment"># static 메소드는 클래스 이름을 통해 호출 가능</span></span><br><span class="line">    s = Simple()</span><br><span class="line">    s.sm()    <span class="comment"># static 메소드는 객체를 통해서도 호출 가능</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line">static method!</span><br><span class="line">static method!</span><br></pre></td></tr></table></figure>
<p>우선 static 메소드와 인스턴스 메소드의 외형적인 차이점은 다음과 같다.</p>
<p><br></br></p>
<h5 id="“static-메소드는-첫-번째-인자로-self를-전달받지-않는다-”"><a href="#“static-메소드는-첫-번째-인자로-self를-전달받지-않는다-”" class="headerlink" title="“static 메소드는 첫 번째 인자로 self를 전달받지 않는다.”"></a>“static 메소드는 첫 번째 인자로 self를 전달받지 않는다.”</h5><p><br></br></p>
<p>이는 객체가 아닌 클래스에 속한 메소드이기 때문에 그렇다. 그리고 이러한 메소드를 준비했다면 다음과 같이 데코레이터 함수 staticmethod를 통과시켜서 실제로 그 메소드가 static 메소드가 되게 해야 한다.</p>
<p>물론 전에 배운 내용을 기반으로 위의 클래스 정의는 다음과 같이 줄여서 쓸 수도 있고 또 이 방법을 훨씬 권장한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sm</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'static method!'</span>)</span><br></pre></td></tr></table></figure>
<p>그럼 생성된 객체의 수를 세는 앞서 보인 예제를 수정해보겠다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Simple.count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod   # 아래의 메소드를 static 메소드로 선언!</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_count</span><span class="params">()</span>:</span>   <span class="comment"># 매개변수로 self가 없는 static 메소드</span></span><br><span class="line">        <span class="keyword">return</span> Simple.count</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(Simple.get_count())   <span class="comment"># 객체가 없는 상태에서도 객체의 수를 물을 수 있다.</span></span><br><span class="line">    s = Simple()</span><br><span class="line">    print(Simple.get_count())</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>위 예제를 통해서 static 메소드를 만드는 방법뿐 아니라 static 메소드 내에서 클래스 변수에 접근하는 방법도 알 수 있다.</p>
<p><br></br></p>
<h4 id="class-메소드"><a href="#class-메소드" class="headerlink" title="[class 메소드]"></a>[class 메소드]</h4><p>static 메소드와 상당히 유사한 메소드로 ‘class 메소드’라는 것이 있다. 일단 다음 예제를 통해서 두 메소드의 외형적 차이를 정리하겠다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span>:</span></span><br><span class="line">    num = <span class="number">5</span>   <span class="comment"># 클래스 변수</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sm</span><span class="params">(i)</span>:</span>  <span class="comment"># static 메소드</span></span><br><span class="line">        print(<span class="string">'st~ 5 + &#123;0&#125; = &#123;1&#125;'</span>.format(i, Simple.num + i))</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cm</span><span class="params">(cls, i)</span>:</span>  <span class="comment"># class 메소드</span></span><br><span class="line">        print(<span class="string">'cl~ 5 + &#123;0&#125; = &#123;1&#125;'</span>.format(i, Simple.num + i))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    Simple.sm(<span class="number">3</span>)  <span class="comment"># 클래스 이름 기반의 static 메소드 호출</span></span><br><span class="line">    Simple.cm(<span class="number">3</span>)  <span class="comment"># 클래스 이름 기반의 class 메소드 호출</span></span><br><span class="line">    s = Simple()</span><br><span class="line">    s.sm(<span class="number">4</span>)   <span class="comment"># 객체를 대상으로 한 static 메소드 호출</span></span><br><span class="line">    s.cm(<span class="number">4</span>)   <span class="comment"># 객체를 대상으로 한 class 메소드 호출</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line">st~ <span class="number">5</span> + <span class="number">3</span> = <span class="number">8</span></span><br><span class="line">cl~ <span class="number">5</span> + <span class="number">3</span> = <span class="number">8</span></span><br><span class="line">st~ <span class="number">5</span> + <span class="number">4</span> = <span class="number">9</span></span><br><span class="line">cl~ <span class="number">5</span> + <span class="number">4</span> = <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>우선 static 메소드 그리고 class 메소드의 외형적 차이는 첫 번째 매개변수 cls의 유무에 있다. (꼭 이름이 cls일 필요는 없지만 이 위치에서는 이 이름을 쓰는 것이 관례이다.)</p>
<p>그런데 예제의 cm 메소드 호출문을 보면 알 수 있듯이, 첫 번째 매개변수에 값을 직접 전달하지는 않는다. 즉, cls를 무시하고 i에만 값을 전달한다.</p>
<p>그렇다면 cls에 전달되는 것을 무엇일까? 아직 이에 대한 설명은 하지 않았지만 위 예제를 통해서 다음과 같이 결론 내릴 수 있다.</p>
<p><br></br></p>
<h5 id="“첫-번째-매개변수-cls를-빼고-보면-static-메소드와-class-메소드는-동일하다-”"><a href="#“첫-번째-매개변수-cls를-빼고-보면-static-메소드와-class-메소드는-동일하다-”" class="headerlink" title="“첫 번째 매개변수 cls를 빼고 보면 static 메소드와 class 메소드는 동일하다.”"></a>“첫 번째 매개변수 cls를 빼고 보면 static 메소드와 class 메소드는 동일하다.”</h5><h5 id="“그리고-cls에는-자동으로-전달되는-무엇인가가-있는-게-분명하다-”"><a href="#“그리고-cls에는-자동으로-전달되는-무엇인가가-있는-게-분명하다-”" class="headerlink" title="“그리고 cls에는 자동으로 전달되는 무엇인가가 있는 게 분명하다.”"></a>“그리고 cls에는 자동으로 전달되는 무엇인가가 있는 게 분명하다.”</h5><p><br></br></p>
<p>자! 그럼 이어서 다음 예제를 보자. 이 예제는 class 메소드의 첫 번째 인자로 전달되는 것이 무엇인지 보여준다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span>:</span></span><br><span class="line">    count = <span class="number">0</span>   <span class="comment"># 생성된 객체의 수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Simple.count += <span class="number">1</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_count</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.count   <span class="comment"># cls에 전달되는 것은 Simple 클래스</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(Simple.get_count())</span><br><span class="line">    s = Simple()</span><br><span class="line">    print(Simple.get_count())</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>클래스 메소드의 첫 번째 인자로 전달되는 것은 이 메소드의 클래스이다. (파이썬은 클래스도 객체이기 때문에 인자로 전달 및 반환이 가능하다.) 즉 위의 예에서는 다음과 같이 get_count가 호출되었으므로,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Simple.get_count()   <span class="comment"># 이 경우 get_count의 cls에 전달되는 것은 Simple 클래스</span></span><br></pre></td></tr></table></figure>
<p>get_count에 매개변수 cls에 전달되는 것은 Simple 클래스이다. 따라서 위의 return문은 다음과 같이 이해할 수 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Simple.count</span><br></pre></td></tr></table></figure>
<p>cls에 전달되는 것은 Simple 클래스이므로 다음 예에서 보듯이 이를 기반으로 객체를 생성하는 것도 가능하다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Natural</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getn</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.n</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(cls, n1, n2)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(n1.getn() + n2.getn())   <span class="comment"># Natural 객체를 생성 후 반환</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n1 = Natural(<span class="number">1</span>)</span><br><span class="line">    n2 = Natural(<span class="number">2</span>)</span><br><span class="line">    n3 = Natural.add(n1, n2)   <span class="comment"># 반환되는 객체를 n3에 저장</span></span><br><span class="line">    print(<span class="string">'&#123;0&#125; + &#123;1&#125; = &#123;2&#125;'</span>.format(n1.getn(), n2.getn(), n3.getn()))</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행결과</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>위 예제의 add 메소드의 cls에 전달되는 것은 Natural 클래스이다.<br>따라서 add의 return문은 Natural 객체의 생성 및 반환으로 이어진다. </p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="disabled" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo" target="_blank" rel="noopener">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/01/20/SEM-%EC%B8%A1%EC%A0%95%EB%AA%A8%ED%98%95/">[SEM] 측정모형</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/01/15/edwith-%EC%9B%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B8%B0%EC%B4%88/">[edwith] 웹 프로그래밍 기초</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/01/14/fnlp-%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC-1/">[FNLP] 밑바닥부터 시작하는 자연어처리 (</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/12/25/SEM-%EC%B8%A1%EC%A0%95%EB%AA%A8%ED%98%95%EC%9D%98-%ED%99%95%EC%9E%A5/">[SEM] 측정모형의 확장</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/algorithm/">algorithm</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/algorithm/selection-sort/">selection sort</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/natural-language-processing/">Natural Language Processi</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/vuejs/">vuejs</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

</body>

</html>